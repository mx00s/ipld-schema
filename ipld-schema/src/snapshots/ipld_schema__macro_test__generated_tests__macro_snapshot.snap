---
source: ipld-schema/src/macro_test.rs
expression: "String::from_utf8_lossy(&std::process::Command::new(\"cargo\").args(&[\"expand\",\n                                                                    \"--manifest-path\",\n                                                                    manifest,\n                                                                    \"--lib\",\n                                                                    \"--tests\",\n                                                                    parent_module]).output().unwrap().stdout)"
---
#[cfg(test)]
pub mod macro_test {
    use ipld_schema_macros::schema_data_types;
    use serde::{Serialize, Deserialize};
    type Bool = bool;
    type Bytes = Vec<u8>;
    type Int = i64;
    type Float = f64;
    type Map<K, V> = std::collections::BTreeMap<K, V>;
    struct AdvancedDataLayout {}
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for AdvancedDataLayout {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "AdvancedDataLayout",
                    false as usize,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for AdvancedDataLayout {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"field index 0 <= i < 0",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::export::PhantomData<AdvancedDataLayout>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = AdvancedDataLayout;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(
                            __formatter,
                            "struct AdvancedDataLayout",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        _: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        _serde::export::Ok(AdvancedDataLayout {})
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        while let _serde::export::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            }
                        {
                            match __key {
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        _serde::export::Ok(AdvancedDataLayout {})
                    }
                }
                const FIELDS: &'static [&'static str] = &[];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "AdvancedDataLayout",
                    FIELDS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<AdvancedDataLayout>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    impl ::core::marker::StructuralPartialEq for AdvancedDataLayout {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for AdvancedDataLayout {
        #[inline]
        fn eq(&self, other: &AdvancedDataLayout) -> bool {
            match *other {
                AdvancedDataLayout {} => match *self {
                    AdvancedDataLayout {} => true,
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialOrd for AdvancedDataLayout {
        #[inline]
        fn partial_cmp(
            &self,
            other: &AdvancedDataLayout,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match *other {
                AdvancedDataLayout {} => match *self {
                    AdvancedDataLayout {} => {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                    }
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for AdvancedDataLayout {
        #[inline]
        fn clone(&self) -> AdvancedDataLayout {
            match *self {
                AdvancedDataLayout {} => AdvancedDataLayout {},
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for AdvancedDataLayout {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                AdvancedDataLayout {} => {
                    let mut debug_trait_builder = f.debug_struct("AdvancedDataLayout");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    impl proptest::arbitrary::Arbitrary for AdvancedDataLayout {
        type Parameters = ();
        type Strategy = proptest::strategy::BoxedStrategy<Self>;
        fn arbitrary_with(args: Self::Parameters) -> Self::Strategy {
            #[allow(dead_code)]
            fn _to_fn_ptr<T>(f: fn(&T) -> bool) -> fn(&T) -> bool {
                f
            }
            let args = std::rc::Rc::new(args);
            proptest::strategy::Strategy::boxed(proptest::strategy::LazyJust::new(|| Self {}))
        }
    }
    struct AdvancedDataLayoutMap(Map<AdvancedDataLayoutName, AdvancedDataLayout>);
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for AdvancedDataLayoutMap {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                _serde::Serializer::serialize_newtype_struct(
                    __serializer,
                    "AdvancedDataLayoutMap",
                    &self.0,
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for AdvancedDataLayoutMap {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                struct __Visitor<'de> {
                    marker: _serde::export::PhantomData<AdvancedDataLayoutMap>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = AdvancedDataLayoutMap;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(
                            __formatter,
                            "tuple struct AdvancedDataLayoutMap",
                        )
                    }
                    #[inline]
                    fn visit_newtype_struct<__E>(
                        self,
                        __e: __E,
                    ) -> _serde::export::Result<Self::Value, __E::Error>
                    where
                        __E: _serde::Deserializer<'de>,
                    {
                        let __field0 : Map < AdvancedDataLayoutName , AdvancedDataLayout > = match < Map < AdvancedDataLayoutName , AdvancedDataLayout > as _serde :: Deserialize > :: deserialize (__e) { _serde :: export :: Ok (__val) => __val , _serde :: export :: Err (__err) => { return _serde :: export :: Err (__err) ; } } ;
                        _serde::export::Ok(AdvancedDataLayoutMap(__field0))
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                            Map<AdvancedDataLayoutName, AdvancedDataLayout>,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    0usize,
                                    &"tuple struct AdvancedDataLayoutMap with 1 element",
                                ));
                            }
                        };
                        _serde::export::Ok(AdvancedDataLayoutMap(__field0))
                    }
                }
                _serde::Deserializer::deserialize_newtype_struct(
                    __deserializer,
                    "AdvancedDataLayoutMap",
                    __Visitor {
                        marker: _serde::export::PhantomData::<AdvancedDataLayoutMap>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    impl ::core::marker::StructuralPartialEq for AdvancedDataLayoutMap {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for AdvancedDataLayoutMap {
        #[inline]
        fn eq(&self, other: &AdvancedDataLayoutMap) -> bool {
            match *other {
                AdvancedDataLayoutMap(ref __self_1_0) => match *self {
                    AdvancedDataLayoutMap(ref __self_0_0) => (*__self_0_0) == (*__self_1_0),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &AdvancedDataLayoutMap) -> bool {
            match *other {
                AdvancedDataLayoutMap(ref __self_1_0) => match *self {
                    AdvancedDataLayoutMap(ref __self_0_0) => (*__self_0_0) != (*__self_1_0),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialOrd for AdvancedDataLayoutMap {
        #[inline]
        fn partial_cmp(
            &self,
            other: &AdvancedDataLayoutMap,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match *other {
                AdvancedDataLayoutMap(ref __self_1_0) => match *self {
                    AdvancedDataLayoutMap(ref __self_0_0) => {
                        match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0), &(*__self_1_0)) {
                            ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                            }
                            cmp => cmp,
                        }
                    }
                },
            }
        }
        #[inline]
        fn lt(&self, other: &AdvancedDataLayoutMap) -> bool {
            match *other {
                AdvancedDataLayoutMap(ref __self_1_0) => match *self {
                    AdvancedDataLayoutMap(ref __self_0_0) => {
                        ::core::option::Option::unwrap_or(
                            ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0), &(*__self_1_0)),
                            ::core::cmp::Ordering::Greater,
                        ) == ::core::cmp::Ordering::Less
                    }
                },
            }
        }
        #[inline]
        fn le(&self, other: &AdvancedDataLayoutMap) -> bool {
            match *other {
                AdvancedDataLayoutMap(ref __self_1_0) => match *self {
                    AdvancedDataLayoutMap(ref __self_0_0) => {
                        ::core::option::Option::unwrap_or(
                            ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0), &(*__self_1_0)),
                            ::core::cmp::Ordering::Greater,
                        ) != ::core::cmp::Ordering::Greater
                    }
                },
            }
        }
        #[inline]
        fn gt(&self, other: &AdvancedDataLayoutMap) -> bool {
            match *other {
                AdvancedDataLayoutMap(ref __self_1_0) => match *self {
                    AdvancedDataLayoutMap(ref __self_0_0) => {
                        ::core::option::Option::unwrap_or(
                            ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0), &(*__self_1_0)),
                            ::core::cmp::Ordering::Less,
                        ) == ::core::cmp::Ordering::Greater
                    }
                },
            }
        }
        #[inline]
        fn ge(&self, other: &AdvancedDataLayoutMap) -> bool {
            match *other {
                AdvancedDataLayoutMap(ref __self_1_0) => match *self {
                    AdvancedDataLayoutMap(ref __self_0_0) => {
                        ::core::option::Option::unwrap_or(
                            ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0), &(*__self_1_0)),
                            ::core::cmp::Ordering::Less,
                        ) != ::core::cmp::Ordering::Less
                    }
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for AdvancedDataLayoutMap {
        #[inline]
        fn clone(&self) -> AdvancedDataLayoutMap {
            match *self {
                AdvancedDataLayoutMap(ref __self_0_0) => {
                    AdvancedDataLayoutMap(::core::clone::Clone::clone(&(*__self_0_0)))
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for AdvancedDataLayoutMap {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                AdvancedDataLayoutMap(ref __self_0_0) => {
                    let mut debug_trait_builder = f.debug_tuple("AdvancedDataLayoutMap");
                    let _ = debug_trait_builder.field(&&(*__self_0_0));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    impl proptest::arbitrary::Arbitrary for AdvancedDataLayoutMap {
        type Parameters = ();
        type Strategy = proptest::strategy::BoxedStrategy<Self>;
        fn arbitrary_with(args: Self::Parameters) -> Self::Strategy {
            #[allow(dead_code)]
            fn _to_fn_ptr<T>(f: fn(&T) -> bool) -> fn(&T) -> bool {
                f
            }
            let args = std::rc::Rc::new(args);
            proptest::strategy::Strategy::boxed({
                let strategy_0 = ({
                    #[allow(dead_code)]
                    fn _strategy_of_0<
                        T: std::fmt::Debug,
                        S: proptest::strategy::Strategy<Value = T>,
                    >(
                        s: S,
                    ) -> impl proptest::strategy::Strategy<Value = T> {
                        s
                    }
                    let _s = proptest::arbitrary::any::<
                        Map<AdvancedDataLayoutName, AdvancedDataLayout>,
                    >();
                    _s
                },);
                let strategy_0 =
                    proptest::strategy::Strategy::prop_map(strategy_0, |_values| Self(_values.0));
                strategy_0
            })
        }
    }
    struct AdvancedDataLayoutName(String);
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for AdvancedDataLayoutName {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                _serde::Serializer::serialize_newtype_struct(
                    __serializer,
                    "AdvancedDataLayoutName",
                    &self.0,
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for AdvancedDataLayoutName {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                struct __Visitor<'de> {
                    marker: _serde::export::PhantomData<AdvancedDataLayoutName>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = AdvancedDataLayoutName;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(
                            __formatter,
                            "tuple struct AdvancedDataLayoutName",
                        )
                    }
                    #[inline]
                    fn visit_newtype_struct<__E>(
                        self,
                        __e: __E,
                    ) -> _serde::export::Result<Self::Value, __E::Error>
                    where
                        __E: _serde::Deserializer<'de>,
                    {
                        let __field0: String =
                            match <String as _serde::Deserialize>::deserialize(__e) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            };
                        _serde::export::Ok(AdvancedDataLayoutName(__field0))
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 =
                            match match _serde::de::SeqAccess::next_element::<String>(&mut __seq) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        0usize,
                                        &"tuple struct AdvancedDataLayoutName with 1 element",
                                    ));
                                }
                            };
                        _serde::export::Ok(AdvancedDataLayoutName(__field0))
                    }
                }
                _serde::Deserializer::deserialize_newtype_struct(
                    __deserializer,
                    "AdvancedDataLayoutName",
                    __Visitor {
                        marker: _serde::export::PhantomData::<AdvancedDataLayoutName>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    impl ::core::marker::StructuralPartialEq for AdvancedDataLayoutName {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for AdvancedDataLayoutName {
        #[inline]
        fn eq(&self, other: &AdvancedDataLayoutName) -> bool {
            match *other {
                AdvancedDataLayoutName(ref __self_1_0) => match *self {
                    AdvancedDataLayoutName(ref __self_0_0) => (*__self_0_0) == (*__self_1_0),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &AdvancedDataLayoutName) -> bool {
            match *other {
                AdvancedDataLayoutName(ref __self_1_0) => match *self {
                    AdvancedDataLayoutName(ref __self_0_0) => (*__self_0_0) != (*__self_1_0),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialOrd for AdvancedDataLayoutName {
        #[inline]
        fn partial_cmp(
            &self,
            other: &AdvancedDataLayoutName,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match *other {
                AdvancedDataLayoutName(ref __self_1_0) => match *self {
                    AdvancedDataLayoutName(ref __self_0_0) => {
                        match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0), &(*__self_1_0)) {
                            ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                            }
                            cmp => cmp,
                        }
                    }
                },
            }
        }
        #[inline]
        fn lt(&self, other: &AdvancedDataLayoutName) -> bool {
            match *other {
                AdvancedDataLayoutName(ref __self_1_0) => match *self {
                    AdvancedDataLayoutName(ref __self_0_0) => {
                        ::core::option::Option::unwrap_or(
                            ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0), &(*__self_1_0)),
                            ::core::cmp::Ordering::Greater,
                        ) == ::core::cmp::Ordering::Less
                    }
                },
            }
        }
        #[inline]
        fn le(&self, other: &AdvancedDataLayoutName) -> bool {
            match *other {
                AdvancedDataLayoutName(ref __self_1_0) => match *self {
                    AdvancedDataLayoutName(ref __self_0_0) => {
                        ::core::option::Option::unwrap_or(
                            ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0), &(*__self_1_0)),
                            ::core::cmp::Ordering::Greater,
                        ) != ::core::cmp::Ordering::Greater
                    }
                },
            }
        }
        #[inline]
        fn gt(&self, other: &AdvancedDataLayoutName) -> bool {
            match *other {
                AdvancedDataLayoutName(ref __self_1_0) => match *self {
                    AdvancedDataLayoutName(ref __self_0_0) => {
                        ::core::option::Option::unwrap_or(
                            ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0), &(*__self_1_0)),
                            ::core::cmp::Ordering::Less,
                        ) == ::core::cmp::Ordering::Greater
                    }
                },
            }
        }
        #[inline]
        fn ge(&self, other: &AdvancedDataLayoutName) -> bool {
            match *other {
                AdvancedDataLayoutName(ref __self_1_0) => match *self {
                    AdvancedDataLayoutName(ref __self_0_0) => {
                        ::core::option::Option::unwrap_or(
                            ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0), &(*__self_1_0)),
                            ::core::cmp::Ordering::Less,
                        ) != ::core::cmp::Ordering::Less
                    }
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for AdvancedDataLayoutName {
        #[inline]
        fn clone(&self) -> AdvancedDataLayoutName {
            match *self {
                AdvancedDataLayoutName(ref __self_0_0) => {
                    AdvancedDataLayoutName(::core::clone::Clone::clone(&(*__self_0_0)))
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for AdvancedDataLayoutName {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                AdvancedDataLayoutName(ref __self_0_0) => {
                    let mut debug_trait_builder = f.debug_tuple("AdvancedDataLayoutName");
                    let _ = debug_trait_builder.field(&&(*__self_0_0));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    impl proptest::arbitrary::Arbitrary for AdvancedDataLayoutName {
        type Parameters = ();
        type Strategy = proptest::strategy::BoxedStrategy<Self>;
        fn arbitrary_with(args: Self::Parameters) -> Self::Strategy {
            #[allow(dead_code)]
            fn _to_fn_ptr<T>(f: fn(&T) -> bool) -> fn(&T) -> bool {
                f
            }
            let args = std::rc::Rc::new(args);
            proptest::strategy::Strategy::boxed({
                let strategy_0 = ({
                    #[allow(dead_code)]
                    fn _strategy_of_0<
                        T: std::fmt::Debug,
                        S: proptest::strategy::Strategy<Value = T>,
                    >(
                        s: S,
                    ) -> impl proptest::strategy::Strategy<Value = T> {
                        s
                    }
                    let _s = proptest::arbitrary::any::<String>();
                    _s
                },);
                let strategy_0 =
                    proptest::strategy::Strategy::prop_map(strategy_0, |_values| Self(_values.0));
                strategy_0
            })
        }
    }
    impl ::core::marker::StructuralEq for AdvancedDataLayoutName {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::Eq for AdvancedDataLayoutName {
        #[inline]
        #[doc(hidden)]
        fn assert_receiver_is_total_eq(&self) -> () {
            {
                let _: ::core::cmp::AssertParamIsEq<String>;
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::Ord for AdvancedDataLayoutName {
        #[inline]
        fn cmp(&self, other: &AdvancedDataLayoutName) -> ::core::cmp::Ordering {
            match *other {
                AdvancedDataLayoutName(ref __self_1_0) => match *self {
                    AdvancedDataLayoutName(ref __self_0_0) => {
                        match ::core::cmp::Ord::cmp(&(*__self_0_0), &(*__self_1_0)) {
                            ::core::cmp::Ordering::Equal => ::core::cmp::Ordering::Equal,
                            cmp => cmp,
                        }
                    }
                },
            }
        }
    }
    enum AnyScalar {
        Bool(Bool),
        String(String),
        Bytes(Bytes),
        Int(Int),
        Float(Float),
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for AnyScalar {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    AnyScalar::Bool(ref __field0) => _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "AnyScalar",
                        0u32,
                        "Bool",
                        __field0,
                    ),
                    AnyScalar::String(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "AnyScalar",
                            1u32,
                            "String",
                            __field0,
                        )
                    }
                    AnyScalar::Bytes(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "AnyScalar",
                            2u32,
                            "Bytes",
                            __field0,
                        )
                    }
                    AnyScalar::Int(ref __field0) => _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "AnyScalar",
                        3u32,
                        "Int",
                        __field0,
                    ),
                    AnyScalar::Float(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "AnyScalar",
                            4u32,
                            "Float",
                            __field0,
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for AnyScalar {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "variant identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::export::Ok(__Field::__field0),
                            1u64 => _serde::export::Ok(__Field::__field1),
                            2u64 => _serde::export::Ok(__Field::__field2),
                            3u64 => _serde::export::Ok(__Field::__field3),
                            4u64 => _serde::export::Ok(__Field::__field4),
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"variant index 0 <= i < 5",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "Bool" => _serde::export::Ok(__Field::__field0),
                            "String" => _serde::export::Ok(__Field::__field1),
                            "Bytes" => _serde::export::Ok(__Field::__field2),
                            "Int" => _serde::export::Ok(__Field::__field3),
                            "Float" => _serde::export::Ok(__Field::__field4),
                            _ => _serde::export::Err(_serde::de::Error::unknown_variant(
                                __value, VARIANTS,
                            )),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"Bool" => _serde::export::Ok(__Field::__field0),
                            b"String" => _serde::export::Ok(__Field::__field1),
                            b"Bytes" => _serde::export::Ok(__Field::__field2),
                            b"Int" => _serde::export::Ok(__Field::__field3),
                            b"Float" => _serde::export::Ok(__Field::__field4),
                            _ => {
                                let __value = &_serde::export::from_utf8_lossy(__value);
                                _serde::export::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                ))
                            }
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::export::PhantomData<AnyScalar>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = AnyScalar;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "enum AnyScalar")
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match match _serde::de::EnumAccess::variant(__data) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            (__Field::__field0, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<Bool>(__variant),
                                AnyScalar::Bool,
                            ),
                            (__Field::__field1, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<String>(__variant),
                                AnyScalar::String,
                            ),
                            (__Field::__field2, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<Bytes>(__variant),
                                AnyScalar::Bytes,
                            ),
                            (__Field::__field3, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<Int>(__variant),
                                AnyScalar::Int,
                            ),
                            (__Field::__field4, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<Float>(__variant),
                                AnyScalar::Float,
                            ),
                        }
                    }
                }
                const VARIANTS: &'static [&'static str] =
                    &["Bool", "String", "Bytes", "Int", "Float"];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "AnyScalar",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<AnyScalar>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    impl ::core::marker::StructuralPartialEq for AnyScalar {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for AnyScalar {
        #[inline]
        fn eq(&self, other: &AnyScalar) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&AnyScalar::Bool(ref __self_0), &AnyScalar::Bool(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        (&AnyScalar::String(ref __self_0), &AnyScalar::String(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        (&AnyScalar::Bytes(ref __self_0), &AnyScalar::Bytes(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        (&AnyScalar::Int(ref __self_0), &AnyScalar::Int(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        (&AnyScalar::Float(ref __self_0), &AnyScalar::Float(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    false
                }
            }
        }
        #[inline]
        fn ne(&self, other: &AnyScalar) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&AnyScalar::Bool(ref __self_0), &AnyScalar::Bool(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        (&AnyScalar::String(ref __self_0), &AnyScalar::String(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        (&AnyScalar::Bytes(ref __self_0), &AnyScalar::Bytes(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        (&AnyScalar::Int(ref __self_0), &AnyScalar::Int(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        (&AnyScalar::Float(ref __self_0), &AnyScalar::Float(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    true
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialOrd for AnyScalar {
        #[inline]
        fn partial_cmp(&self, other: &AnyScalar) -> ::core::option::Option<::core::cmp::Ordering> {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&AnyScalar::Bool(ref __self_0), &AnyScalar::Bool(ref __arg_1_0)) => {
                            match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0))
                            {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                }
                                cmp => cmp,
                            }
                        }
                        (&AnyScalar::String(ref __self_0), &AnyScalar::String(ref __arg_1_0)) => {
                            match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0))
                            {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                }
                                cmp => cmp,
                            }
                        }
                        (&AnyScalar::Bytes(ref __self_0), &AnyScalar::Bytes(ref __arg_1_0)) => {
                            match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0))
                            {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                }
                                cmp => cmp,
                            }
                        }
                        (&AnyScalar::Int(ref __self_0), &AnyScalar::Int(ref __arg_1_0)) => {
                            match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0))
                            {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                }
                                cmp => cmp,
                            }
                        }
                        (&AnyScalar::Float(ref __self_0), &AnyScalar::Float(ref __arg_1_0)) => {
                            match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0))
                            {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                }
                                cmp => cmp,
                            }
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    __self_vi.partial_cmp(&__arg_1_vi)
                }
            }
        }
        #[inline]
        fn lt(&self, other: &AnyScalar) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&AnyScalar::Bool(ref __self_0), &AnyScalar::Bool(ref __arg_1_0)) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Greater,
                            ) == ::core::cmp::Ordering::Less
                        }
                        (&AnyScalar::String(ref __self_0), &AnyScalar::String(ref __arg_1_0)) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Greater,
                            ) == ::core::cmp::Ordering::Less
                        }
                        (&AnyScalar::Bytes(ref __self_0), &AnyScalar::Bytes(ref __arg_1_0)) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Greater,
                            ) == ::core::cmp::Ordering::Less
                        }
                        (&AnyScalar::Int(ref __self_0), &AnyScalar::Int(ref __arg_1_0)) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Greater,
                            ) == ::core::cmp::Ordering::Less
                        }
                        (&AnyScalar::Float(ref __self_0), &AnyScalar::Float(ref __arg_1_0)) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Greater,
                            ) == ::core::cmp::Ordering::Less
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    __self_vi.lt(&__arg_1_vi)
                }
            }
        }
        #[inline]
        fn le(&self, other: &AnyScalar) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&AnyScalar::Bool(ref __self_0), &AnyScalar::Bool(ref __arg_1_0)) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Greater,
                            ) != ::core::cmp::Ordering::Greater
                        }
                        (&AnyScalar::String(ref __self_0), &AnyScalar::String(ref __arg_1_0)) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Greater,
                            ) != ::core::cmp::Ordering::Greater
                        }
                        (&AnyScalar::Bytes(ref __self_0), &AnyScalar::Bytes(ref __arg_1_0)) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Greater,
                            ) != ::core::cmp::Ordering::Greater
                        }
                        (&AnyScalar::Int(ref __self_0), &AnyScalar::Int(ref __arg_1_0)) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Greater,
                            ) != ::core::cmp::Ordering::Greater
                        }
                        (&AnyScalar::Float(ref __self_0), &AnyScalar::Float(ref __arg_1_0)) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Greater,
                            ) != ::core::cmp::Ordering::Greater
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    __self_vi.le(&__arg_1_vi)
                }
            }
        }
        #[inline]
        fn gt(&self, other: &AnyScalar) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&AnyScalar::Bool(ref __self_0), &AnyScalar::Bool(ref __arg_1_0)) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Less,
                            ) == ::core::cmp::Ordering::Greater
                        }
                        (&AnyScalar::String(ref __self_0), &AnyScalar::String(ref __arg_1_0)) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Less,
                            ) == ::core::cmp::Ordering::Greater
                        }
                        (&AnyScalar::Bytes(ref __self_0), &AnyScalar::Bytes(ref __arg_1_0)) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Less,
                            ) == ::core::cmp::Ordering::Greater
                        }
                        (&AnyScalar::Int(ref __self_0), &AnyScalar::Int(ref __arg_1_0)) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Less,
                            ) == ::core::cmp::Ordering::Greater
                        }
                        (&AnyScalar::Float(ref __self_0), &AnyScalar::Float(ref __arg_1_0)) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Less,
                            ) == ::core::cmp::Ordering::Greater
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    __self_vi.gt(&__arg_1_vi)
                }
            }
        }
        #[inline]
        fn ge(&self, other: &AnyScalar) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&AnyScalar::Bool(ref __self_0), &AnyScalar::Bool(ref __arg_1_0)) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Less,
                            ) != ::core::cmp::Ordering::Less
                        }
                        (&AnyScalar::String(ref __self_0), &AnyScalar::String(ref __arg_1_0)) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Less,
                            ) != ::core::cmp::Ordering::Less
                        }
                        (&AnyScalar::Bytes(ref __self_0), &AnyScalar::Bytes(ref __arg_1_0)) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Less,
                            ) != ::core::cmp::Ordering::Less
                        }
                        (&AnyScalar::Int(ref __self_0), &AnyScalar::Int(ref __arg_1_0)) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Less,
                            ) != ::core::cmp::Ordering::Less
                        }
                        (&AnyScalar::Float(ref __self_0), &AnyScalar::Float(ref __arg_1_0)) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Less,
                            ) != ::core::cmp::Ordering::Less
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    __self_vi.ge(&__arg_1_vi)
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for AnyScalar {
        #[inline]
        fn clone(&self) -> AnyScalar {
            match (&*self,) {
                (&AnyScalar::Bool(ref __self_0),) => {
                    AnyScalar::Bool(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&AnyScalar::String(ref __self_0),) => {
                    AnyScalar::String(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&AnyScalar::Bytes(ref __self_0),) => {
                    AnyScalar::Bytes(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&AnyScalar::Int(ref __self_0),) => {
                    AnyScalar::Int(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&AnyScalar::Float(ref __self_0),) => {
                    AnyScalar::Float(::core::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for AnyScalar {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&AnyScalar::Bool(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("Bool");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&AnyScalar::String(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("String");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&AnyScalar::Bytes(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("Bytes");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&AnyScalar::Int(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("Int");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&AnyScalar::Float(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("Float");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    impl proptest::arbitrary::Arbitrary for AnyScalar {
        type Parameters = ();
        type Strategy = proptest::strategy::BoxedStrategy<Self>;
        fn arbitrary_with(args: Self::Parameters) -> Self::Strategy {
            #[allow(dead_code)]
            fn _to_fn_ptr<T>(f: fn(&T) -> bool) -> fn(&T) -> bool {
                f
            }
            let args = std::rc::Rc::new(args);
            proptest::strategy::Strategy::boxed({
                #[allow(dead_code)]
                fn _to_weight(weight: u32) -> u32 {
                    weight
                }
                let _s = ::proptest::strategy::TupleUnion::new((
                    (
                        1,
                        ::proptest::std_facade::Arc::new({
                            let strategy_0 = ({
                                #[allow(dead_code)]
                                fn _strategy_of_0<
                                    T: std::fmt::Debug,
                                    S: proptest::strategy::Strategy<Value = T>,
                                >(
                                    s: S,
                                ) -> impl proptest::strategy::Strategy<Value = T>
                                {
                                    s
                                }
                                let _s = proptest::arbitrary::any::<Bool>();
                                _s
                            },);
                            let strategy_0 =
                                proptest::strategy::Strategy::prop_map(strategy_0, |_values| {
                                    Self::Bool(_values.0)
                                });
                            strategy_0
                        }),
                    ),
                    (
                        1,
                        ::proptest::std_facade::Arc::new({
                            let strategy_0 = ({
                                #[allow(dead_code)]
                                fn _strategy_of_0<
                                    T: std::fmt::Debug,
                                    S: proptest::strategy::Strategy<Value = T>,
                                >(
                                    s: S,
                                ) -> impl proptest::strategy::Strategy<Value = T>
                                {
                                    s
                                }
                                let _s = proptest::arbitrary::any::<String>();
                                _s
                            },);
                            let strategy_0 =
                                proptest::strategy::Strategy::prop_map(strategy_0, |_values| {
                                    Self::String(_values.0)
                                });
                            strategy_0
                        }),
                    ),
                    (
                        1,
                        ::proptest::std_facade::Arc::new({
                            let strategy_0 = ({
                                #[allow(dead_code)]
                                fn _strategy_of_0<
                                    T: std::fmt::Debug,
                                    S: proptest::strategy::Strategy<Value = T>,
                                >(
                                    s: S,
                                ) -> impl proptest::strategy::Strategy<Value = T>
                                {
                                    s
                                }
                                let _s = proptest::arbitrary::any::<Bytes>();
                                _s
                            },);
                            let strategy_0 =
                                proptest::strategy::Strategy::prop_map(strategy_0, |_values| {
                                    Self::Bytes(_values.0)
                                });
                            strategy_0
                        }),
                    ),
                    (
                        1,
                        ::proptest::std_facade::Arc::new({
                            let strategy_0 = ({
                                #[allow(dead_code)]
                                fn _strategy_of_0<
                                    T: std::fmt::Debug,
                                    S: proptest::strategy::Strategy<Value = T>,
                                >(
                                    s: S,
                                ) -> impl proptest::strategy::Strategy<Value = T>
                                {
                                    s
                                }
                                let _s = proptest::arbitrary::any::<Int>();
                                _s
                            },);
                            let strategy_0 =
                                proptest::strategy::Strategy::prop_map(strategy_0, |_values| {
                                    Self::Int(_values.0)
                                });
                            strategy_0
                        }),
                    ),
                    (
                        1,
                        ::proptest::std_facade::Arc::new({
                            let strategy_0 = ({
                                #[allow(dead_code)]
                                fn _strategy_of_0<
                                    T: std::fmt::Debug,
                                    S: proptest::strategy::Strategy<Value = T>,
                                >(
                                    s: S,
                                ) -> impl proptest::strategy::Strategy<Value = T>
                                {
                                    s
                                }
                                let _s = proptest::arbitrary::any::<Float>();
                                _s
                            },);
                            let strategy_0 =
                                proptest::strategy::Strategy::prop_map(strategy_0, |_values| {
                                    Self::Float(_values.0)
                                });
                            strategy_0
                        }),
                    ),
                ));
                _s
            })
        }
    }
    enum BytesRepresentation {
        advanced(AdvancedDataLayoutName),
        bytes(BytesRepresentation_Bytes),
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for BytesRepresentation {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    BytesRepresentation::advanced(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "BytesRepresentation",
                            0u32,
                            "advanced",
                            __field0,
                        )
                    }
                    BytesRepresentation::bytes(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "BytesRepresentation",
                            1u32,
                            "bytes",
                            __field0,
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for BytesRepresentation {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "variant identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::export::Ok(__Field::__field0),
                            1u64 => _serde::export::Ok(__Field::__field1),
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"variant index 0 <= i < 2",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "advanced" => _serde::export::Ok(__Field::__field0),
                            "bytes" => _serde::export::Ok(__Field::__field1),
                            _ => _serde::export::Err(_serde::de::Error::unknown_variant(
                                __value, VARIANTS,
                            )),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"advanced" => _serde::export::Ok(__Field::__field0),
                            b"bytes" => _serde::export::Ok(__Field::__field1),
                            _ => {
                                let __value = &_serde::export::from_utf8_lossy(__value);
                                _serde::export::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                ))
                            }
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::export::PhantomData<BytesRepresentation>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = BytesRepresentation;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(
                            __formatter,
                            "enum BytesRepresentation",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match match _serde::de::EnumAccess::variant(__data) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            (__Field::__field0, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<AdvancedDataLayoutName>(
                                    __variant,
                                ),
                                BytesRepresentation::advanced,
                            ),
                            (__Field::__field1, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<
                                    BytesRepresentation_Bytes,
                                >(__variant),
                                BytesRepresentation::bytes,
                            ),
                        }
                    }
                }
                const VARIANTS: &'static [&'static str] = &["advanced", "bytes"];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "BytesRepresentation",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<BytesRepresentation>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    impl ::core::marker::StructuralPartialEq for BytesRepresentation {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for BytesRepresentation {
        #[inline]
        fn eq(&self, other: &BytesRepresentation) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (
                            &BytesRepresentation::advanced(ref __self_0),
                            &BytesRepresentation::advanced(ref __arg_1_0),
                        ) => (*__self_0) == (*__arg_1_0),
                        (
                            &BytesRepresentation::bytes(ref __self_0),
                            &BytesRepresentation::bytes(ref __arg_1_0),
                        ) => (*__self_0) == (*__arg_1_0),
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    false
                }
            }
        }
        #[inline]
        fn ne(&self, other: &BytesRepresentation) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (
                            &BytesRepresentation::advanced(ref __self_0),
                            &BytesRepresentation::advanced(ref __arg_1_0),
                        ) => (*__self_0) != (*__arg_1_0),
                        (
                            &BytesRepresentation::bytes(ref __self_0),
                            &BytesRepresentation::bytes(ref __arg_1_0),
                        ) => (*__self_0) != (*__arg_1_0),
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    true
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialOrd for BytesRepresentation {
        #[inline]
        fn partial_cmp(
            &self,
            other: &BytesRepresentation,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (
                            &BytesRepresentation::advanced(ref __self_0),
                            &BytesRepresentation::advanced(ref __arg_1_0),
                        ) => {
                            match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0))
                            {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                }
                                cmp => cmp,
                            }
                        }
                        (
                            &BytesRepresentation::bytes(ref __self_0),
                            &BytesRepresentation::bytes(ref __arg_1_0),
                        ) => {
                            match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0))
                            {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                }
                                cmp => cmp,
                            }
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    __self_vi.partial_cmp(&__arg_1_vi)
                }
            }
        }
        #[inline]
        fn lt(&self, other: &BytesRepresentation) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (
                            &BytesRepresentation::advanced(ref __self_0),
                            &BytesRepresentation::advanced(ref __arg_1_0),
                        ) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Greater,
                            ) == ::core::cmp::Ordering::Less
                        }
                        (
                            &BytesRepresentation::bytes(ref __self_0),
                            &BytesRepresentation::bytes(ref __arg_1_0),
                        ) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Greater,
                            ) == ::core::cmp::Ordering::Less
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    __self_vi.lt(&__arg_1_vi)
                }
            }
        }
        #[inline]
        fn le(&self, other: &BytesRepresentation) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (
                            &BytesRepresentation::advanced(ref __self_0),
                            &BytesRepresentation::advanced(ref __arg_1_0),
                        ) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Greater,
                            ) != ::core::cmp::Ordering::Greater
                        }
                        (
                            &BytesRepresentation::bytes(ref __self_0),
                            &BytesRepresentation::bytes(ref __arg_1_0),
                        ) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Greater,
                            ) != ::core::cmp::Ordering::Greater
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    __self_vi.le(&__arg_1_vi)
                }
            }
        }
        #[inline]
        fn gt(&self, other: &BytesRepresentation) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (
                            &BytesRepresentation::advanced(ref __self_0),
                            &BytesRepresentation::advanced(ref __arg_1_0),
                        ) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Less,
                            ) == ::core::cmp::Ordering::Greater
                        }
                        (
                            &BytesRepresentation::bytes(ref __self_0),
                            &BytesRepresentation::bytes(ref __arg_1_0),
                        ) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Less,
                            ) == ::core::cmp::Ordering::Greater
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    __self_vi.gt(&__arg_1_vi)
                }
            }
        }
        #[inline]
        fn ge(&self, other: &BytesRepresentation) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (
                            &BytesRepresentation::advanced(ref __self_0),
                            &BytesRepresentation::advanced(ref __arg_1_0),
                        ) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Less,
                            ) != ::core::cmp::Ordering::Less
                        }
                        (
                            &BytesRepresentation::bytes(ref __self_0),
                            &BytesRepresentation::bytes(ref __arg_1_0),
                        ) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Less,
                            ) != ::core::cmp::Ordering::Less
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    __self_vi.ge(&__arg_1_vi)
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for BytesRepresentation {
        #[inline]
        fn clone(&self) -> BytesRepresentation {
            match (&*self,) {
                (&BytesRepresentation::advanced(ref __self_0),) => {
                    BytesRepresentation::advanced(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&BytesRepresentation::bytes(ref __self_0),) => {
                    BytesRepresentation::bytes(::core::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for BytesRepresentation {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&BytesRepresentation::advanced(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("advanced");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&BytesRepresentation::bytes(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("bytes");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    impl proptest::arbitrary::Arbitrary for BytesRepresentation {
        type Parameters = ();
        type Strategy = proptest::strategy::BoxedStrategy<Self>;
        fn arbitrary_with(args: Self::Parameters) -> Self::Strategy {
            #[allow(dead_code)]
            fn _to_fn_ptr<T>(f: fn(&T) -> bool) -> fn(&T) -> bool {
                f
            }
            let args = std::rc::Rc::new(args);
            proptest::strategy::Strategy::boxed({
                #[allow(dead_code)]
                fn _to_weight(weight: u32) -> u32 {
                    weight
                }
                let _s = ::proptest::strategy::TupleUnion::new((
                    (
                        1,
                        ::proptest::std_facade::Arc::new({
                            let strategy_0 = ({
                                #[allow(dead_code)]
                                fn _strategy_of_0<
                                    T: std::fmt::Debug,
                                    S: proptest::strategy::Strategy<Value = T>,
                                >(
                                    s: S,
                                ) -> impl proptest::strategy::Strategy<Value = T>
                                {
                                    s
                                }
                                let _s = proptest::arbitrary::any::<AdvancedDataLayoutName>();
                                _s
                            },);
                            let strategy_0 =
                                proptest::strategy::Strategy::prop_map(strategy_0, |_values| {
                                    Self::advanced(_values.0)
                                });
                            strategy_0
                        }),
                    ),
                    (
                        1,
                        ::proptest::std_facade::Arc::new({
                            let strategy_0 = ({
                                #[allow(dead_code)]
                                fn _strategy_of_0<
                                    T: std::fmt::Debug,
                                    S: proptest::strategy::Strategy<Value = T>,
                                >(
                                    s: S,
                                ) -> impl proptest::strategy::Strategy<Value = T>
                                {
                                    s
                                }
                                let _s = proptest::arbitrary::any::<BytesRepresentation_Bytes>();
                                _s
                            },);
                            let strategy_0 =
                                proptest::strategy::Strategy::prop_map(strategy_0, |_values| {
                                    Self::bytes(_values.0)
                                });
                            strategy_0
                        }),
                    ),
                ));
                _s
            })
        }
    }
    struct BytesRepresentation_Bytes {}
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for BytesRepresentation_Bytes {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "BytesRepresentation_Bytes",
                    false as usize,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for BytesRepresentation_Bytes {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"field index 0 <= i < 0",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::export::PhantomData<BytesRepresentation_Bytes>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = BytesRepresentation_Bytes;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(
                            __formatter,
                            "struct BytesRepresentation_Bytes",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        _: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        _serde::export::Ok(BytesRepresentation_Bytes {})
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        while let _serde::export::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            }
                        {
                            match __key {
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        _serde::export::Ok(BytesRepresentation_Bytes {})
                    }
                }
                const FIELDS: &'static [&'static str] = &[];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "BytesRepresentation_Bytes",
                    FIELDS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<BytesRepresentation_Bytes>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    impl ::core::marker::StructuralPartialEq for BytesRepresentation_Bytes {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for BytesRepresentation_Bytes {
        #[inline]
        fn eq(&self, other: &BytesRepresentation_Bytes) -> bool {
            match *other {
                BytesRepresentation_Bytes {} => match *self {
                    BytesRepresentation_Bytes {} => true,
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialOrd for BytesRepresentation_Bytes {
        #[inline]
        fn partial_cmp(
            &self,
            other: &BytesRepresentation_Bytes,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match *other {
                BytesRepresentation_Bytes {} => match *self {
                    BytesRepresentation_Bytes {} => {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                    }
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for BytesRepresentation_Bytes {
        #[inline]
        fn clone(&self) -> BytesRepresentation_Bytes {
            match *self {
                BytesRepresentation_Bytes {} => BytesRepresentation_Bytes {},
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for BytesRepresentation_Bytes {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                BytesRepresentation_Bytes {} => {
                    let mut debug_trait_builder = f.debug_struct("BytesRepresentation_Bytes");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    impl proptest::arbitrary::Arbitrary for BytesRepresentation_Bytes {
        type Parameters = ();
        type Strategy = proptest::strategy::BoxedStrategy<Self>;
        fn arbitrary_with(args: Self::Parameters) -> Self::Strategy {
            #[allow(dead_code)]
            fn _to_fn_ptr<T>(f: fn(&T) -> bool) -> fn(&T) -> bool {
                f
            }
            let args = std::rc::Rc::new(args);
            proptest::strategy::Strategy::boxed(proptest::strategy::LazyJust::new(|| Self {}))
        }
    }
    enum EnumRepresentation {
        int(EnumRepresentation_Int),
        string(EnumRepresentation_String),
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for EnumRepresentation {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    EnumRepresentation::int(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "EnumRepresentation",
                            0u32,
                            "int",
                            __field0,
                        )
                    }
                    EnumRepresentation::string(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "EnumRepresentation",
                            1u32,
                            "string",
                            __field0,
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for EnumRepresentation {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "variant identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::export::Ok(__Field::__field0),
                            1u64 => _serde::export::Ok(__Field::__field1),
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"variant index 0 <= i < 2",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "int" => _serde::export::Ok(__Field::__field0),
                            "string" => _serde::export::Ok(__Field::__field1),
                            _ => _serde::export::Err(_serde::de::Error::unknown_variant(
                                __value, VARIANTS,
                            )),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"int" => _serde::export::Ok(__Field::__field0),
                            b"string" => _serde::export::Ok(__Field::__field1),
                            _ => {
                                let __value = &_serde::export::from_utf8_lossy(__value);
                                _serde::export::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                ))
                            }
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::export::PhantomData<EnumRepresentation>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = EnumRepresentation;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "enum EnumRepresentation")
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match match _serde::de::EnumAccess::variant(__data) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            (__Field::__field0, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<EnumRepresentation_Int>(
                                    __variant,
                                ),
                                EnumRepresentation::int,
                            ),
                            (__Field::__field1, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<
                                    EnumRepresentation_String,
                                >(__variant),
                                EnumRepresentation::string,
                            ),
                        }
                    }
                }
                const VARIANTS: &'static [&'static str] = &["int", "string"];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "EnumRepresentation",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<EnumRepresentation>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    impl ::core::marker::StructuralPartialEq for EnumRepresentation {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for EnumRepresentation {
        #[inline]
        fn eq(&self, other: &EnumRepresentation) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (
                            &EnumRepresentation::int(ref __self_0),
                            &EnumRepresentation::int(ref __arg_1_0),
                        ) => (*__self_0) == (*__arg_1_0),
                        (
                            &EnumRepresentation::string(ref __self_0),
                            &EnumRepresentation::string(ref __arg_1_0),
                        ) => (*__self_0) == (*__arg_1_0),
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    false
                }
            }
        }
        #[inline]
        fn ne(&self, other: &EnumRepresentation) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (
                            &EnumRepresentation::int(ref __self_0),
                            &EnumRepresentation::int(ref __arg_1_0),
                        ) => (*__self_0) != (*__arg_1_0),
                        (
                            &EnumRepresentation::string(ref __self_0),
                            &EnumRepresentation::string(ref __arg_1_0),
                        ) => (*__self_0) != (*__arg_1_0),
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    true
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialOrd for EnumRepresentation {
        #[inline]
        fn partial_cmp(
            &self,
            other: &EnumRepresentation,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (
                            &EnumRepresentation::int(ref __self_0),
                            &EnumRepresentation::int(ref __arg_1_0),
                        ) => {
                            match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0))
                            {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                }
                                cmp => cmp,
                            }
                        }
                        (
                            &EnumRepresentation::string(ref __self_0),
                            &EnumRepresentation::string(ref __arg_1_0),
                        ) => {
                            match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0))
                            {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                }
                                cmp => cmp,
                            }
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    __self_vi.partial_cmp(&__arg_1_vi)
                }
            }
        }
        #[inline]
        fn lt(&self, other: &EnumRepresentation) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (
                            &EnumRepresentation::int(ref __self_0),
                            &EnumRepresentation::int(ref __arg_1_0),
                        ) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Greater,
                            ) == ::core::cmp::Ordering::Less
                        }
                        (
                            &EnumRepresentation::string(ref __self_0),
                            &EnumRepresentation::string(ref __arg_1_0),
                        ) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Greater,
                            ) == ::core::cmp::Ordering::Less
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    __self_vi.lt(&__arg_1_vi)
                }
            }
        }
        #[inline]
        fn le(&self, other: &EnumRepresentation) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (
                            &EnumRepresentation::int(ref __self_0),
                            &EnumRepresentation::int(ref __arg_1_0),
                        ) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Greater,
                            ) != ::core::cmp::Ordering::Greater
                        }
                        (
                            &EnumRepresentation::string(ref __self_0),
                            &EnumRepresentation::string(ref __arg_1_0),
                        ) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Greater,
                            ) != ::core::cmp::Ordering::Greater
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    __self_vi.le(&__arg_1_vi)
                }
            }
        }
        #[inline]
        fn gt(&self, other: &EnumRepresentation) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (
                            &EnumRepresentation::int(ref __self_0),
                            &EnumRepresentation::int(ref __arg_1_0),
                        ) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Less,
                            ) == ::core::cmp::Ordering::Greater
                        }
                        (
                            &EnumRepresentation::string(ref __self_0),
                            &EnumRepresentation::string(ref __arg_1_0),
                        ) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Less,
                            ) == ::core::cmp::Ordering::Greater
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    __self_vi.gt(&__arg_1_vi)
                }
            }
        }
        #[inline]
        fn ge(&self, other: &EnumRepresentation) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (
                            &EnumRepresentation::int(ref __self_0),
                            &EnumRepresentation::int(ref __arg_1_0),
                        ) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Less,
                            ) != ::core::cmp::Ordering::Less
                        }
                        (
                            &EnumRepresentation::string(ref __self_0),
                            &EnumRepresentation::string(ref __arg_1_0),
                        ) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Less,
                            ) != ::core::cmp::Ordering::Less
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    __self_vi.ge(&__arg_1_vi)
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for EnumRepresentation {
        #[inline]
        fn clone(&self) -> EnumRepresentation {
            match (&*self,) {
                (&EnumRepresentation::int(ref __self_0),) => {
                    EnumRepresentation::int(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&EnumRepresentation::string(ref __self_0),) => {
                    EnumRepresentation::string(::core::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for EnumRepresentation {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&EnumRepresentation::int(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("int");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&EnumRepresentation::string(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("string");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    impl proptest::arbitrary::Arbitrary for EnumRepresentation {
        type Parameters = ();
        type Strategy = proptest::strategy::BoxedStrategy<Self>;
        fn arbitrary_with(args: Self::Parameters) -> Self::Strategy {
            #[allow(dead_code)]
            fn _to_fn_ptr<T>(f: fn(&T) -> bool) -> fn(&T) -> bool {
                f
            }
            let args = std::rc::Rc::new(args);
            proptest::strategy::Strategy::boxed({
                #[allow(dead_code)]
                fn _to_weight(weight: u32) -> u32 {
                    weight
                }
                let _s = ::proptest::strategy::TupleUnion::new((
                    (
                        1,
                        ::proptest::std_facade::Arc::new({
                            let strategy_0 = ({
                                #[allow(dead_code)]
                                fn _strategy_of_0<
                                    T: std::fmt::Debug,
                                    S: proptest::strategy::Strategy<Value = T>,
                                >(
                                    s: S,
                                ) -> impl proptest::strategy::Strategy<Value = T>
                                {
                                    s
                                }
                                let _s = proptest::arbitrary::any::<EnumRepresentation_Int>();
                                _s
                            },);
                            let strategy_0 =
                                proptest::strategy::Strategy::prop_map(strategy_0, |_values| {
                                    Self::int(_values.0)
                                });
                            strategy_0
                        }),
                    ),
                    (
                        1,
                        ::proptest::std_facade::Arc::new({
                            let strategy_0 = ({
                                #[allow(dead_code)]
                                fn _strategy_of_0<
                                    T: std::fmt::Debug,
                                    S: proptest::strategy::Strategy<Value = T>,
                                >(
                                    s: S,
                                ) -> impl proptest::strategy::Strategy<Value = T>
                                {
                                    s
                                }
                                let _s = proptest::arbitrary::any::<EnumRepresentation_String>();
                                _s
                            },);
                            let strategy_0 =
                                proptest::strategy::Strategy::prop_map(strategy_0, |_values| {
                                    Self::string(_values.0)
                                });
                            strategy_0
                        }),
                    ),
                ));
                _s
            })
        }
    }
    struct EnumRepresentation_Int(Map<EnumValue, Int>);
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for EnumRepresentation_Int {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                _serde::Serializer::serialize_newtype_struct(
                    __serializer,
                    "EnumRepresentation_Int",
                    &self.0,
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for EnumRepresentation_Int {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                struct __Visitor<'de> {
                    marker: _serde::export::PhantomData<EnumRepresentation_Int>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = EnumRepresentation_Int;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(
                            __formatter,
                            "tuple struct EnumRepresentation_Int",
                        )
                    }
                    #[inline]
                    fn visit_newtype_struct<__E>(
                        self,
                        __e: __E,
                    ) -> _serde::export::Result<Self::Value, __E::Error>
                    where
                        __E: _serde::Deserializer<'de>,
                    {
                        let __field0: Map<EnumValue, Int> =
                            match <Map<EnumValue, Int> as _serde::Deserialize>::deserialize(__e) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            };
                        _serde::export::Ok(EnumRepresentation_Int(__field0))
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                            Map<EnumValue, Int>,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    0usize,
                                    &"tuple struct EnumRepresentation_Int with 1 element",
                                ));
                            }
                        };
                        _serde::export::Ok(EnumRepresentation_Int(__field0))
                    }
                }
                _serde::Deserializer::deserialize_newtype_struct(
                    __deserializer,
                    "EnumRepresentation_Int",
                    __Visitor {
                        marker: _serde::export::PhantomData::<EnumRepresentation_Int>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    impl ::core::marker::StructuralPartialEq for EnumRepresentation_Int {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for EnumRepresentation_Int {
        #[inline]
        fn eq(&self, other: &EnumRepresentation_Int) -> bool {
            match *other {
                EnumRepresentation_Int(ref __self_1_0) => match *self {
                    EnumRepresentation_Int(ref __self_0_0) => (*__self_0_0) == (*__self_1_0),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &EnumRepresentation_Int) -> bool {
            match *other {
                EnumRepresentation_Int(ref __self_1_0) => match *self {
                    EnumRepresentation_Int(ref __self_0_0) => (*__self_0_0) != (*__self_1_0),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialOrd for EnumRepresentation_Int {
        #[inline]
        fn partial_cmp(
            &self,
            other: &EnumRepresentation_Int,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match *other {
                EnumRepresentation_Int(ref __self_1_0) => match *self {
                    EnumRepresentation_Int(ref __self_0_0) => {
                        match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0), &(*__self_1_0)) {
                            ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                            }
                            cmp => cmp,
                        }
                    }
                },
            }
        }
        #[inline]
        fn lt(&self, other: &EnumRepresentation_Int) -> bool {
            match *other {
                EnumRepresentation_Int(ref __self_1_0) => match *self {
                    EnumRepresentation_Int(ref __self_0_0) => {
                        ::core::option::Option::unwrap_or(
                            ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0), &(*__self_1_0)),
                            ::core::cmp::Ordering::Greater,
                        ) == ::core::cmp::Ordering::Less
                    }
                },
            }
        }
        #[inline]
        fn le(&self, other: &EnumRepresentation_Int) -> bool {
            match *other {
                EnumRepresentation_Int(ref __self_1_0) => match *self {
                    EnumRepresentation_Int(ref __self_0_0) => {
                        ::core::option::Option::unwrap_or(
                            ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0), &(*__self_1_0)),
                            ::core::cmp::Ordering::Greater,
                        ) != ::core::cmp::Ordering::Greater
                    }
                },
            }
        }
        #[inline]
        fn gt(&self, other: &EnumRepresentation_Int) -> bool {
            match *other {
                EnumRepresentation_Int(ref __self_1_0) => match *self {
                    EnumRepresentation_Int(ref __self_0_0) => {
                        ::core::option::Option::unwrap_or(
                            ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0), &(*__self_1_0)),
                            ::core::cmp::Ordering::Less,
                        ) == ::core::cmp::Ordering::Greater
                    }
                },
            }
        }
        #[inline]
        fn ge(&self, other: &EnumRepresentation_Int) -> bool {
            match *other {
                EnumRepresentation_Int(ref __self_1_0) => match *self {
                    EnumRepresentation_Int(ref __self_0_0) => {
                        ::core::option::Option::unwrap_or(
                            ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0), &(*__self_1_0)),
                            ::core::cmp::Ordering::Less,
                        ) != ::core::cmp::Ordering::Less
                    }
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for EnumRepresentation_Int {
        #[inline]
        fn clone(&self) -> EnumRepresentation_Int {
            match *self {
                EnumRepresentation_Int(ref __self_0_0) => {
                    EnumRepresentation_Int(::core::clone::Clone::clone(&(*__self_0_0)))
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for EnumRepresentation_Int {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                EnumRepresentation_Int(ref __self_0_0) => {
                    let mut debug_trait_builder = f.debug_tuple("EnumRepresentation_Int");
                    let _ = debug_trait_builder.field(&&(*__self_0_0));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    impl proptest::arbitrary::Arbitrary for EnumRepresentation_Int {
        type Parameters = ();
        type Strategy = proptest::strategy::BoxedStrategy<Self>;
        fn arbitrary_with(args: Self::Parameters) -> Self::Strategy {
            #[allow(dead_code)]
            fn _to_fn_ptr<T>(f: fn(&T) -> bool) -> fn(&T) -> bool {
                f
            }
            let args = std::rc::Rc::new(args);
            proptest::strategy::Strategy::boxed({
                let strategy_0 = ({
                    #[allow(dead_code)]
                    fn _strategy_of_0<
                        T: std::fmt::Debug,
                        S: proptest::strategy::Strategy<Value = T>,
                    >(
                        s: S,
                    ) -> impl proptest::strategy::Strategy<Value = T> {
                        s
                    }
                    let _s = proptest::arbitrary::any::<Map<EnumValue, Int>>();
                    _s
                },);
                let strategy_0 =
                    proptest::strategy::Strategy::prop_map(strategy_0, |_values| Self(_values.0));
                strategy_0
            })
        }
    }
    struct EnumRepresentation_String(Map<EnumValue, String>);
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for EnumRepresentation_String {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                _serde::Serializer::serialize_newtype_struct(
                    __serializer,
                    "EnumRepresentation_String",
                    &self.0,
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for EnumRepresentation_String {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                struct __Visitor<'de> {
                    marker: _serde::export::PhantomData<EnumRepresentation_String>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = EnumRepresentation_String;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(
                            __formatter,
                            "tuple struct EnumRepresentation_String",
                        )
                    }
                    #[inline]
                    fn visit_newtype_struct<__E>(
                        self,
                        __e: __E,
                    ) -> _serde::export::Result<Self::Value, __E::Error>
                    where
                        __E: _serde::Deserializer<'de>,
                    {
                        let __field0: Map<EnumValue, String> =
                            match <Map<EnumValue, String> as _serde::Deserialize>::deserialize(__e)
                            {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            };
                        _serde::export::Ok(EnumRepresentation_String(__field0))
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                            Map<EnumValue, String>,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    0usize,
                                    &"tuple struct EnumRepresentation_String with 1 element",
                                ));
                            }
                        };
                        _serde::export::Ok(EnumRepresentation_String(__field0))
                    }
                }
                _serde::Deserializer::deserialize_newtype_struct(
                    __deserializer,
                    "EnumRepresentation_String",
                    __Visitor {
                        marker: _serde::export::PhantomData::<EnumRepresentation_String>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    impl ::core::marker::StructuralPartialEq for EnumRepresentation_String {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for EnumRepresentation_String {
        #[inline]
        fn eq(&self, other: &EnumRepresentation_String) -> bool {
            match *other {
                EnumRepresentation_String(ref __self_1_0) => match *self {
                    EnumRepresentation_String(ref __self_0_0) => (*__self_0_0) == (*__self_1_0),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &EnumRepresentation_String) -> bool {
            match *other {
                EnumRepresentation_String(ref __self_1_0) => match *self {
                    EnumRepresentation_String(ref __self_0_0) => (*__self_0_0) != (*__self_1_0),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialOrd for EnumRepresentation_String {
        #[inline]
        fn partial_cmp(
            &self,
            other: &EnumRepresentation_String,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match *other {
                EnumRepresentation_String(ref __self_1_0) => match *self {
                    EnumRepresentation_String(ref __self_0_0) => {
                        match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0), &(*__self_1_0)) {
                            ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                            }
                            cmp => cmp,
                        }
                    }
                },
            }
        }
        #[inline]
        fn lt(&self, other: &EnumRepresentation_String) -> bool {
            match *other {
                EnumRepresentation_String(ref __self_1_0) => match *self {
                    EnumRepresentation_String(ref __self_0_0) => {
                        ::core::option::Option::unwrap_or(
                            ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0), &(*__self_1_0)),
                            ::core::cmp::Ordering::Greater,
                        ) == ::core::cmp::Ordering::Less
                    }
                },
            }
        }
        #[inline]
        fn le(&self, other: &EnumRepresentation_String) -> bool {
            match *other {
                EnumRepresentation_String(ref __self_1_0) => match *self {
                    EnumRepresentation_String(ref __self_0_0) => {
                        ::core::option::Option::unwrap_or(
                            ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0), &(*__self_1_0)),
                            ::core::cmp::Ordering::Greater,
                        ) != ::core::cmp::Ordering::Greater
                    }
                },
            }
        }
        #[inline]
        fn gt(&self, other: &EnumRepresentation_String) -> bool {
            match *other {
                EnumRepresentation_String(ref __self_1_0) => match *self {
                    EnumRepresentation_String(ref __self_0_0) => {
                        ::core::option::Option::unwrap_or(
                            ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0), &(*__self_1_0)),
                            ::core::cmp::Ordering::Less,
                        ) == ::core::cmp::Ordering::Greater
                    }
                },
            }
        }
        #[inline]
        fn ge(&self, other: &EnumRepresentation_String) -> bool {
            match *other {
                EnumRepresentation_String(ref __self_1_0) => match *self {
                    EnumRepresentation_String(ref __self_0_0) => {
                        ::core::option::Option::unwrap_or(
                            ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0), &(*__self_1_0)),
                            ::core::cmp::Ordering::Less,
                        ) != ::core::cmp::Ordering::Less
                    }
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for EnumRepresentation_String {
        #[inline]
        fn clone(&self) -> EnumRepresentation_String {
            match *self {
                EnumRepresentation_String(ref __self_0_0) => {
                    EnumRepresentation_String(::core::clone::Clone::clone(&(*__self_0_0)))
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for EnumRepresentation_String {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                EnumRepresentation_String(ref __self_0_0) => {
                    let mut debug_trait_builder = f.debug_tuple("EnumRepresentation_String");
                    let _ = debug_trait_builder.field(&&(*__self_0_0));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    impl proptest::arbitrary::Arbitrary for EnumRepresentation_String {
        type Parameters = ();
        type Strategy = proptest::strategy::BoxedStrategy<Self>;
        fn arbitrary_with(args: Self::Parameters) -> Self::Strategy {
            #[allow(dead_code)]
            fn _to_fn_ptr<T>(f: fn(&T) -> bool) -> fn(&T) -> bool {
                f
            }
            let args = std::rc::Rc::new(args);
            proptest::strategy::Strategy::boxed({
                let strategy_0 = ({
                    #[allow(dead_code)]
                    fn _strategy_of_0<
                        T: std::fmt::Debug,
                        S: proptest::strategy::Strategy<Value = T>,
                    >(
                        s: S,
                    ) -> impl proptest::strategy::Strategy<Value = T> {
                        s
                    }
                    let _s = proptest::arbitrary::any::<Map<EnumValue, String>>();
                    _s
                },);
                let strategy_0 =
                    proptest::strategy::Strategy::prop_map(strategy_0, |_values| Self(_values.0));
                strategy_0
            })
        }
    }
    struct EnumValue(String);
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for EnumValue {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                _serde::Serializer::serialize_newtype_struct(__serializer, "EnumValue", &self.0)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for EnumValue {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                struct __Visitor<'de> {
                    marker: _serde::export::PhantomData<EnumValue>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = EnumValue;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "tuple struct EnumValue")
                    }
                    #[inline]
                    fn visit_newtype_struct<__E>(
                        self,
                        __e: __E,
                    ) -> _serde::export::Result<Self::Value, __E::Error>
                    where
                        __E: _serde::Deserializer<'de>,
                    {
                        let __field0: String =
                            match <String as _serde::Deserialize>::deserialize(__e) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            };
                        _serde::export::Ok(EnumValue(__field0))
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 =
                            match match _serde::de::SeqAccess::next_element::<String>(&mut __seq) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        0usize,
                                        &"tuple struct EnumValue with 1 element",
                                    ));
                                }
                            };
                        _serde::export::Ok(EnumValue(__field0))
                    }
                }
                _serde::Deserializer::deserialize_newtype_struct(
                    __deserializer,
                    "EnumValue",
                    __Visitor {
                        marker: _serde::export::PhantomData::<EnumValue>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    impl ::core::marker::StructuralPartialEq for EnumValue {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for EnumValue {
        #[inline]
        fn eq(&self, other: &EnumValue) -> bool {
            match *other {
                EnumValue(ref __self_1_0) => match *self {
                    EnumValue(ref __self_0_0) => (*__self_0_0) == (*__self_1_0),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &EnumValue) -> bool {
            match *other {
                EnumValue(ref __self_1_0) => match *self {
                    EnumValue(ref __self_0_0) => (*__self_0_0) != (*__self_1_0),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialOrd for EnumValue {
        #[inline]
        fn partial_cmp(&self, other: &EnumValue) -> ::core::option::Option<::core::cmp::Ordering> {
            match *other {
                EnumValue(ref __self_1_0) => match *self {
                    EnumValue(ref __self_0_0) => {
                        match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0), &(*__self_1_0)) {
                            ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                            }
                            cmp => cmp,
                        }
                    }
                },
            }
        }
        #[inline]
        fn lt(&self, other: &EnumValue) -> bool {
            match *other {
                EnumValue(ref __self_1_0) => match *self {
                    EnumValue(ref __self_0_0) => {
                        ::core::option::Option::unwrap_or(
                            ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0), &(*__self_1_0)),
                            ::core::cmp::Ordering::Greater,
                        ) == ::core::cmp::Ordering::Less
                    }
                },
            }
        }
        #[inline]
        fn le(&self, other: &EnumValue) -> bool {
            match *other {
                EnumValue(ref __self_1_0) => match *self {
                    EnumValue(ref __self_0_0) => {
                        ::core::option::Option::unwrap_or(
                            ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0), &(*__self_1_0)),
                            ::core::cmp::Ordering::Greater,
                        ) != ::core::cmp::Ordering::Greater
                    }
                },
            }
        }
        #[inline]
        fn gt(&self, other: &EnumValue) -> bool {
            match *other {
                EnumValue(ref __self_1_0) => match *self {
                    EnumValue(ref __self_0_0) => {
                        ::core::option::Option::unwrap_or(
                            ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0), &(*__self_1_0)),
                            ::core::cmp::Ordering::Less,
                        ) == ::core::cmp::Ordering::Greater
                    }
                },
            }
        }
        #[inline]
        fn ge(&self, other: &EnumValue) -> bool {
            match *other {
                EnumValue(ref __self_1_0) => match *self {
                    EnumValue(ref __self_0_0) => {
                        ::core::option::Option::unwrap_or(
                            ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0), &(*__self_1_0)),
                            ::core::cmp::Ordering::Less,
                        ) != ::core::cmp::Ordering::Less
                    }
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for EnumValue {
        #[inline]
        fn clone(&self) -> EnumValue {
            match *self {
                EnumValue(ref __self_0_0) => EnumValue(::core::clone::Clone::clone(&(*__self_0_0))),
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for EnumValue {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                EnumValue(ref __self_0_0) => {
                    let mut debug_trait_builder = f.debug_tuple("EnumValue");
                    let _ = debug_trait_builder.field(&&(*__self_0_0));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    impl proptest::arbitrary::Arbitrary for EnumValue {
        type Parameters = ();
        type Strategy = proptest::strategy::BoxedStrategy<Self>;
        fn arbitrary_with(args: Self::Parameters) -> Self::Strategy {
            #[allow(dead_code)]
            fn _to_fn_ptr<T>(f: fn(&T) -> bool) -> fn(&T) -> bool {
                f
            }
            let args = std::rc::Rc::new(args);
            proptest::strategy::Strategy::boxed({
                let strategy_0 = ({
                    #[allow(dead_code)]
                    fn _strategy_of_0<
                        T: std::fmt::Debug,
                        S: proptest::strategy::Strategy<Value = T>,
                    >(
                        s: S,
                    ) -> impl proptest::strategy::Strategy<Value = T> {
                        s
                    }
                    let _s = proptest::arbitrary::any::<String>();
                    _s
                },);
                let strategy_0 =
                    proptest::strategy::Strategy::prop_map(strategy_0, |_values| Self(_values.0));
                strategy_0
            })
        }
    }
    impl ::core::marker::StructuralEq for EnumValue {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::Eq for EnumValue {
        #[inline]
        #[doc(hidden)]
        fn assert_receiver_is_total_eq(&self) -> () {
            {
                let _: ::core::cmp::AssertParamIsEq<String>;
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::Ord for EnumValue {
        #[inline]
        fn cmp(&self, other: &EnumValue) -> ::core::cmp::Ordering {
            match *other {
                EnumValue(ref __self_1_0) => match *self {
                    EnumValue(ref __self_0_0) => {
                        match ::core::cmp::Ord::cmp(&(*__self_0_0), &(*__self_1_0)) {
                            ::core::cmp::Ordering::Equal => ::core::cmp::Ordering::Equal,
                            cmp => cmp,
                        }
                    }
                },
            }
        }
    }
    struct FieldName(String);
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for FieldName {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                _serde::Serializer::serialize_newtype_struct(__serializer, "FieldName", &self.0)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for FieldName {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                struct __Visitor<'de> {
                    marker: _serde::export::PhantomData<FieldName>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = FieldName;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "tuple struct FieldName")
                    }
                    #[inline]
                    fn visit_newtype_struct<__E>(
                        self,
                        __e: __E,
                    ) -> _serde::export::Result<Self::Value, __E::Error>
                    where
                        __E: _serde::Deserializer<'de>,
                    {
                        let __field0: String =
                            match <String as _serde::Deserialize>::deserialize(__e) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            };
                        _serde::export::Ok(FieldName(__field0))
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 =
                            match match _serde::de::SeqAccess::next_element::<String>(&mut __seq) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        0usize,
                                        &"tuple struct FieldName with 1 element",
                                    ));
                                }
                            };
                        _serde::export::Ok(FieldName(__field0))
                    }
                }
                _serde::Deserializer::deserialize_newtype_struct(
                    __deserializer,
                    "FieldName",
                    __Visitor {
                        marker: _serde::export::PhantomData::<FieldName>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    impl ::core::marker::StructuralPartialEq for FieldName {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for FieldName {
        #[inline]
        fn eq(&self, other: &FieldName) -> bool {
            match *other {
                FieldName(ref __self_1_0) => match *self {
                    FieldName(ref __self_0_0) => (*__self_0_0) == (*__self_1_0),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &FieldName) -> bool {
            match *other {
                FieldName(ref __self_1_0) => match *self {
                    FieldName(ref __self_0_0) => (*__self_0_0) != (*__self_1_0),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialOrd for FieldName {
        #[inline]
        fn partial_cmp(&self, other: &FieldName) -> ::core::option::Option<::core::cmp::Ordering> {
            match *other {
                FieldName(ref __self_1_0) => match *self {
                    FieldName(ref __self_0_0) => {
                        match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0), &(*__self_1_0)) {
                            ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                            }
                            cmp => cmp,
                        }
                    }
                },
            }
        }
        #[inline]
        fn lt(&self, other: &FieldName) -> bool {
            match *other {
                FieldName(ref __self_1_0) => match *self {
                    FieldName(ref __self_0_0) => {
                        ::core::option::Option::unwrap_or(
                            ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0), &(*__self_1_0)),
                            ::core::cmp::Ordering::Greater,
                        ) == ::core::cmp::Ordering::Less
                    }
                },
            }
        }
        #[inline]
        fn le(&self, other: &FieldName) -> bool {
            match *other {
                FieldName(ref __self_1_0) => match *self {
                    FieldName(ref __self_0_0) => {
                        ::core::option::Option::unwrap_or(
                            ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0), &(*__self_1_0)),
                            ::core::cmp::Ordering::Greater,
                        ) != ::core::cmp::Ordering::Greater
                    }
                },
            }
        }
        #[inline]
        fn gt(&self, other: &FieldName) -> bool {
            match *other {
                FieldName(ref __self_1_0) => match *self {
                    FieldName(ref __self_0_0) => {
                        ::core::option::Option::unwrap_or(
                            ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0), &(*__self_1_0)),
                            ::core::cmp::Ordering::Less,
                        ) == ::core::cmp::Ordering::Greater
                    }
                },
            }
        }
        #[inline]
        fn ge(&self, other: &FieldName) -> bool {
            match *other {
                FieldName(ref __self_1_0) => match *self {
                    FieldName(ref __self_0_0) => {
                        ::core::option::Option::unwrap_or(
                            ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0), &(*__self_1_0)),
                            ::core::cmp::Ordering::Less,
                        ) != ::core::cmp::Ordering::Less
                    }
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for FieldName {
        #[inline]
        fn clone(&self) -> FieldName {
            match *self {
                FieldName(ref __self_0_0) => FieldName(::core::clone::Clone::clone(&(*__self_0_0))),
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for FieldName {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                FieldName(ref __self_0_0) => {
                    let mut debug_trait_builder = f.debug_tuple("FieldName");
                    let _ = debug_trait_builder.field(&&(*__self_0_0));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    impl proptest::arbitrary::Arbitrary for FieldName {
        type Parameters = ();
        type Strategy = proptest::strategy::BoxedStrategy<Self>;
        fn arbitrary_with(args: Self::Parameters) -> Self::Strategy {
            #[allow(dead_code)]
            fn _to_fn_ptr<T>(f: fn(&T) -> bool) -> fn(&T) -> bool {
                f
            }
            let args = std::rc::Rc::new(args);
            proptest::strategy::Strategy::boxed({
                let strategy_0 = ({
                    #[allow(dead_code)]
                    fn _strategy_of_0<
                        T: std::fmt::Debug,
                        S: proptest::strategy::Strategy<Value = T>,
                    >(
                        s: S,
                    ) -> impl proptest::strategy::Strategy<Value = T> {
                        s
                    }
                    let _s = proptest::arbitrary::any::<String>();
                    _s
                },);
                let strategy_0 =
                    proptest::strategy::Strategy::prop_map(strategy_0, |_values| Self(_values.0));
                strategy_0
            })
        }
    }
    impl ::core::marker::StructuralEq for FieldName {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::Eq for FieldName {
        #[inline]
        #[doc(hidden)]
        fn assert_receiver_is_total_eq(&self) -> () {
            {
                let _: ::core::cmp::AssertParamIsEq<String>;
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::Ord for FieldName {
        #[inline]
        fn cmp(&self, other: &FieldName) -> ::core::cmp::Ordering {
            match *other {
                FieldName(ref __self_1_0) => match *self {
                    FieldName(ref __self_0_0) => {
                        match ::core::cmp::Ord::cmp(&(*__self_0_0), &(*__self_1_0)) {
                            ::core::cmp::Ordering::Equal => ::core::cmp::Ordering::Equal,
                            cmp => cmp,
                        }
                    }
                },
            }
        }
    }
    enum InlineDefn {
        list(TypeList),
        map(TypeMap),
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for InlineDefn {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    InlineDefn::list(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "InlineDefn",
                            0u32,
                            "list",
                            __field0,
                        )
                    }
                    InlineDefn::map(ref __field0) => _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "InlineDefn",
                        1u32,
                        "map",
                        __field0,
                    ),
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for InlineDefn {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "variant identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::export::Ok(__Field::__field0),
                            1u64 => _serde::export::Ok(__Field::__field1),
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"variant index 0 <= i < 2",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "list" => _serde::export::Ok(__Field::__field0),
                            "map" => _serde::export::Ok(__Field::__field1),
                            _ => _serde::export::Err(_serde::de::Error::unknown_variant(
                                __value, VARIANTS,
                            )),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"list" => _serde::export::Ok(__Field::__field0),
                            b"map" => _serde::export::Ok(__Field::__field1),
                            _ => {
                                let __value = &_serde::export::from_utf8_lossy(__value);
                                _serde::export::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                ))
                            }
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::export::PhantomData<InlineDefn>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = InlineDefn;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "enum InlineDefn")
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match match _serde::de::EnumAccess::variant(__data) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            (__Field::__field0, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<TypeList>(__variant),
                                InlineDefn::list,
                            ),
                            (__Field::__field1, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<TypeMap>(__variant),
                                InlineDefn::map,
                            ),
                        }
                    }
                }
                const VARIANTS: &'static [&'static str] = &["list", "map"];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "InlineDefn",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<InlineDefn>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    impl ::core::marker::StructuralPartialEq for InlineDefn {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for InlineDefn {
        #[inline]
        fn eq(&self, other: &InlineDefn) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&InlineDefn::list(ref __self_0), &InlineDefn::list(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        (&InlineDefn::map(ref __self_0), &InlineDefn::map(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    false
                }
            }
        }
        #[inline]
        fn ne(&self, other: &InlineDefn) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&InlineDefn::list(ref __self_0), &InlineDefn::list(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        (&InlineDefn::map(ref __self_0), &InlineDefn::map(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    true
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialOrd for InlineDefn {
        #[inline]
        fn partial_cmp(&self, other: &InlineDefn) -> ::core::option::Option<::core::cmp::Ordering> {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&InlineDefn::list(ref __self_0), &InlineDefn::list(ref __arg_1_0)) => {
                            match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0))
                            {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                }
                                cmp => cmp,
                            }
                        }
                        (&InlineDefn::map(ref __self_0), &InlineDefn::map(ref __arg_1_0)) => {
                            match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0))
                            {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                }
                                cmp => cmp,
                            }
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    __self_vi.partial_cmp(&__arg_1_vi)
                }
            }
        }
        #[inline]
        fn lt(&self, other: &InlineDefn) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&InlineDefn::list(ref __self_0), &InlineDefn::list(ref __arg_1_0)) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Greater,
                            ) == ::core::cmp::Ordering::Less
                        }
                        (&InlineDefn::map(ref __self_0), &InlineDefn::map(ref __arg_1_0)) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Greater,
                            ) == ::core::cmp::Ordering::Less
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    __self_vi.lt(&__arg_1_vi)
                }
            }
        }
        #[inline]
        fn le(&self, other: &InlineDefn) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&InlineDefn::list(ref __self_0), &InlineDefn::list(ref __arg_1_0)) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Greater,
                            ) != ::core::cmp::Ordering::Greater
                        }
                        (&InlineDefn::map(ref __self_0), &InlineDefn::map(ref __arg_1_0)) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Greater,
                            ) != ::core::cmp::Ordering::Greater
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    __self_vi.le(&__arg_1_vi)
                }
            }
        }
        #[inline]
        fn gt(&self, other: &InlineDefn) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&InlineDefn::list(ref __self_0), &InlineDefn::list(ref __arg_1_0)) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Less,
                            ) == ::core::cmp::Ordering::Greater
                        }
                        (&InlineDefn::map(ref __self_0), &InlineDefn::map(ref __arg_1_0)) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Less,
                            ) == ::core::cmp::Ordering::Greater
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    __self_vi.gt(&__arg_1_vi)
                }
            }
        }
        #[inline]
        fn ge(&self, other: &InlineDefn) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&InlineDefn::list(ref __self_0), &InlineDefn::list(ref __arg_1_0)) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Less,
                            ) != ::core::cmp::Ordering::Less
                        }
                        (&InlineDefn::map(ref __self_0), &InlineDefn::map(ref __arg_1_0)) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Less,
                            ) != ::core::cmp::Ordering::Less
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    __self_vi.ge(&__arg_1_vi)
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for InlineDefn {
        #[inline]
        fn clone(&self) -> InlineDefn {
            match (&*self,) {
                (&InlineDefn::list(ref __self_0),) => {
                    InlineDefn::list(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&InlineDefn::map(ref __self_0),) => {
                    InlineDefn::map(::core::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for InlineDefn {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&InlineDefn::list(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("list");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&InlineDefn::map(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("map");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    impl proptest::arbitrary::Arbitrary for InlineDefn {
        type Parameters = ();
        type Strategy = proptest::strategy::BoxedStrategy<Self>;
        fn arbitrary_with(args: Self::Parameters) -> Self::Strategy {
            #[allow(dead_code)]
            fn _to_fn_ptr<T>(f: fn(&T) -> bool) -> fn(&T) -> bool {
                f
            }
            let args = std::rc::Rc::new(args);
            proptest::strategy::Strategy::boxed({
                #[allow(dead_code)]
                fn _to_weight(weight: u32) -> u32 {
                    weight
                }
                let _s = ::proptest::strategy::TupleUnion::new((
                    (
                        1,
                        ::proptest::std_facade::Arc::new({
                            let strategy_0 = ({
                                #[allow(dead_code)]
                                fn _strategy_of_0<
                                    T: std::fmt::Debug,
                                    S: proptest::strategy::Strategy<Value = T>,
                                >(
                                    s: S,
                                ) -> impl proptest::strategy::Strategy<Value = T>
                                {
                                    s
                                }
                                let _s = proptest::arbitrary::any::<TypeList>();
                                _s
                            },);
                            let strategy_0 =
                                proptest::strategy::Strategy::prop_map(strategy_0, |_values| {
                                    Self::list(_values.0)
                                });
                            strategy_0
                        }),
                    ),
                    (
                        1,
                        ::proptest::std_facade::Arc::new({
                            let strategy_0 = ({
                                #[allow(dead_code)]
                                fn _strategy_of_0<
                                    T: std::fmt::Debug,
                                    S: proptest::strategy::Strategy<Value = T>,
                                >(
                                    s: S,
                                ) -> impl proptest::strategy::Strategy<Value = T>
                                {
                                    s
                                }
                                let _s = proptest::arbitrary::any::<TypeMap>();
                                _s
                            },);
                            let strategy_0 =
                                proptest::strategy::Strategy::prop_map(strategy_0, |_values| {
                                    Self::map(_values.0)
                                });
                            strategy_0
                        }),
                    ),
                ));
                _s
            })
        }
    }
    enum ListRepresentation {
        advanced(AdvancedDataLayoutName),
        list(ListRepresentation_List),
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for ListRepresentation {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    ListRepresentation::advanced(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "ListRepresentation",
                            0u32,
                            "advanced",
                            __field0,
                        )
                    }
                    ListRepresentation::list(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "ListRepresentation",
                            1u32,
                            "list",
                            __field0,
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for ListRepresentation {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "variant identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::export::Ok(__Field::__field0),
                            1u64 => _serde::export::Ok(__Field::__field1),
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"variant index 0 <= i < 2",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "advanced" => _serde::export::Ok(__Field::__field0),
                            "list" => _serde::export::Ok(__Field::__field1),
                            _ => _serde::export::Err(_serde::de::Error::unknown_variant(
                                __value, VARIANTS,
                            )),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"advanced" => _serde::export::Ok(__Field::__field0),
                            b"list" => _serde::export::Ok(__Field::__field1),
                            _ => {
                                let __value = &_serde::export::from_utf8_lossy(__value);
                                _serde::export::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                ))
                            }
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::export::PhantomData<ListRepresentation>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = ListRepresentation;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "enum ListRepresentation")
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match match _serde::de::EnumAccess::variant(__data) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            (__Field::__field0, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<AdvancedDataLayoutName>(
                                    __variant,
                                ),
                                ListRepresentation::advanced,
                            ),
                            (__Field::__field1, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<ListRepresentation_List>(
                                    __variant,
                                ),
                                ListRepresentation::list,
                            ),
                        }
                    }
                }
                const VARIANTS: &'static [&'static str] = &["advanced", "list"];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "ListRepresentation",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<ListRepresentation>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    impl ::core::marker::StructuralPartialEq for ListRepresentation {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for ListRepresentation {
        #[inline]
        fn eq(&self, other: &ListRepresentation) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (
                            &ListRepresentation::advanced(ref __self_0),
                            &ListRepresentation::advanced(ref __arg_1_0),
                        ) => (*__self_0) == (*__arg_1_0),
                        (
                            &ListRepresentation::list(ref __self_0),
                            &ListRepresentation::list(ref __arg_1_0),
                        ) => (*__self_0) == (*__arg_1_0),
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    false
                }
            }
        }
        #[inline]
        fn ne(&self, other: &ListRepresentation) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (
                            &ListRepresentation::advanced(ref __self_0),
                            &ListRepresentation::advanced(ref __arg_1_0),
                        ) => (*__self_0) != (*__arg_1_0),
                        (
                            &ListRepresentation::list(ref __self_0),
                            &ListRepresentation::list(ref __arg_1_0),
                        ) => (*__self_0) != (*__arg_1_0),
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    true
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialOrd for ListRepresentation {
        #[inline]
        fn partial_cmp(
            &self,
            other: &ListRepresentation,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (
                            &ListRepresentation::advanced(ref __self_0),
                            &ListRepresentation::advanced(ref __arg_1_0),
                        ) => {
                            match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0))
                            {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                }
                                cmp => cmp,
                            }
                        }
                        (
                            &ListRepresentation::list(ref __self_0),
                            &ListRepresentation::list(ref __arg_1_0),
                        ) => {
                            match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0))
                            {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                }
                                cmp => cmp,
                            }
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    __self_vi.partial_cmp(&__arg_1_vi)
                }
            }
        }
        #[inline]
        fn lt(&self, other: &ListRepresentation) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (
                            &ListRepresentation::advanced(ref __self_0),
                            &ListRepresentation::advanced(ref __arg_1_0),
                        ) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Greater,
                            ) == ::core::cmp::Ordering::Less
                        }
                        (
                            &ListRepresentation::list(ref __self_0),
                            &ListRepresentation::list(ref __arg_1_0),
                        ) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Greater,
                            ) == ::core::cmp::Ordering::Less
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    __self_vi.lt(&__arg_1_vi)
                }
            }
        }
        #[inline]
        fn le(&self, other: &ListRepresentation) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (
                            &ListRepresentation::advanced(ref __self_0),
                            &ListRepresentation::advanced(ref __arg_1_0),
                        ) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Greater,
                            ) != ::core::cmp::Ordering::Greater
                        }
                        (
                            &ListRepresentation::list(ref __self_0),
                            &ListRepresentation::list(ref __arg_1_0),
                        ) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Greater,
                            ) != ::core::cmp::Ordering::Greater
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    __self_vi.le(&__arg_1_vi)
                }
            }
        }
        #[inline]
        fn gt(&self, other: &ListRepresentation) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (
                            &ListRepresentation::advanced(ref __self_0),
                            &ListRepresentation::advanced(ref __arg_1_0),
                        ) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Less,
                            ) == ::core::cmp::Ordering::Greater
                        }
                        (
                            &ListRepresentation::list(ref __self_0),
                            &ListRepresentation::list(ref __arg_1_0),
                        ) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Less,
                            ) == ::core::cmp::Ordering::Greater
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    __self_vi.gt(&__arg_1_vi)
                }
            }
        }
        #[inline]
        fn ge(&self, other: &ListRepresentation) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (
                            &ListRepresentation::advanced(ref __self_0),
                            &ListRepresentation::advanced(ref __arg_1_0),
                        ) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Less,
                            ) != ::core::cmp::Ordering::Less
                        }
                        (
                            &ListRepresentation::list(ref __self_0),
                            &ListRepresentation::list(ref __arg_1_0),
                        ) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Less,
                            ) != ::core::cmp::Ordering::Less
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    __self_vi.ge(&__arg_1_vi)
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for ListRepresentation {
        #[inline]
        fn clone(&self) -> ListRepresentation {
            match (&*self,) {
                (&ListRepresentation::advanced(ref __self_0),) => {
                    ListRepresentation::advanced(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&ListRepresentation::list(ref __self_0),) => {
                    ListRepresentation::list(::core::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for ListRepresentation {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&ListRepresentation::advanced(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("advanced");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&ListRepresentation::list(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("list");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    impl proptest::arbitrary::Arbitrary for ListRepresentation {
        type Parameters = ();
        type Strategy = proptest::strategy::BoxedStrategy<Self>;
        fn arbitrary_with(args: Self::Parameters) -> Self::Strategy {
            #[allow(dead_code)]
            fn _to_fn_ptr<T>(f: fn(&T) -> bool) -> fn(&T) -> bool {
                f
            }
            let args = std::rc::Rc::new(args);
            proptest::strategy::Strategy::boxed({
                #[allow(dead_code)]
                fn _to_weight(weight: u32) -> u32 {
                    weight
                }
                let _s = ::proptest::strategy::TupleUnion::new((
                    (
                        1,
                        ::proptest::std_facade::Arc::new({
                            let strategy_0 = ({
                                #[allow(dead_code)]
                                fn _strategy_of_0<
                                    T: std::fmt::Debug,
                                    S: proptest::strategy::Strategy<Value = T>,
                                >(
                                    s: S,
                                ) -> impl proptest::strategy::Strategy<Value = T>
                                {
                                    s
                                }
                                let _s = proptest::arbitrary::any::<AdvancedDataLayoutName>();
                                _s
                            },);
                            let strategy_0 =
                                proptest::strategy::Strategy::prop_map(strategy_0, |_values| {
                                    Self::advanced(_values.0)
                                });
                            strategy_0
                        }),
                    ),
                    (
                        1,
                        ::proptest::std_facade::Arc::new({
                            let strategy_0 = ({
                                #[allow(dead_code)]
                                fn _strategy_of_0<
                                    T: std::fmt::Debug,
                                    S: proptest::strategy::Strategy<Value = T>,
                                >(
                                    s: S,
                                ) -> impl proptest::strategy::Strategy<Value = T>
                                {
                                    s
                                }
                                let _s = proptest::arbitrary::any::<ListRepresentation_List>();
                                _s
                            },);
                            let strategy_0 =
                                proptest::strategy::Strategy::prop_map(strategy_0, |_values| {
                                    Self::list(_values.0)
                                });
                            strategy_0
                        }),
                    ),
                ));
                _s
            })
        }
    }
    struct ListRepresentation_List {}
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for ListRepresentation_List {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "ListRepresentation_List",
                    false as usize,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for ListRepresentation_List {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"field index 0 <= i < 0",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::export::PhantomData<ListRepresentation_List>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = ListRepresentation_List;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(
                            __formatter,
                            "struct ListRepresentation_List",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        _: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        _serde::export::Ok(ListRepresentation_List {})
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        while let _serde::export::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            }
                        {
                            match __key {
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        _serde::export::Ok(ListRepresentation_List {})
                    }
                }
                const FIELDS: &'static [&'static str] = &[];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "ListRepresentation_List",
                    FIELDS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<ListRepresentation_List>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    impl ::core::marker::StructuralPartialEq for ListRepresentation_List {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for ListRepresentation_List {
        #[inline]
        fn eq(&self, other: &ListRepresentation_List) -> bool {
            match *other {
                ListRepresentation_List {} => match *self {
                    ListRepresentation_List {} => true,
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialOrd for ListRepresentation_List {
        #[inline]
        fn partial_cmp(
            &self,
            other: &ListRepresentation_List,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match *other {
                ListRepresentation_List {} => match *self {
                    ListRepresentation_List {} => {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                    }
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for ListRepresentation_List {
        #[inline]
        fn clone(&self) -> ListRepresentation_List {
            match *self {
                ListRepresentation_List {} => ListRepresentation_List {},
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for ListRepresentation_List {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                ListRepresentation_List {} => {
                    let mut debug_trait_builder = f.debug_struct("ListRepresentation_List");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    impl proptest::arbitrary::Arbitrary for ListRepresentation_List {
        type Parameters = ();
        type Strategy = proptest::strategy::BoxedStrategy<Self>;
        fn arbitrary_with(args: Self::Parameters) -> Self::Strategy {
            #[allow(dead_code)]
            fn _to_fn_ptr<T>(f: fn(&T) -> bool) -> fn(&T) -> bool {
                f
            }
            let args = std::rc::Rc::new(args);
            proptest::strategy::Strategy::boxed(proptest::strategy::LazyJust::new(|| Self {}))
        }
    }
    enum MapRepresentation {
        advanced(AdvancedDataLayoutName),
        listpairs(MapRepresentation_ListPairs),
        map(MapRepresentation_Map),
        stringpairs(MapRepresentation_StringPairs),
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for MapRepresentation {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    MapRepresentation::advanced(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "MapRepresentation",
                            0u32,
                            "advanced",
                            __field0,
                        )
                    }
                    MapRepresentation::listpairs(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "MapRepresentation",
                            1u32,
                            "listpairs",
                            __field0,
                        )
                    }
                    MapRepresentation::map(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "MapRepresentation",
                            2u32,
                            "map",
                            __field0,
                        )
                    }
                    MapRepresentation::stringpairs(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "MapRepresentation",
                            3u32,
                            "stringpairs",
                            __field0,
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for MapRepresentation {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "variant identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::export::Ok(__Field::__field0),
                            1u64 => _serde::export::Ok(__Field::__field1),
                            2u64 => _serde::export::Ok(__Field::__field2),
                            3u64 => _serde::export::Ok(__Field::__field3),
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"variant index 0 <= i < 4",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "advanced" => _serde::export::Ok(__Field::__field0),
                            "listpairs" => _serde::export::Ok(__Field::__field1),
                            "map" => _serde::export::Ok(__Field::__field2),
                            "stringpairs" => _serde::export::Ok(__Field::__field3),
                            _ => _serde::export::Err(_serde::de::Error::unknown_variant(
                                __value, VARIANTS,
                            )),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"advanced" => _serde::export::Ok(__Field::__field0),
                            b"listpairs" => _serde::export::Ok(__Field::__field1),
                            b"map" => _serde::export::Ok(__Field::__field2),
                            b"stringpairs" => _serde::export::Ok(__Field::__field3),
                            _ => {
                                let __value = &_serde::export::from_utf8_lossy(__value);
                                _serde::export::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                ))
                            }
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::export::PhantomData<MapRepresentation>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = MapRepresentation;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "enum MapRepresentation")
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match match _serde::de::EnumAccess::variant(__data) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            (__Field::__field0, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<AdvancedDataLayoutName>(
                                    __variant,
                                ),
                                MapRepresentation::advanced,
                            ),
                            (__Field::__field1, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<
                                    MapRepresentation_ListPairs,
                                >(__variant),
                                MapRepresentation::listpairs,
                            ),
                            (__Field::__field2, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<MapRepresentation_Map>(
                                    __variant,
                                ),
                                MapRepresentation::map,
                            ),
                            (__Field::__field3, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<
                                    MapRepresentation_StringPairs,
                                >(__variant),
                                MapRepresentation::stringpairs,
                            ),
                        }
                    }
                }
                const VARIANTS: &'static [&'static str] =
                    &["advanced", "listpairs", "map", "stringpairs"];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "MapRepresentation",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<MapRepresentation>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    impl ::core::marker::StructuralPartialEq for MapRepresentation {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for MapRepresentation {
        #[inline]
        fn eq(&self, other: &MapRepresentation) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (
                            &MapRepresentation::advanced(ref __self_0),
                            &MapRepresentation::advanced(ref __arg_1_0),
                        ) => (*__self_0) == (*__arg_1_0),
                        (
                            &MapRepresentation::listpairs(ref __self_0),
                            &MapRepresentation::listpairs(ref __arg_1_0),
                        ) => (*__self_0) == (*__arg_1_0),
                        (
                            &MapRepresentation::map(ref __self_0),
                            &MapRepresentation::map(ref __arg_1_0),
                        ) => (*__self_0) == (*__arg_1_0),
                        (
                            &MapRepresentation::stringpairs(ref __self_0),
                            &MapRepresentation::stringpairs(ref __arg_1_0),
                        ) => (*__self_0) == (*__arg_1_0),
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    false
                }
            }
        }
        #[inline]
        fn ne(&self, other: &MapRepresentation) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (
                            &MapRepresentation::advanced(ref __self_0),
                            &MapRepresentation::advanced(ref __arg_1_0),
                        ) => (*__self_0) != (*__arg_1_0),
                        (
                            &MapRepresentation::listpairs(ref __self_0),
                            &MapRepresentation::listpairs(ref __arg_1_0),
                        ) => (*__self_0) != (*__arg_1_0),
                        (
                            &MapRepresentation::map(ref __self_0),
                            &MapRepresentation::map(ref __arg_1_0),
                        ) => (*__self_0) != (*__arg_1_0),
                        (
                            &MapRepresentation::stringpairs(ref __self_0),
                            &MapRepresentation::stringpairs(ref __arg_1_0),
                        ) => (*__self_0) != (*__arg_1_0),
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    true
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialOrd for MapRepresentation {
        #[inline]
        fn partial_cmp(
            &self,
            other: &MapRepresentation,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (
                            &MapRepresentation::advanced(ref __self_0),
                            &MapRepresentation::advanced(ref __arg_1_0),
                        ) => {
                            match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0))
                            {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                }
                                cmp => cmp,
                            }
                        }
                        (
                            &MapRepresentation::listpairs(ref __self_0),
                            &MapRepresentation::listpairs(ref __arg_1_0),
                        ) => {
                            match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0))
                            {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                }
                                cmp => cmp,
                            }
                        }
                        (
                            &MapRepresentation::map(ref __self_0),
                            &MapRepresentation::map(ref __arg_1_0),
                        ) => {
                            match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0))
                            {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                }
                                cmp => cmp,
                            }
                        }
                        (
                            &MapRepresentation::stringpairs(ref __self_0),
                            &MapRepresentation::stringpairs(ref __arg_1_0),
                        ) => {
                            match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0))
                            {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                }
                                cmp => cmp,
                            }
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    __self_vi.partial_cmp(&__arg_1_vi)
                }
            }
        }
        #[inline]
        fn lt(&self, other: &MapRepresentation) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (
                            &MapRepresentation::advanced(ref __self_0),
                            &MapRepresentation::advanced(ref __arg_1_0),
                        ) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Greater,
                            ) == ::core::cmp::Ordering::Less
                        }
                        (
                            &MapRepresentation::listpairs(ref __self_0),
                            &MapRepresentation::listpairs(ref __arg_1_0),
                        ) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Greater,
                            ) == ::core::cmp::Ordering::Less
                        }
                        (
                            &MapRepresentation::map(ref __self_0),
                            &MapRepresentation::map(ref __arg_1_0),
                        ) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Greater,
                            ) == ::core::cmp::Ordering::Less
                        }
                        (
                            &MapRepresentation::stringpairs(ref __self_0),
                            &MapRepresentation::stringpairs(ref __arg_1_0),
                        ) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Greater,
                            ) == ::core::cmp::Ordering::Less
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    __self_vi.lt(&__arg_1_vi)
                }
            }
        }
        #[inline]
        fn le(&self, other: &MapRepresentation) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (
                            &MapRepresentation::advanced(ref __self_0),
                            &MapRepresentation::advanced(ref __arg_1_0),
                        ) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Greater,
                            ) != ::core::cmp::Ordering::Greater
                        }
                        (
                            &MapRepresentation::listpairs(ref __self_0),
                            &MapRepresentation::listpairs(ref __arg_1_0),
                        ) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Greater,
                            ) != ::core::cmp::Ordering::Greater
                        }
                        (
                            &MapRepresentation::map(ref __self_0),
                            &MapRepresentation::map(ref __arg_1_0),
                        ) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Greater,
                            ) != ::core::cmp::Ordering::Greater
                        }
                        (
                            &MapRepresentation::stringpairs(ref __self_0),
                            &MapRepresentation::stringpairs(ref __arg_1_0),
                        ) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Greater,
                            ) != ::core::cmp::Ordering::Greater
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    __self_vi.le(&__arg_1_vi)
                }
            }
        }
        #[inline]
        fn gt(&self, other: &MapRepresentation) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (
                            &MapRepresentation::advanced(ref __self_0),
                            &MapRepresentation::advanced(ref __arg_1_0),
                        ) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Less,
                            ) == ::core::cmp::Ordering::Greater
                        }
                        (
                            &MapRepresentation::listpairs(ref __self_0),
                            &MapRepresentation::listpairs(ref __arg_1_0),
                        ) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Less,
                            ) == ::core::cmp::Ordering::Greater
                        }
                        (
                            &MapRepresentation::map(ref __self_0),
                            &MapRepresentation::map(ref __arg_1_0),
                        ) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Less,
                            ) == ::core::cmp::Ordering::Greater
                        }
                        (
                            &MapRepresentation::stringpairs(ref __self_0),
                            &MapRepresentation::stringpairs(ref __arg_1_0),
                        ) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Less,
                            ) == ::core::cmp::Ordering::Greater
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    __self_vi.gt(&__arg_1_vi)
                }
            }
        }
        #[inline]
        fn ge(&self, other: &MapRepresentation) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (
                            &MapRepresentation::advanced(ref __self_0),
                            &MapRepresentation::advanced(ref __arg_1_0),
                        ) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Less,
                            ) != ::core::cmp::Ordering::Less
                        }
                        (
                            &MapRepresentation::listpairs(ref __self_0),
                            &MapRepresentation::listpairs(ref __arg_1_0),
                        ) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Less,
                            ) != ::core::cmp::Ordering::Less
                        }
                        (
                            &MapRepresentation::map(ref __self_0),
                            &MapRepresentation::map(ref __arg_1_0),
                        ) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Less,
                            ) != ::core::cmp::Ordering::Less
                        }
                        (
                            &MapRepresentation::stringpairs(ref __self_0),
                            &MapRepresentation::stringpairs(ref __arg_1_0),
                        ) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Less,
                            ) != ::core::cmp::Ordering::Less
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    __self_vi.ge(&__arg_1_vi)
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for MapRepresentation {
        #[inline]
        fn clone(&self) -> MapRepresentation {
            match (&*self,) {
                (&MapRepresentation::advanced(ref __self_0),) => {
                    MapRepresentation::advanced(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&MapRepresentation::listpairs(ref __self_0),) => {
                    MapRepresentation::listpairs(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&MapRepresentation::map(ref __self_0),) => {
                    MapRepresentation::map(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&MapRepresentation::stringpairs(ref __self_0),) => {
                    MapRepresentation::stringpairs(::core::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for MapRepresentation {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&MapRepresentation::advanced(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("advanced");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&MapRepresentation::listpairs(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("listpairs");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&MapRepresentation::map(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("map");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&MapRepresentation::stringpairs(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("stringpairs");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    impl proptest::arbitrary::Arbitrary for MapRepresentation {
        type Parameters = ();
        type Strategy = proptest::strategy::BoxedStrategy<Self>;
        fn arbitrary_with(args: Self::Parameters) -> Self::Strategy {
            #[allow(dead_code)]
            fn _to_fn_ptr<T>(f: fn(&T) -> bool) -> fn(&T) -> bool {
                f
            }
            let args = std::rc::Rc::new(args);
            proptest::strategy::Strategy::boxed({
                #[allow(dead_code)]
                fn _to_weight(weight: u32) -> u32 {
                    weight
                }
                let _s = ::proptest::strategy::TupleUnion::new((
                    (
                        1,
                        ::proptest::std_facade::Arc::new({
                            let strategy_0 = ({
                                #[allow(dead_code)]
                                fn _strategy_of_0<
                                    T: std::fmt::Debug,
                                    S: proptest::strategy::Strategy<Value = T>,
                                >(
                                    s: S,
                                ) -> impl proptest::strategy::Strategy<Value = T>
                                {
                                    s
                                }
                                let _s = proptest::arbitrary::any::<AdvancedDataLayoutName>();
                                _s
                            },);
                            let strategy_0 =
                                proptest::strategy::Strategy::prop_map(strategy_0, |_values| {
                                    Self::advanced(_values.0)
                                });
                            strategy_0
                        }),
                    ),
                    (
                        1,
                        ::proptest::std_facade::Arc::new({
                            let strategy_0 = ({
                                #[allow(dead_code)]
                                fn _strategy_of_0<
                                    T: std::fmt::Debug,
                                    S: proptest::strategy::Strategy<Value = T>,
                                >(
                                    s: S,
                                ) -> impl proptest::strategy::Strategy<Value = T>
                                {
                                    s
                                }
                                let _s = proptest::arbitrary::any::<MapRepresentation_ListPairs>();
                                _s
                            },);
                            let strategy_0 =
                                proptest::strategy::Strategy::prop_map(strategy_0, |_values| {
                                    Self::listpairs(_values.0)
                                });
                            strategy_0
                        }),
                    ),
                    (
                        1,
                        ::proptest::std_facade::Arc::new({
                            let strategy_0 = ({
                                #[allow(dead_code)]
                                fn _strategy_of_0<
                                    T: std::fmt::Debug,
                                    S: proptest::strategy::Strategy<Value = T>,
                                >(
                                    s: S,
                                ) -> impl proptest::strategy::Strategy<Value = T>
                                {
                                    s
                                }
                                let _s = proptest::arbitrary::any::<MapRepresentation_Map>();
                                _s
                            },);
                            let strategy_0 =
                                proptest::strategy::Strategy::prop_map(strategy_0, |_values| {
                                    Self::map(_values.0)
                                });
                            strategy_0
                        }),
                    ),
                    (
                        1,
                        ::proptest::std_facade::Arc::new({
                            let strategy_0 = ({
                                #[allow(dead_code)]
                                fn _strategy_of_0<
                                    T: std::fmt::Debug,
                                    S: proptest::strategy::Strategy<Value = T>,
                                >(
                                    s: S,
                                ) -> impl proptest::strategy::Strategy<Value = T>
                                {
                                    s
                                }
                                let _s =
                                    proptest::arbitrary::any::<MapRepresentation_StringPairs>();
                                _s
                            },);
                            let strategy_0 =
                                proptest::strategy::Strategy::prop_map(strategy_0, |_values| {
                                    Self::stringpairs(_values.0)
                                });
                            strategy_0
                        }),
                    ),
                ));
                _s
            })
        }
    }
    struct MapRepresentation_ListPairs {}
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for MapRepresentation_ListPairs {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "MapRepresentation_ListPairs",
                    false as usize,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for MapRepresentation_ListPairs {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"field index 0 <= i < 0",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::export::PhantomData<MapRepresentation_ListPairs>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = MapRepresentation_ListPairs;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(
                            __formatter,
                            "struct MapRepresentation_ListPairs",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        _: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        _serde::export::Ok(MapRepresentation_ListPairs {})
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        while let _serde::export::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            }
                        {
                            match __key {
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        _serde::export::Ok(MapRepresentation_ListPairs {})
                    }
                }
                const FIELDS: &'static [&'static str] = &[];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "MapRepresentation_ListPairs",
                    FIELDS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<MapRepresentation_ListPairs>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    impl ::core::marker::StructuralPartialEq for MapRepresentation_ListPairs {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for MapRepresentation_ListPairs {
        #[inline]
        fn eq(&self, other: &MapRepresentation_ListPairs) -> bool {
            match *other {
                MapRepresentation_ListPairs {} => match *self {
                    MapRepresentation_ListPairs {} => true,
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialOrd for MapRepresentation_ListPairs {
        #[inline]
        fn partial_cmp(
            &self,
            other: &MapRepresentation_ListPairs,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match *other {
                MapRepresentation_ListPairs {} => match *self {
                    MapRepresentation_ListPairs {} => {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                    }
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for MapRepresentation_ListPairs {
        #[inline]
        fn clone(&self) -> MapRepresentation_ListPairs {
            match *self {
                MapRepresentation_ListPairs {} => MapRepresentation_ListPairs {},
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for MapRepresentation_ListPairs {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                MapRepresentation_ListPairs {} => {
                    let mut debug_trait_builder = f.debug_struct("MapRepresentation_ListPairs");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    impl proptest::arbitrary::Arbitrary for MapRepresentation_ListPairs {
        type Parameters = ();
        type Strategy = proptest::strategy::BoxedStrategy<Self>;
        fn arbitrary_with(args: Self::Parameters) -> Self::Strategy {
            #[allow(dead_code)]
            fn _to_fn_ptr<T>(f: fn(&T) -> bool) -> fn(&T) -> bool {
                f
            }
            let args = std::rc::Rc::new(args);
            proptest::strategy::Strategy::boxed(proptest::strategy::LazyJust::new(|| Self {}))
        }
    }
    struct MapRepresentation_Map {}
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for MapRepresentation_Map {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "MapRepresentation_Map",
                    false as usize,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for MapRepresentation_Map {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"field index 0 <= i < 0",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::export::PhantomData<MapRepresentation_Map>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = MapRepresentation_Map;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(
                            __formatter,
                            "struct MapRepresentation_Map",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        _: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        _serde::export::Ok(MapRepresentation_Map {})
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        while let _serde::export::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            }
                        {
                            match __key {
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        _serde::export::Ok(MapRepresentation_Map {})
                    }
                }
                const FIELDS: &'static [&'static str] = &[];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "MapRepresentation_Map",
                    FIELDS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<MapRepresentation_Map>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    impl ::core::marker::StructuralPartialEq for MapRepresentation_Map {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for MapRepresentation_Map {
        #[inline]
        fn eq(&self, other: &MapRepresentation_Map) -> bool {
            match *other {
                MapRepresentation_Map {} => match *self {
                    MapRepresentation_Map {} => true,
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialOrd for MapRepresentation_Map {
        #[inline]
        fn partial_cmp(
            &self,
            other: &MapRepresentation_Map,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match *other {
                MapRepresentation_Map {} => match *self {
                    MapRepresentation_Map {} => {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                    }
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for MapRepresentation_Map {
        #[inline]
        fn clone(&self) -> MapRepresentation_Map {
            match *self {
                MapRepresentation_Map {} => MapRepresentation_Map {},
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for MapRepresentation_Map {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                MapRepresentation_Map {} => {
                    let mut debug_trait_builder = f.debug_struct("MapRepresentation_Map");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    impl proptest::arbitrary::Arbitrary for MapRepresentation_Map {
        type Parameters = ();
        type Strategy = proptest::strategy::BoxedStrategy<Self>;
        fn arbitrary_with(args: Self::Parameters) -> Self::Strategy {
            #[allow(dead_code)]
            fn _to_fn_ptr<T>(f: fn(&T) -> bool) -> fn(&T) -> bool {
                f
            }
            let args = std::rc::Rc::new(args);
            proptest::strategy::Strategy::boxed(proptest::strategy::LazyJust::new(|| Self {}))
        }
    }
    struct MapRepresentation_StringPairs {}
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for MapRepresentation_StringPairs {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "MapRepresentation_StringPairs",
                    false as usize,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for MapRepresentation_StringPairs {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"field index 0 <= i < 0",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::export::PhantomData<MapRepresentation_StringPairs>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = MapRepresentation_StringPairs;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(
                            __formatter,
                            "struct MapRepresentation_StringPairs",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        _: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        _serde::export::Ok(MapRepresentation_StringPairs {})
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        while let _serde::export::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            }
                        {
                            match __key {
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        _serde::export::Ok(MapRepresentation_StringPairs {})
                    }
                }
                const FIELDS: &'static [&'static str] = &[];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "MapRepresentation_StringPairs",
                    FIELDS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<MapRepresentation_StringPairs>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    impl ::core::marker::StructuralPartialEq for MapRepresentation_StringPairs {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for MapRepresentation_StringPairs {
        #[inline]
        fn eq(&self, other: &MapRepresentation_StringPairs) -> bool {
            match *other {
                MapRepresentation_StringPairs {} => match *self {
                    MapRepresentation_StringPairs {} => true,
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialOrd for MapRepresentation_StringPairs {
        #[inline]
        fn partial_cmp(
            &self,
            other: &MapRepresentation_StringPairs,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match *other {
                MapRepresentation_StringPairs {} => match *self {
                    MapRepresentation_StringPairs {} => {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                    }
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for MapRepresentation_StringPairs {
        #[inline]
        fn clone(&self) -> MapRepresentation_StringPairs {
            match *self {
                MapRepresentation_StringPairs {} => MapRepresentation_StringPairs {},
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for MapRepresentation_StringPairs {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                MapRepresentation_StringPairs {} => {
                    let mut debug_trait_builder = f.debug_struct("MapRepresentation_StringPairs");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    impl proptest::arbitrary::Arbitrary for MapRepresentation_StringPairs {
        type Parameters = ();
        type Strategy = proptest::strategy::BoxedStrategy<Self>;
        fn arbitrary_with(args: Self::Parameters) -> Self::Strategy {
            #[allow(dead_code)]
            fn _to_fn_ptr<T>(f: fn(&T) -> bool) -> fn(&T) -> bool {
                f
            }
            let args = std::rc::Rc::new(args);
            proptest::strategy::Strategy::boxed(proptest::strategy::LazyJust::new(|| Self {}))
        }
    }
    enum RepresentationKind {
        Bool,
        Bytes,
        Float,
        Int,
        Link,
        List,
        Map,
        String,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for RepresentationKind {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    RepresentationKind::Bool => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "RepresentationKind",
                        0u32,
                        "Bool",
                    ),
                    RepresentationKind::Bytes => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "RepresentationKind",
                        1u32,
                        "Bytes",
                    ),
                    RepresentationKind::Float => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "RepresentationKind",
                        2u32,
                        "Float",
                    ),
                    RepresentationKind::Int => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "RepresentationKind",
                        3u32,
                        "Int",
                    ),
                    RepresentationKind::Link => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "RepresentationKind",
                        4u32,
                        "Link",
                    ),
                    RepresentationKind::List => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "RepresentationKind",
                        5u32,
                        "List",
                    ),
                    RepresentationKind::Map => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "RepresentationKind",
                        6u32,
                        "Map",
                    ),
                    RepresentationKind::String => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "RepresentationKind",
                        7u32,
                        "String",
                    ),
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for RepresentationKind {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                    __field6,
                    __field7,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "variant identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::export::Ok(__Field::__field0),
                            1u64 => _serde::export::Ok(__Field::__field1),
                            2u64 => _serde::export::Ok(__Field::__field2),
                            3u64 => _serde::export::Ok(__Field::__field3),
                            4u64 => _serde::export::Ok(__Field::__field4),
                            5u64 => _serde::export::Ok(__Field::__field5),
                            6u64 => _serde::export::Ok(__Field::__field6),
                            7u64 => _serde::export::Ok(__Field::__field7),
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"variant index 0 <= i < 8",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "Bool" => _serde::export::Ok(__Field::__field0),
                            "Bytes" => _serde::export::Ok(__Field::__field1),
                            "Float" => _serde::export::Ok(__Field::__field2),
                            "Int" => _serde::export::Ok(__Field::__field3),
                            "Link" => _serde::export::Ok(__Field::__field4),
                            "List" => _serde::export::Ok(__Field::__field5),
                            "Map" => _serde::export::Ok(__Field::__field6),
                            "String" => _serde::export::Ok(__Field::__field7),
                            _ => _serde::export::Err(_serde::de::Error::unknown_variant(
                                __value, VARIANTS,
                            )),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"Bool" => _serde::export::Ok(__Field::__field0),
                            b"Bytes" => _serde::export::Ok(__Field::__field1),
                            b"Float" => _serde::export::Ok(__Field::__field2),
                            b"Int" => _serde::export::Ok(__Field::__field3),
                            b"Link" => _serde::export::Ok(__Field::__field4),
                            b"List" => _serde::export::Ok(__Field::__field5),
                            b"Map" => _serde::export::Ok(__Field::__field6),
                            b"String" => _serde::export::Ok(__Field::__field7),
                            _ => {
                                let __value = &_serde::export::from_utf8_lossy(__value);
                                _serde::export::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                ))
                            }
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::export::PhantomData<RepresentationKind>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = RepresentationKind;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "enum RepresentationKind")
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match match _serde::de::EnumAccess::variant(__data) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            (__Field::__field0, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(RepresentationKind::Bool)
                            }
                            (__Field::__field1, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(RepresentationKind::Bytes)
                            }
                            (__Field::__field2, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(RepresentationKind::Float)
                            }
                            (__Field::__field3, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(RepresentationKind::Int)
                            }
                            (__Field::__field4, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(RepresentationKind::Link)
                            }
                            (__Field::__field5, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(RepresentationKind::List)
                            }
                            (__Field::__field6, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(RepresentationKind::Map)
                            }
                            (__Field::__field7, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(RepresentationKind::String)
                            }
                        }
                    }
                }
                const VARIANTS: &'static [&'static str] = &[
                    "Bool", "Bytes", "Float", "Int", "Link", "List", "Map", "String",
                ];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "RepresentationKind",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<RepresentationKind>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    impl ::core::marker::StructuralPartialEq for RepresentationKind {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for RepresentationKind {
        #[inline]
        fn eq(&self, other: &RepresentationKind) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        _ => true,
                    }
                } else {
                    false
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialOrd for RepresentationKind {
        #[inline]
        fn partial_cmp(
            &self,
            other: &RepresentationKind,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        _ => ::core::option::Option::Some(::core::cmp::Ordering::Equal),
                    }
                } else {
                    __self_vi.partial_cmp(&__arg_1_vi)
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for RepresentationKind {
        #[inline]
        fn clone(&self) -> RepresentationKind {
            match (&*self,) {
                (&RepresentationKind::Bool,) => RepresentationKind::Bool,
                (&RepresentationKind::Bytes,) => RepresentationKind::Bytes,
                (&RepresentationKind::Float,) => RepresentationKind::Float,
                (&RepresentationKind::Int,) => RepresentationKind::Int,
                (&RepresentationKind::Link,) => RepresentationKind::Link,
                (&RepresentationKind::List,) => RepresentationKind::List,
                (&RepresentationKind::Map,) => RepresentationKind::Map,
                (&RepresentationKind::String,) => RepresentationKind::String,
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for RepresentationKind {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&RepresentationKind::Bool,) => {
                    let mut debug_trait_builder = f.debug_tuple("Bool");
                    debug_trait_builder.finish()
                }
                (&RepresentationKind::Bytes,) => {
                    let mut debug_trait_builder = f.debug_tuple("Bytes");
                    debug_trait_builder.finish()
                }
                (&RepresentationKind::Float,) => {
                    let mut debug_trait_builder = f.debug_tuple("Float");
                    debug_trait_builder.finish()
                }
                (&RepresentationKind::Int,) => {
                    let mut debug_trait_builder = f.debug_tuple("Int");
                    debug_trait_builder.finish()
                }
                (&RepresentationKind::Link,) => {
                    let mut debug_trait_builder = f.debug_tuple("Link");
                    debug_trait_builder.finish()
                }
                (&RepresentationKind::List,) => {
                    let mut debug_trait_builder = f.debug_tuple("List");
                    debug_trait_builder.finish()
                }
                (&RepresentationKind::Map,) => {
                    let mut debug_trait_builder = f.debug_tuple("Map");
                    debug_trait_builder.finish()
                }
                (&RepresentationKind::String,) => {
                    let mut debug_trait_builder = f.debug_tuple("String");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    impl proptest::arbitrary::Arbitrary for RepresentationKind {
        type Parameters = ();
        type Strategy = proptest::strategy::BoxedStrategy<Self>;
        fn arbitrary_with(args: Self::Parameters) -> Self::Strategy {
            #[allow(dead_code)]
            fn _to_fn_ptr<T>(f: fn(&T) -> bool) -> fn(&T) -> bool {
                f
            }
            let args = std::rc::Rc::new(args);
            proptest::strategy::Strategy::boxed({
                #[allow(dead_code)]
                fn _to_weight(weight: u32) -> u32 {
                    weight
                }
                let _s = ::proptest::strategy::TupleUnion::new((
                    (
                        1,
                        ::proptest::std_facade::Arc::new(proptest::strategy::LazyJust::new(|| {
                            Self::Bool
                        })),
                    ),
                    (
                        1,
                        ::proptest::std_facade::Arc::new(proptest::strategy::LazyJust::new(|| {
                            Self::Bytes
                        })),
                    ),
                    (
                        1,
                        ::proptest::std_facade::Arc::new(proptest::strategy::LazyJust::new(|| {
                            Self::Float
                        })),
                    ),
                    (
                        1,
                        ::proptest::std_facade::Arc::new(proptest::strategy::LazyJust::new(|| {
                            Self::Int
                        })),
                    ),
                    (
                        1,
                        ::proptest::std_facade::Arc::new(proptest::strategy::LazyJust::new(|| {
                            Self::Link
                        })),
                    ),
                    (
                        1,
                        ::proptest::std_facade::Arc::new(proptest::strategy::LazyJust::new(|| {
                            Self::List
                        })),
                    ),
                    (
                        1,
                        ::proptest::std_facade::Arc::new(proptest::strategy::LazyJust::new(|| {
                            Self::Map
                        })),
                    ),
                    (
                        1,
                        ::proptest::std_facade::Arc::new(proptest::strategy::LazyJust::new(|| {
                            Self::String
                        })),
                    ),
                ));
                _s
            })
        }
    }
    impl ::core::marker::StructuralEq for RepresentationKind {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::Eq for RepresentationKind {
        #[inline]
        #[doc(hidden)]
        fn assert_receiver_is_total_eq(&self) -> () {
            {}
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::Ord for RepresentationKind {
        #[inline]
        fn cmp(&self, other: &RepresentationKind) -> ::core::cmp::Ordering {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        _ => ::core::cmp::Ordering::Equal,
                    }
                } else {
                    __self_vi.cmp(&__arg_1_vi)
                }
            }
        }
    }
    struct Schema {}
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for Schema {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "Schema",
                    false as usize,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for Schema {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"field index 0 <= i < 0",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::export::PhantomData<Schema>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Schema;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "struct Schema")
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        _: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        _serde::export::Ok(Schema {})
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        while let _serde::export::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            }
                        {
                            match __key {
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        _serde::export::Ok(Schema {})
                    }
                }
                const FIELDS: &'static [&'static str] = &[];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Schema",
                    FIELDS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<Schema>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    impl ::core::marker::StructuralPartialEq for Schema {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for Schema {
        #[inline]
        fn eq(&self, other: &Schema) -> bool {
            match *other {
                Schema {} => match *self {
                    Schema {} => true,
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialOrd for Schema {
        #[inline]
        fn partial_cmp(&self, other: &Schema) -> ::core::option::Option<::core::cmp::Ordering> {
            match *other {
                Schema {} => match *self {
                    Schema {} => ::core::option::Option::Some(::core::cmp::Ordering::Equal),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for Schema {
        #[inline]
        fn clone(&self) -> Schema {
            match *self {
                Schema {} => Schema {},
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for Schema {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                Schema {} => {
                    let mut debug_trait_builder = f.debug_struct("Schema");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    impl proptest::arbitrary::Arbitrary for Schema {
        type Parameters = ();
        type Strategy = proptest::strategy::BoxedStrategy<Self>;
        fn arbitrary_with(args: Self::Parameters) -> Self::Strategy {
            #[allow(dead_code)]
            fn _to_fn_ptr<T>(f: fn(&T) -> bool) -> fn(&T) -> bool {
                f
            }
            let args = std::rc::Rc::new(args);
            proptest::strategy::Strategy::boxed(proptest::strategy::LazyJust::new(|| Self {}))
        }
    }
    struct SchemaMap(Map<TypeName, Type>);
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for SchemaMap {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                _serde::Serializer::serialize_newtype_struct(__serializer, "SchemaMap", &self.0)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for SchemaMap {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                struct __Visitor<'de> {
                    marker: _serde::export::PhantomData<SchemaMap>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = SchemaMap;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "tuple struct SchemaMap")
                    }
                    #[inline]
                    fn visit_newtype_struct<__E>(
                        self,
                        __e: __E,
                    ) -> _serde::export::Result<Self::Value, __E::Error>
                    where
                        __E: _serde::Deserializer<'de>,
                    {
                        let __field0: Map<TypeName, Type> =
                            match <Map<TypeName, Type> as _serde::Deserialize>::deserialize(__e) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            };
                        _serde::export::Ok(SchemaMap(__field0))
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                            Map<TypeName, Type>,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    0usize,
                                    &"tuple struct SchemaMap with 1 element",
                                ));
                            }
                        };
                        _serde::export::Ok(SchemaMap(__field0))
                    }
                }
                _serde::Deserializer::deserialize_newtype_struct(
                    __deserializer,
                    "SchemaMap",
                    __Visitor {
                        marker: _serde::export::PhantomData::<SchemaMap>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    impl ::core::marker::StructuralPartialEq for SchemaMap {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for SchemaMap {
        #[inline]
        fn eq(&self, other: &SchemaMap) -> bool {
            match *other {
                SchemaMap(ref __self_1_0) => match *self {
                    SchemaMap(ref __self_0_0) => (*__self_0_0) == (*__self_1_0),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &SchemaMap) -> bool {
            match *other {
                SchemaMap(ref __self_1_0) => match *self {
                    SchemaMap(ref __self_0_0) => (*__self_0_0) != (*__self_1_0),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialOrd for SchemaMap {
        #[inline]
        fn partial_cmp(&self, other: &SchemaMap) -> ::core::option::Option<::core::cmp::Ordering> {
            match *other {
                SchemaMap(ref __self_1_0) => match *self {
                    SchemaMap(ref __self_0_0) => {
                        match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0), &(*__self_1_0)) {
                            ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                            }
                            cmp => cmp,
                        }
                    }
                },
            }
        }
        #[inline]
        fn lt(&self, other: &SchemaMap) -> bool {
            match *other {
                SchemaMap(ref __self_1_0) => match *self {
                    SchemaMap(ref __self_0_0) => {
                        ::core::option::Option::unwrap_or(
                            ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0), &(*__self_1_0)),
                            ::core::cmp::Ordering::Greater,
                        ) == ::core::cmp::Ordering::Less
                    }
                },
            }
        }
        #[inline]
        fn le(&self, other: &SchemaMap) -> bool {
            match *other {
                SchemaMap(ref __self_1_0) => match *self {
                    SchemaMap(ref __self_0_0) => {
                        ::core::option::Option::unwrap_or(
                            ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0), &(*__self_1_0)),
                            ::core::cmp::Ordering::Greater,
                        ) != ::core::cmp::Ordering::Greater
                    }
                },
            }
        }
        #[inline]
        fn gt(&self, other: &SchemaMap) -> bool {
            match *other {
                SchemaMap(ref __self_1_0) => match *self {
                    SchemaMap(ref __self_0_0) => {
                        ::core::option::Option::unwrap_or(
                            ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0), &(*__self_1_0)),
                            ::core::cmp::Ordering::Less,
                        ) == ::core::cmp::Ordering::Greater
                    }
                },
            }
        }
        #[inline]
        fn ge(&self, other: &SchemaMap) -> bool {
            match *other {
                SchemaMap(ref __self_1_0) => match *self {
                    SchemaMap(ref __self_0_0) => {
                        ::core::option::Option::unwrap_or(
                            ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0), &(*__self_1_0)),
                            ::core::cmp::Ordering::Less,
                        ) != ::core::cmp::Ordering::Less
                    }
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for SchemaMap {
        #[inline]
        fn clone(&self) -> SchemaMap {
            match *self {
                SchemaMap(ref __self_0_0) => SchemaMap(::core::clone::Clone::clone(&(*__self_0_0))),
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for SchemaMap {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                SchemaMap(ref __self_0_0) => {
                    let mut debug_trait_builder = f.debug_tuple("SchemaMap");
                    let _ = debug_trait_builder.field(&&(*__self_0_0));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    impl proptest::arbitrary::Arbitrary for SchemaMap {
        type Parameters = ();
        type Strategy = proptest::strategy::BoxedStrategy<Self>;
        fn arbitrary_with(args: Self::Parameters) -> Self::Strategy {
            #[allow(dead_code)]
            fn _to_fn_ptr<T>(f: fn(&T) -> bool) -> fn(&T) -> bool {
                f
            }
            let args = std::rc::Rc::new(args);
            proptest::strategy::Strategy::boxed({
                let strategy_0 = ({
                    #[allow(dead_code)]
                    fn _strategy_of_0<
                        T: std::fmt::Debug,
                        S: proptest::strategy::Strategy<Value = T>,
                    >(
                        s: S,
                    ) -> impl proptest::strategy::Strategy<Value = T> {
                        s
                    }
                    let _s = proptest::arbitrary::any::<Map<TypeName, Type>>();
                    _s
                },);
                let strategy_0 =
                    proptest::strategy::Strategy::prop_map(strategy_0, |_values| Self(_values.0));
                strategy_0
            })
        }
    }
    struct StructField {}
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for StructField {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "StructField",
                    false as usize,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for StructField {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"field index 0 <= i < 0",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::export::PhantomData<StructField>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = StructField;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "struct StructField")
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        _: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        _serde::export::Ok(StructField {})
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        while let _serde::export::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            }
                        {
                            match __key {
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        _serde::export::Ok(StructField {})
                    }
                }
                const FIELDS: &'static [&'static str] = &[];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "StructField",
                    FIELDS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<StructField>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    impl ::core::marker::StructuralPartialEq for StructField {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for StructField {
        #[inline]
        fn eq(&self, other: &StructField) -> bool {
            match *other {
                StructField {} => match *self {
                    StructField {} => true,
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialOrd for StructField {
        #[inline]
        fn partial_cmp(
            &self,
            other: &StructField,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match *other {
                StructField {} => match *self {
                    StructField {} => ::core::option::Option::Some(::core::cmp::Ordering::Equal),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for StructField {
        #[inline]
        fn clone(&self) -> StructField {
            match *self {
                StructField {} => StructField {},
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for StructField {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                StructField {} => {
                    let mut debug_trait_builder = f.debug_struct("StructField");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    impl proptest::arbitrary::Arbitrary for StructField {
        type Parameters = ();
        type Strategy = proptest::strategy::BoxedStrategy<Self>;
        fn arbitrary_with(args: Self::Parameters) -> Self::Strategy {
            #[allow(dead_code)]
            fn _to_fn_ptr<T>(f: fn(&T) -> bool) -> fn(&T) -> bool {
                f
            }
            let args = std::rc::Rc::new(args);
            proptest::strategy::Strategy::boxed(proptest::strategy::LazyJust::new(|| Self {}))
        }
    }
    enum StructRepresentation {
        listpairs(StructRepresentation_ListPairs),
        map(StructRepresentation_Map),
        stringjoin(StructRepresentation_StringJoin),
        stringpairs(StructRepresentation_StringPairs),
        tuple(StructRepresentation_Tuple),
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for StructRepresentation {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    StructRepresentation::listpairs(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "StructRepresentation",
                            0u32,
                            "listpairs",
                            __field0,
                        )
                    }
                    StructRepresentation::map(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "StructRepresentation",
                            1u32,
                            "map",
                            __field0,
                        )
                    }
                    StructRepresentation::stringjoin(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "StructRepresentation",
                            2u32,
                            "stringjoin",
                            __field0,
                        )
                    }
                    StructRepresentation::stringpairs(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "StructRepresentation",
                            3u32,
                            "stringpairs",
                            __field0,
                        )
                    }
                    StructRepresentation::tuple(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "StructRepresentation",
                            4u32,
                            "tuple",
                            __field0,
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for StructRepresentation {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "variant identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::export::Ok(__Field::__field0),
                            1u64 => _serde::export::Ok(__Field::__field1),
                            2u64 => _serde::export::Ok(__Field::__field2),
                            3u64 => _serde::export::Ok(__Field::__field3),
                            4u64 => _serde::export::Ok(__Field::__field4),
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"variant index 0 <= i < 5",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "listpairs" => _serde::export::Ok(__Field::__field0),
                            "map" => _serde::export::Ok(__Field::__field1),
                            "stringjoin" => _serde::export::Ok(__Field::__field2),
                            "stringpairs" => _serde::export::Ok(__Field::__field3),
                            "tuple" => _serde::export::Ok(__Field::__field4),
                            _ => _serde::export::Err(_serde::de::Error::unknown_variant(
                                __value, VARIANTS,
                            )),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"listpairs" => _serde::export::Ok(__Field::__field0),
                            b"map" => _serde::export::Ok(__Field::__field1),
                            b"stringjoin" => _serde::export::Ok(__Field::__field2),
                            b"stringpairs" => _serde::export::Ok(__Field::__field3),
                            b"tuple" => _serde::export::Ok(__Field::__field4),
                            _ => {
                                let __value = &_serde::export::from_utf8_lossy(__value);
                                _serde::export::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                ))
                            }
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::export::PhantomData<StructRepresentation>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = StructRepresentation;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(
                            __formatter,
                            "enum StructRepresentation",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match match _serde::de::EnumAccess::variant(__data) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            (__Field::__field0, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<
                                    StructRepresentation_ListPairs,
                                >(__variant),
                                StructRepresentation::listpairs,
                            ),
                            (__Field::__field1, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<
                                    StructRepresentation_Map,
                                >(__variant),
                                StructRepresentation::map,
                            ),
                            (__Field::__field2, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<
                                    StructRepresentation_StringJoin,
                                >(__variant),
                                StructRepresentation::stringjoin,
                            ),
                            (__Field::__field3, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<
                                    StructRepresentation_StringPairs,
                                >(__variant),
                                StructRepresentation::stringpairs,
                            ),
                            (__Field::__field4, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<
                                    StructRepresentation_Tuple,
                                >(__variant),
                                StructRepresentation::tuple,
                            ),
                        }
                    }
                }
                const VARIANTS: &'static [&'static str] =
                    &["listpairs", "map", "stringjoin", "stringpairs", "tuple"];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "StructRepresentation",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<StructRepresentation>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    impl ::core::marker::StructuralPartialEq for StructRepresentation {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for StructRepresentation {
        #[inline]
        fn eq(&self, other: &StructRepresentation) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (
                            &StructRepresentation::listpairs(ref __self_0),
                            &StructRepresentation::listpairs(ref __arg_1_0),
                        ) => (*__self_0) == (*__arg_1_0),
                        (
                            &StructRepresentation::map(ref __self_0),
                            &StructRepresentation::map(ref __arg_1_0),
                        ) => (*__self_0) == (*__arg_1_0),
                        (
                            &StructRepresentation::stringjoin(ref __self_0),
                            &StructRepresentation::stringjoin(ref __arg_1_0),
                        ) => (*__self_0) == (*__arg_1_0),
                        (
                            &StructRepresentation::stringpairs(ref __self_0),
                            &StructRepresentation::stringpairs(ref __arg_1_0),
                        ) => (*__self_0) == (*__arg_1_0),
                        (
                            &StructRepresentation::tuple(ref __self_0),
                            &StructRepresentation::tuple(ref __arg_1_0),
                        ) => (*__self_0) == (*__arg_1_0),
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    false
                }
            }
        }
        #[inline]
        fn ne(&self, other: &StructRepresentation) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (
                            &StructRepresentation::listpairs(ref __self_0),
                            &StructRepresentation::listpairs(ref __arg_1_0),
                        ) => (*__self_0) != (*__arg_1_0),
                        (
                            &StructRepresentation::map(ref __self_0),
                            &StructRepresentation::map(ref __arg_1_0),
                        ) => (*__self_0) != (*__arg_1_0),
                        (
                            &StructRepresentation::stringjoin(ref __self_0),
                            &StructRepresentation::stringjoin(ref __arg_1_0),
                        ) => (*__self_0) != (*__arg_1_0),
                        (
                            &StructRepresentation::stringpairs(ref __self_0),
                            &StructRepresentation::stringpairs(ref __arg_1_0),
                        ) => (*__self_0) != (*__arg_1_0),
                        (
                            &StructRepresentation::tuple(ref __self_0),
                            &StructRepresentation::tuple(ref __arg_1_0),
                        ) => (*__self_0) != (*__arg_1_0),
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    true
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialOrd for StructRepresentation {
        #[inline]
        fn partial_cmp(
            &self,
            other: &StructRepresentation,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (
                            &StructRepresentation::listpairs(ref __self_0),
                            &StructRepresentation::listpairs(ref __arg_1_0),
                        ) => {
                            match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0))
                            {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                }
                                cmp => cmp,
                            }
                        }
                        (
                            &StructRepresentation::map(ref __self_0),
                            &StructRepresentation::map(ref __arg_1_0),
                        ) => {
                            match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0))
                            {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                }
                                cmp => cmp,
                            }
                        }
                        (
                            &StructRepresentation::stringjoin(ref __self_0),
                            &StructRepresentation::stringjoin(ref __arg_1_0),
                        ) => {
                            match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0))
                            {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                }
                                cmp => cmp,
                            }
                        }
                        (
                            &StructRepresentation::stringpairs(ref __self_0),
                            &StructRepresentation::stringpairs(ref __arg_1_0),
                        ) => {
                            match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0))
                            {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                }
                                cmp => cmp,
                            }
                        }
                        (
                            &StructRepresentation::tuple(ref __self_0),
                            &StructRepresentation::tuple(ref __arg_1_0),
                        ) => {
                            match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0))
                            {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                }
                                cmp => cmp,
                            }
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    __self_vi.partial_cmp(&__arg_1_vi)
                }
            }
        }
        #[inline]
        fn lt(&self, other: &StructRepresentation) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (
                            &StructRepresentation::listpairs(ref __self_0),
                            &StructRepresentation::listpairs(ref __arg_1_0),
                        ) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Greater,
                            ) == ::core::cmp::Ordering::Less
                        }
                        (
                            &StructRepresentation::map(ref __self_0),
                            &StructRepresentation::map(ref __arg_1_0),
                        ) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Greater,
                            ) == ::core::cmp::Ordering::Less
                        }
                        (
                            &StructRepresentation::stringjoin(ref __self_0),
                            &StructRepresentation::stringjoin(ref __arg_1_0),
                        ) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Greater,
                            ) == ::core::cmp::Ordering::Less
                        }
                        (
                            &StructRepresentation::stringpairs(ref __self_0),
                            &StructRepresentation::stringpairs(ref __arg_1_0),
                        ) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Greater,
                            ) == ::core::cmp::Ordering::Less
                        }
                        (
                            &StructRepresentation::tuple(ref __self_0),
                            &StructRepresentation::tuple(ref __arg_1_0),
                        ) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Greater,
                            ) == ::core::cmp::Ordering::Less
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    __self_vi.lt(&__arg_1_vi)
                }
            }
        }
        #[inline]
        fn le(&self, other: &StructRepresentation) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (
                            &StructRepresentation::listpairs(ref __self_0),
                            &StructRepresentation::listpairs(ref __arg_1_0),
                        ) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Greater,
                            ) != ::core::cmp::Ordering::Greater
                        }
                        (
                            &StructRepresentation::map(ref __self_0),
                            &StructRepresentation::map(ref __arg_1_0),
                        ) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Greater,
                            ) != ::core::cmp::Ordering::Greater
                        }
                        (
                            &StructRepresentation::stringjoin(ref __self_0),
                            &StructRepresentation::stringjoin(ref __arg_1_0),
                        ) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Greater,
                            ) != ::core::cmp::Ordering::Greater
                        }
                        (
                            &StructRepresentation::stringpairs(ref __self_0),
                            &StructRepresentation::stringpairs(ref __arg_1_0),
                        ) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Greater,
                            ) != ::core::cmp::Ordering::Greater
                        }
                        (
                            &StructRepresentation::tuple(ref __self_0),
                            &StructRepresentation::tuple(ref __arg_1_0),
                        ) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Greater,
                            ) != ::core::cmp::Ordering::Greater
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    __self_vi.le(&__arg_1_vi)
                }
            }
        }
        #[inline]
        fn gt(&self, other: &StructRepresentation) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (
                            &StructRepresentation::listpairs(ref __self_0),
                            &StructRepresentation::listpairs(ref __arg_1_0),
                        ) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Less,
                            ) == ::core::cmp::Ordering::Greater
                        }
                        (
                            &StructRepresentation::map(ref __self_0),
                            &StructRepresentation::map(ref __arg_1_0),
                        ) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Less,
                            ) == ::core::cmp::Ordering::Greater
                        }
                        (
                            &StructRepresentation::stringjoin(ref __self_0),
                            &StructRepresentation::stringjoin(ref __arg_1_0),
                        ) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Less,
                            ) == ::core::cmp::Ordering::Greater
                        }
                        (
                            &StructRepresentation::stringpairs(ref __self_0),
                            &StructRepresentation::stringpairs(ref __arg_1_0),
                        ) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Less,
                            ) == ::core::cmp::Ordering::Greater
                        }
                        (
                            &StructRepresentation::tuple(ref __self_0),
                            &StructRepresentation::tuple(ref __arg_1_0),
                        ) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Less,
                            ) == ::core::cmp::Ordering::Greater
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    __self_vi.gt(&__arg_1_vi)
                }
            }
        }
        #[inline]
        fn ge(&self, other: &StructRepresentation) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (
                            &StructRepresentation::listpairs(ref __self_0),
                            &StructRepresentation::listpairs(ref __arg_1_0),
                        ) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Less,
                            ) != ::core::cmp::Ordering::Less
                        }
                        (
                            &StructRepresentation::map(ref __self_0),
                            &StructRepresentation::map(ref __arg_1_0),
                        ) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Less,
                            ) != ::core::cmp::Ordering::Less
                        }
                        (
                            &StructRepresentation::stringjoin(ref __self_0),
                            &StructRepresentation::stringjoin(ref __arg_1_0),
                        ) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Less,
                            ) != ::core::cmp::Ordering::Less
                        }
                        (
                            &StructRepresentation::stringpairs(ref __self_0),
                            &StructRepresentation::stringpairs(ref __arg_1_0),
                        ) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Less,
                            ) != ::core::cmp::Ordering::Less
                        }
                        (
                            &StructRepresentation::tuple(ref __self_0),
                            &StructRepresentation::tuple(ref __arg_1_0),
                        ) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Less,
                            ) != ::core::cmp::Ordering::Less
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    __self_vi.ge(&__arg_1_vi)
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for StructRepresentation {
        #[inline]
        fn clone(&self) -> StructRepresentation {
            match (&*self,) {
                (&StructRepresentation::listpairs(ref __self_0),) => {
                    StructRepresentation::listpairs(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&StructRepresentation::map(ref __self_0),) => {
                    StructRepresentation::map(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&StructRepresentation::stringjoin(ref __self_0),) => {
                    StructRepresentation::stringjoin(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&StructRepresentation::stringpairs(ref __self_0),) => {
                    StructRepresentation::stringpairs(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&StructRepresentation::tuple(ref __self_0),) => {
                    StructRepresentation::tuple(::core::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for StructRepresentation {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&StructRepresentation::listpairs(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("listpairs");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&StructRepresentation::map(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("map");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&StructRepresentation::stringjoin(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("stringjoin");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&StructRepresentation::stringpairs(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("stringpairs");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&StructRepresentation::tuple(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("tuple");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    impl proptest::arbitrary::Arbitrary for StructRepresentation {
        type Parameters = ();
        type Strategy = proptest::strategy::BoxedStrategy<Self>;
        fn arbitrary_with(args: Self::Parameters) -> Self::Strategy {
            #[allow(dead_code)]
            fn _to_fn_ptr<T>(f: fn(&T) -> bool) -> fn(&T) -> bool {
                f
            }
            let args = std::rc::Rc::new(args);
            proptest::strategy::Strategy::boxed({
                #[allow(dead_code)]
                fn _to_weight(weight: u32) -> u32 {
                    weight
                }
                let _s = ::proptest::strategy::TupleUnion::new((
                    (
                        1,
                        ::proptest::std_facade::Arc::new({
                            let strategy_0 = ({
                                #[allow(dead_code)]
                                fn _strategy_of_0<
                                    T: std::fmt::Debug,
                                    S: proptest::strategy::Strategy<Value = T>,
                                >(
                                    s: S,
                                ) -> impl proptest::strategy::Strategy<Value = T>
                                {
                                    s
                                }
                                let _s =
                                    proptest::arbitrary::any::<StructRepresentation_ListPairs>();
                                _s
                            },);
                            let strategy_0 =
                                proptest::strategy::Strategy::prop_map(strategy_0, |_values| {
                                    Self::listpairs(_values.0)
                                });
                            strategy_0
                        }),
                    ),
                    (
                        1,
                        ::proptest::std_facade::Arc::new({
                            let strategy_0 = ({
                                #[allow(dead_code)]
                                fn _strategy_of_0<
                                    T: std::fmt::Debug,
                                    S: proptest::strategy::Strategy<Value = T>,
                                >(
                                    s: S,
                                ) -> impl proptest::strategy::Strategy<Value = T>
                                {
                                    s
                                }
                                let _s = proptest::arbitrary::any::<StructRepresentation_Map>();
                                _s
                            },);
                            let strategy_0 =
                                proptest::strategy::Strategy::prop_map(strategy_0, |_values| {
                                    Self::map(_values.0)
                                });
                            strategy_0
                        }),
                    ),
                    (
                        1,
                        ::proptest::std_facade::Arc::new({
                            let strategy_0 = ({
                                #[allow(dead_code)]
                                fn _strategy_of_0<
                                    T: std::fmt::Debug,
                                    S: proptest::strategy::Strategy<Value = T>,
                                >(
                                    s: S,
                                ) -> impl proptest::strategy::Strategy<Value = T>
                                {
                                    s
                                }
                                let _s =
                                    proptest::arbitrary::any::<StructRepresentation_StringJoin>();
                                _s
                            },);
                            let strategy_0 =
                                proptest::strategy::Strategy::prop_map(strategy_0, |_values| {
                                    Self::stringjoin(_values.0)
                                });
                            strategy_0
                        }),
                    ),
                    (
                        1,
                        ::proptest::std_facade::Arc::new({
                            let strategy_0 = ({
                                #[allow(dead_code)]
                                fn _strategy_of_0<
                                    T: std::fmt::Debug,
                                    S: proptest::strategy::Strategy<Value = T>,
                                >(
                                    s: S,
                                ) -> impl proptest::strategy::Strategy<Value = T>
                                {
                                    s
                                }
                                let _s =
                                    proptest::arbitrary::any::<StructRepresentation_StringPairs>();
                                _s
                            },);
                            let strategy_0 =
                                proptest::strategy::Strategy::prop_map(strategy_0, |_values| {
                                    Self::stringpairs(_values.0)
                                });
                            strategy_0
                        }),
                    ),
                    (
                        1,
                        ::proptest::std_facade::Arc::new({
                            let strategy_0 = ({
                                #[allow(dead_code)]
                                fn _strategy_of_0<
                                    T: std::fmt::Debug,
                                    S: proptest::strategy::Strategy<Value = T>,
                                >(
                                    s: S,
                                ) -> impl proptest::strategy::Strategy<Value = T>
                                {
                                    s
                                }
                                let _s = proptest::arbitrary::any::<StructRepresentation_Tuple>();
                                _s
                            },);
                            let strategy_0 =
                                proptest::strategy::Strategy::prop_map(strategy_0, |_values| {
                                    Self::tuple(_values.0)
                                });
                            strategy_0
                        }),
                    ),
                ));
                _s
            })
        }
    }
    struct StructRepresentation_ListPairs {}
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for StructRepresentation_ListPairs {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "StructRepresentation_ListPairs",
                    false as usize,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for StructRepresentation_ListPairs {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"field index 0 <= i < 0",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::export::PhantomData<StructRepresentation_ListPairs>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = StructRepresentation_ListPairs;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(
                            __formatter,
                            "struct StructRepresentation_ListPairs",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        _: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        _serde::export::Ok(StructRepresentation_ListPairs {})
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        while let _serde::export::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            }
                        {
                            match __key {
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        _serde::export::Ok(StructRepresentation_ListPairs {})
                    }
                }
                const FIELDS: &'static [&'static str] = &[];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "StructRepresentation_ListPairs",
                    FIELDS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<StructRepresentation_ListPairs>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    impl ::core::marker::StructuralPartialEq for StructRepresentation_ListPairs {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for StructRepresentation_ListPairs {
        #[inline]
        fn eq(&self, other: &StructRepresentation_ListPairs) -> bool {
            match *other {
                StructRepresentation_ListPairs {} => match *self {
                    StructRepresentation_ListPairs {} => true,
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialOrd for StructRepresentation_ListPairs {
        #[inline]
        fn partial_cmp(
            &self,
            other: &StructRepresentation_ListPairs,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match *other {
                StructRepresentation_ListPairs {} => match *self {
                    StructRepresentation_ListPairs {} => {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                    }
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for StructRepresentation_ListPairs {
        #[inline]
        fn clone(&self) -> StructRepresentation_ListPairs {
            match *self {
                StructRepresentation_ListPairs {} => StructRepresentation_ListPairs {},
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for StructRepresentation_ListPairs {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                StructRepresentation_ListPairs {} => {
                    let mut debug_trait_builder = f.debug_struct("StructRepresentation_ListPairs");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    impl proptest::arbitrary::Arbitrary for StructRepresentation_ListPairs {
        type Parameters = ();
        type Strategy = proptest::strategy::BoxedStrategy<Self>;
        fn arbitrary_with(args: Self::Parameters) -> Self::Strategy {
            #[allow(dead_code)]
            fn _to_fn_ptr<T>(f: fn(&T) -> bool) -> fn(&T) -> bool {
                f
            }
            let args = std::rc::Rc::new(args);
            proptest::strategy::Strategy::boxed(proptest::strategy::LazyJust::new(|| Self {}))
        }
    }
    struct StructRepresentation_Map {}
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for StructRepresentation_Map {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "StructRepresentation_Map",
                    false as usize,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for StructRepresentation_Map {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"field index 0 <= i < 0",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::export::PhantomData<StructRepresentation_Map>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = StructRepresentation_Map;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(
                            __formatter,
                            "struct StructRepresentation_Map",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        _: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        _serde::export::Ok(StructRepresentation_Map {})
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        while let _serde::export::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            }
                        {
                            match __key {
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        _serde::export::Ok(StructRepresentation_Map {})
                    }
                }
                const FIELDS: &'static [&'static str] = &[];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "StructRepresentation_Map",
                    FIELDS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<StructRepresentation_Map>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    impl ::core::marker::StructuralPartialEq for StructRepresentation_Map {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for StructRepresentation_Map {
        #[inline]
        fn eq(&self, other: &StructRepresentation_Map) -> bool {
            match *other {
                StructRepresentation_Map {} => match *self {
                    StructRepresentation_Map {} => true,
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialOrd for StructRepresentation_Map {
        #[inline]
        fn partial_cmp(
            &self,
            other: &StructRepresentation_Map,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match *other {
                StructRepresentation_Map {} => match *self {
                    StructRepresentation_Map {} => {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                    }
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for StructRepresentation_Map {
        #[inline]
        fn clone(&self) -> StructRepresentation_Map {
            match *self {
                StructRepresentation_Map {} => StructRepresentation_Map {},
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for StructRepresentation_Map {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                StructRepresentation_Map {} => {
                    let mut debug_trait_builder = f.debug_struct("StructRepresentation_Map");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    impl proptest::arbitrary::Arbitrary for StructRepresentation_Map {
        type Parameters = ();
        type Strategy = proptest::strategy::BoxedStrategy<Self>;
        fn arbitrary_with(args: Self::Parameters) -> Self::Strategy {
            #[allow(dead_code)]
            fn _to_fn_ptr<T>(f: fn(&T) -> bool) -> fn(&T) -> bool {
                f
            }
            let args = std::rc::Rc::new(args);
            proptest::strategy::Strategy::boxed(proptest::strategy::LazyJust::new(|| Self {}))
        }
    }
    struct StructRepresentation_Map_FieldDetails {}
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for StructRepresentation_Map_FieldDetails {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "StructRepresentation_Map_FieldDetails",
                    false as usize,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for StructRepresentation_Map_FieldDetails {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"field index 0 <= i < 0",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::export::PhantomData<StructRepresentation_Map_FieldDetails>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = StructRepresentation_Map_FieldDetails;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(
                            __formatter,
                            "struct StructRepresentation_Map_FieldDetails",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        _: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        _serde::export::Ok(StructRepresentation_Map_FieldDetails {})
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        while let _serde::export::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            }
                        {
                            match __key {
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        _serde::export::Ok(StructRepresentation_Map_FieldDetails {})
                    }
                }
                const FIELDS: &'static [&'static str] = &[];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "StructRepresentation_Map_FieldDetails",
                    FIELDS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<StructRepresentation_Map_FieldDetails>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    impl ::core::marker::StructuralPartialEq for StructRepresentation_Map_FieldDetails {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for StructRepresentation_Map_FieldDetails {
        #[inline]
        fn eq(&self, other: &StructRepresentation_Map_FieldDetails) -> bool {
            match *other {
                StructRepresentation_Map_FieldDetails {} => match *self {
                    StructRepresentation_Map_FieldDetails {} => true,
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialOrd for StructRepresentation_Map_FieldDetails {
        #[inline]
        fn partial_cmp(
            &self,
            other: &StructRepresentation_Map_FieldDetails,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match *other {
                StructRepresentation_Map_FieldDetails {} => match *self {
                    StructRepresentation_Map_FieldDetails {} => {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                    }
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for StructRepresentation_Map_FieldDetails {
        #[inline]
        fn clone(&self) -> StructRepresentation_Map_FieldDetails {
            match *self {
                StructRepresentation_Map_FieldDetails {} => {
                    StructRepresentation_Map_FieldDetails {}
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for StructRepresentation_Map_FieldDetails {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                StructRepresentation_Map_FieldDetails {} => {
                    let mut debug_trait_builder =
                        f.debug_struct("StructRepresentation_Map_FieldDetails");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    impl proptest::arbitrary::Arbitrary for StructRepresentation_Map_FieldDetails {
        type Parameters = ();
        type Strategy = proptest::strategy::BoxedStrategy<Self>;
        fn arbitrary_with(args: Self::Parameters) -> Self::Strategy {
            #[allow(dead_code)]
            fn _to_fn_ptr<T>(f: fn(&T) -> bool) -> fn(&T) -> bool {
                f
            }
            let args = std::rc::Rc::new(args);
            proptest::strategy::Strategy::boxed(proptest::strategy::LazyJust::new(|| Self {}))
        }
    }
    struct StructRepresentation_StringJoin {}
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for StructRepresentation_StringJoin {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "StructRepresentation_StringJoin",
                    false as usize,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for StructRepresentation_StringJoin {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"field index 0 <= i < 0",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::export::PhantomData<StructRepresentation_StringJoin>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = StructRepresentation_StringJoin;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(
                            __formatter,
                            "struct StructRepresentation_StringJoin",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        _: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        _serde::export::Ok(StructRepresentation_StringJoin {})
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        while let _serde::export::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            }
                        {
                            match __key {
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        _serde::export::Ok(StructRepresentation_StringJoin {})
                    }
                }
                const FIELDS: &'static [&'static str] = &[];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "StructRepresentation_StringJoin",
                    FIELDS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<StructRepresentation_StringJoin>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    impl ::core::marker::StructuralPartialEq for StructRepresentation_StringJoin {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for StructRepresentation_StringJoin {
        #[inline]
        fn eq(&self, other: &StructRepresentation_StringJoin) -> bool {
            match *other {
                StructRepresentation_StringJoin {} => match *self {
                    StructRepresentation_StringJoin {} => true,
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialOrd for StructRepresentation_StringJoin {
        #[inline]
        fn partial_cmp(
            &self,
            other: &StructRepresentation_StringJoin,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match *other {
                StructRepresentation_StringJoin {} => match *self {
                    StructRepresentation_StringJoin {} => {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                    }
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for StructRepresentation_StringJoin {
        #[inline]
        fn clone(&self) -> StructRepresentation_StringJoin {
            match *self {
                StructRepresentation_StringJoin {} => StructRepresentation_StringJoin {},
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for StructRepresentation_StringJoin {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                StructRepresentation_StringJoin {} => {
                    let mut debug_trait_builder = f.debug_struct("StructRepresentation_StringJoin");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    impl proptest::arbitrary::Arbitrary for StructRepresentation_StringJoin {
        type Parameters = ();
        type Strategy = proptest::strategy::BoxedStrategy<Self>;
        fn arbitrary_with(args: Self::Parameters) -> Self::Strategy {
            #[allow(dead_code)]
            fn _to_fn_ptr<T>(f: fn(&T) -> bool) -> fn(&T) -> bool {
                f
            }
            let args = std::rc::Rc::new(args);
            proptest::strategy::Strategy::boxed(proptest::strategy::LazyJust::new(|| Self {}))
        }
    }
    struct StructRepresentation_StringPairs {}
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for StructRepresentation_StringPairs {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "StructRepresentation_StringPairs",
                    false as usize,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for StructRepresentation_StringPairs {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"field index 0 <= i < 0",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::export::PhantomData<StructRepresentation_StringPairs>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = StructRepresentation_StringPairs;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(
                            __formatter,
                            "struct StructRepresentation_StringPairs",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        _: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        _serde::export::Ok(StructRepresentation_StringPairs {})
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        while let _serde::export::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            }
                        {
                            match __key {
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        _serde::export::Ok(StructRepresentation_StringPairs {})
                    }
                }
                const FIELDS: &'static [&'static str] = &[];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "StructRepresentation_StringPairs",
                    FIELDS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<StructRepresentation_StringPairs>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    impl ::core::marker::StructuralPartialEq for StructRepresentation_StringPairs {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for StructRepresentation_StringPairs {
        #[inline]
        fn eq(&self, other: &StructRepresentation_StringPairs) -> bool {
            match *other {
                StructRepresentation_StringPairs {} => match *self {
                    StructRepresentation_StringPairs {} => true,
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialOrd for StructRepresentation_StringPairs {
        #[inline]
        fn partial_cmp(
            &self,
            other: &StructRepresentation_StringPairs,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match *other {
                StructRepresentation_StringPairs {} => match *self {
                    StructRepresentation_StringPairs {} => {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                    }
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for StructRepresentation_StringPairs {
        #[inline]
        fn clone(&self) -> StructRepresentation_StringPairs {
            match *self {
                StructRepresentation_StringPairs {} => StructRepresentation_StringPairs {},
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for StructRepresentation_StringPairs {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                StructRepresentation_StringPairs {} => {
                    let mut debug_trait_builder =
                        f.debug_struct("StructRepresentation_StringPairs");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    impl proptest::arbitrary::Arbitrary for StructRepresentation_StringPairs {
        type Parameters = ();
        type Strategy = proptest::strategy::BoxedStrategy<Self>;
        fn arbitrary_with(args: Self::Parameters) -> Self::Strategy {
            #[allow(dead_code)]
            fn _to_fn_ptr<T>(f: fn(&T) -> bool) -> fn(&T) -> bool {
                f
            }
            let args = std::rc::Rc::new(args);
            proptest::strategy::Strategy::boxed(proptest::strategy::LazyJust::new(|| Self {}))
        }
    }
    struct StructRepresentation_Tuple {}
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for StructRepresentation_Tuple {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "StructRepresentation_Tuple",
                    false as usize,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for StructRepresentation_Tuple {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"field index 0 <= i < 0",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::export::PhantomData<StructRepresentation_Tuple>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = StructRepresentation_Tuple;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(
                            __formatter,
                            "struct StructRepresentation_Tuple",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        _: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        _serde::export::Ok(StructRepresentation_Tuple {})
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        while let _serde::export::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            }
                        {
                            match __key {
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        _serde::export::Ok(StructRepresentation_Tuple {})
                    }
                }
                const FIELDS: &'static [&'static str] = &[];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "StructRepresentation_Tuple",
                    FIELDS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<StructRepresentation_Tuple>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    impl ::core::marker::StructuralPartialEq for StructRepresentation_Tuple {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for StructRepresentation_Tuple {
        #[inline]
        fn eq(&self, other: &StructRepresentation_Tuple) -> bool {
            match *other {
                StructRepresentation_Tuple {} => match *self {
                    StructRepresentation_Tuple {} => true,
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialOrd for StructRepresentation_Tuple {
        #[inline]
        fn partial_cmp(
            &self,
            other: &StructRepresentation_Tuple,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match *other {
                StructRepresentation_Tuple {} => match *self {
                    StructRepresentation_Tuple {} => {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                    }
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for StructRepresentation_Tuple {
        #[inline]
        fn clone(&self) -> StructRepresentation_Tuple {
            match *self {
                StructRepresentation_Tuple {} => StructRepresentation_Tuple {},
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for StructRepresentation_Tuple {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                StructRepresentation_Tuple {} => {
                    let mut debug_trait_builder = f.debug_struct("StructRepresentation_Tuple");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    impl proptest::arbitrary::Arbitrary for StructRepresentation_Tuple {
        type Parameters = ();
        type Strategy = proptest::strategy::BoxedStrategy<Self>;
        fn arbitrary_with(args: Self::Parameters) -> Self::Strategy {
            #[allow(dead_code)]
            fn _to_fn_ptr<T>(f: fn(&T) -> bool) -> fn(&T) -> bool {
                f
            }
            let args = std::rc::Rc::new(args);
            proptest::strategy::Strategy::boxed(proptest::strategy::LazyJust::new(|| Self {}))
        }
    }
    enum Type {
        bool(TypeBool),
        bytes(TypeBytes),
        copy(TypeCopy),
        r#enum(TypeEnum),
        float(TypeFloat),
        int(TypeInt),
        link(TypeLink),
        list(TypeList),
        map(TypeMap),
        string(TypeString),
        r#struct(TypeStruct),
        union(TypeUnion),
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for Type {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    Type::bool(ref __field0) => _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "Type",
                        0u32,
                        "bool",
                        __field0,
                    ),
                    Type::bytes(ref __field0) => _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "Type",
                        1u32,
                        "bytes",
                        __field0,
                    ),
                    Type::copy(ref __field0) => _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "Type",
                        2u32,
                        "copy",
                        __field0,
                    ),
                    Type::r#enum(ref __field0) => _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "Type",
                        3u32,
                        "enum",
                        __field0,
                    ),
                    Type::float(ref __field0) => _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "Type",
                        4u32,
                        "float",
                        __field0,
                    ),
                    Type::int(ref __field0) => _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "Type",
                        5u32,
                        "int",
                        __field0,
                    ),
                    Type::link(ref __field0) => _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "Type",
                        6u32,
                        "link",
                        __field0,
                    ),
                    Type::list(ref __field0) => _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "Type",
                        7u32,
                        "list",
                        __field0,
                    ),
                    Type::map(ref __field0) => _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "Type",
                        8u32,
                        "map",
                        __field0,
                    ),
                    Type::string(ref __field0) => _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "Type",
                        9u32,
                        "string",
                        __field0,
                    ),
                    Type::r#struct(ref __field0) => _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "Type",
                        10u32,
                        "struct",
                        __field0,
                    ),
                    Type::union(ref __field0) => _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "Type",
                        11u32,
                        "union",
                        __field0,
                    ),
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for Type {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                    __field6,
                    __field7,
                    __field8,
                    __field9,
                    __field10,
                    __field11,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "variant identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::export::Ok(__Field::__field0),
                            1u64 => _serde::export::Ok(__Field::__field1),
                            2u64 => _serde::export::Ok(__Field::__field2),
                            3u64 => _serde::export::Ok(__Field::__field3),
                            4u64 => _serde::export::Ok(__Field::__field4),
                            5u64 => _serde::export::Ok(__Field::__field5),
                            6u64 => _serde::export::Ok(__Field::__field6),
                            7u64 => _serde::export::Ok(__Field::__field7),
                            8u64 => _serde::export::Ok(__Field::__field8),
                            9u64 => _serde::export::Ok(__Field::__field9),
                            10u64 => _serde::export::Ok(__Field::__field10),
                            11u64 => _serde::export::Ok(__Field::__field11),
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"variant index 0 <= i < 12",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "bool" => _serde::export::Ok(__Field::__field0),
                            "bytes" => _serde::export::Ok(__Field::__field1),
                            "copy" => _serde::export::Ok(__Field::__field2),
                            "enum" => _serde::export::Ok(__Field::__field3),
                            "float" => _serde::export::Ok(__Field::__field4),
                            "int" => _serde::export::Ok(__Field::__field5),
                            "link" => _serde::export::Ok(__Field::__field6),
                            "list" => _serde::export::Ok(__Field::__field7),
                            "map" => _serde::export::Ok(__Field::__field8),
                            "string" => _serde::export::Ok(__Field::__field9),
                            "struct" => _serde::export::Ok(__Field::__field10),
                            "union" => _serde::export::Ok(__Field::__field11),
                            _ => _serde::export::Err(_serde::de::Error::unknown_variant(
                                __value, VARIANTS,
                            )),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"bool" => _serde::export::Ok(__Field::__field0),
                            b"bytes" => _serde::export::Ok(__Field::__field1),
                            b"copy" => _serde::export::Ok(__Field::__field2),
                            b"enum" => _serde::export::Ok(__Field::__field3),
                            b"float" => _serde::export::Ok(__Field::__field4),
                            b"int" => _serde::export::Ok(__Field::__field5),
                            b"link" => _serde::export::Ok(__Field::__field6),
                            b"list" => _serde::export::Ok(__Field::__field7),
                            b"map" => _serde::export::Ok(__Field::__field8),
                            b"string" => _serde::export::Ok(__Field::__field9),
                            b"struct" => _serde::export::Ok(__Field::__field10),
                            b"union" => _serde::export::Ok(__Field::__field11),
                            _ => {
                                let __value = &_serde::export::from_utf8_lossy(__value);
                                _serde::export::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                ))
                            }
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::export::PhantomData<Type>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Type;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "enum Type")
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match match _serde::de::EnumAccess::variant(__data) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            (__Field::__field0, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<TypeBool>(__variant),
                                Type::bool,
                            ),
                            (__Field::__field1, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<TypeBytes>(__variant),
                                Type::bytes,
                            ),
                            (__Field::__field2, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<TypeCopy>(__variant),
                                Type::copy,
                            ),
                            (__Field::__field3, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<TypeEnum>(__variant),
                                Type::r#enum,
                            ),
                            (__Field::__field4, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<TypeFloat>(__variant),
                                Type::float,
                            ),
                            (__Field::__field5, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<TypeInt>(__variant),
                                Type::int,
                            ),
                            (__Field::__field6, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<TypeLink>(__variant),
                                Type::link,
                            ),
                            (__Field::__field7, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<TypeList>(__variant),
                                Type::list,
                            ),
                            (__Field::__field8, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<TypeMap>(__variant),
                                Type::map,
                            ),
                            (__Field::__field9, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<TypeString>(__variant),
                                Type::string,
                            ),
                            (__Field::__field10, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<TypeStruct>(__variant),
                                Type::r#struct,
                            ),
                            (__Field::__field11, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<TypeUnion>(__variant),
                                Type::union,
                            ),
                        }
                    }
                }
                const VARIANTS: &'static [&'static str] = &[
                    "bool", "bytes", "copy", "enum", "float", "int", "link", "list", "map",
                    "string", "struct", "union",
                ];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "Type",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<Type>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    impl ::core::marker::StructuralPartialEq for Type {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for Type {
        #[inline]
        fn eq(&self, other: &Type) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&Type::bool(ref __self_0), &Type::bool(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        (&Type::bytes(ref __self_0), &Type::bytes(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        (&Type::copy(ref __self_0), &Type::copy(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        (&Type::r#enum(ref __self_0), &Type::r#enum(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        (&Type::float(ref __self_0), &Type::float(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        (&Type::int(ref __self_0), &Type::int(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        (&Type::link(ref __self_0), &Type::link(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        (&Type::list(ref __self_0), &Type::list(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        (&Type::map(ref __self_0), &Type::map(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        (&Type::string(ref __self_0), &Type::string(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        (&Type::r#struct(ref __self_0), &Type::r#struct(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        (&Type::union(ref __self_0), &Type::union(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    false
                }
            }
        }
        #[inline]
        fn ne(&self, other: &Type) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&Type::bool(ref __self_0), &Type::bool(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        (&Type::bytes(ref __self_0), &Type::bytes(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        (&Type::copy(ref __self_0), &Type::copy(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        (&Type::r#enum(ref __self_0), &Type::r#enum(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        (&Type::float(ref __self_0), &Type::float(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        (&Type::int(ref __self_0), &Type::int(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        (&Type::link(ref __self_0), &Type::link(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        (&Type::list(ref __self_0), &Type::list(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        (&Type::map(ref __self_0), &Type::map(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        (&Type::string(ref __self_0), &Type::string(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        (&Type::r#struct(ref __self_0), &Type::r#struct(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        (&Type::union(ref __self_0), &Type::union(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    true
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialOrd for Type {
        #[inline]
        fn partial_cmp(&self, other: &Type) -> ::core::option::Option<::core::cmp::Ordering> {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&Type::bool(ref __self_0), &Type::bool(ref __arg_1_0)) => {
                            match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0))
                            {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                }
                                cmp => cmp,
                            }
                        }
                        (&Type::bytes(ref __self_0), &Type::bytes(ref __arg_1_0)) => {
                            match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0))
                            {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                }
                                cmp => cmp,
                            }
                        }
                        (&Type::copy(ref __self_0), &Type::copy(ref __arg_1_0)) => {
                            match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0))
                            {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                }
                                cmp => cmp,
                            }
                        }
                        (&Type::r#enum(ref __self_0), &Type::r#enum(ref __arg_1_0)) => {
                            match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0))
                            {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                }
                                cmp => cmp,
                            }
                        }
                        (&Type::float(ref __self_0), &Type::float(ref __arg_1_0)) => {
                            match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0))
                            {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                }
                                cmp => cmp,
                            }
                        }
                        (&Type::int(ref __self_0), &Type::int(ref __arg_1_0)) => {
                            match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0))
                            {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                }
                                cmp => cmp,
                            }
                        }
                        (&Type::link(ref __self_0), &Type::link(ref __arg_1_0)) => {
                            match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0))
                            {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                }
                                cmp => cmp,
                            }
                        }
                        (&Type::list(ref __self_0), &Type::list(ref __arg_1_0)) => {
                            match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0))
                            {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                }
                                cmp => cmp,
                            }
                        }
                        (&Type::map(ref __self_0), &Type::map(ref __arg_1_0)) => {
                            match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0))
                            {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                }
                                cmp => cmp,
                            }
                        }
                        (&Type::string(ref __self_0), &Type::string(ref __arg_1_0)) => {
                            match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0))
                            {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                }
                                cmp => cmp,
                            }
                        }
                        (&Type::r#struct(ref __self_0), &Type::r#struct(ref __arg_1_0)) => {
                            match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0))
                            {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                }
                                cmp => cmp,
                            }
                        }
                        (&Type::union(ref __self_0), &Type::union(ref __arg_1_0)) => {
                            match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0))
                            {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                }
                                cmp => cmp,
                            }
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    __self_vi.partial_cmp(&__arg_1_vi)
                }
            }
        }
        #[inline]
        fn lt(&self, other: &Type) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&Type::bool(ref __self_0), &Type::bool(ref __arg_1_0)) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Greater,
                            ) == ::core::cmp::Ordering::Less
                        }
                        (&Type::bytes(ref __self_0), &Type::bytes(ref __arg_1_0)) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Greater,
                            ) == ::core::cmp::Ordering::Less
                        }
                        (&Type::copy(ref __self_0), &Type::copy(ref __arg_1_0)) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Greater,
                            ) == ::core::cmp::Ordering::Less
                        }
                        (&Type::r#enum(ref __self_0), &Type::r#enum(ref __arg_1_0)) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Greater,
                            ) == ::core::cmp::Ordering::Less
                        }
                        (&Type::float(ref __self_0), &Type::float(ref __arg_1_0)) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Greater,
                            ) == ::core::cmp::Ordering::Less
                        }
                        (&Type::int(ref __self_0), &Type::int(ref __arg_1_0)) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Greater,
                            ) == ::core::cmp::Ordering::Less
                        }
                        (&Type::link(ref __self_0), &Type::link(ref __arg_1_0)) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Greater,
                            ) == ::core::cmp::Ordering::Less
                        }
                        (&Type::list(ref __self_0), &Type::list(ref __arg_1_0)) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Greater,
                            ) == ::core::cmp::Ordering::Less
                        }
                        (&Type::map(ref __self_0), &Type::map(ref __arg_1_0)) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Greater,
                            ) == ::core::cmp::Ordering::Less
                        }
                        (&Type::string(ref __self_0), &Type::string(ref __arg_1_0)) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Greater,
                            ) == ::core::cmp::Ordering::Less
                        }
                        (&Type::r#struct(ref __self_0), &Type::r#struct(ref __arg_1_0)) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Greater,
                            ) == ::core::cmp::Ordering::Less
                        }
                        (&Type::union(ref __self_0), &Type::union(ref __arg_1_0)) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Greater,
                            ) == ::core::cmp::Ordering::Less
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    __self_vi.lt(&__arg_1_vi)
                }
            }
        }
        #[inline]
        fn le(&self, other: &Type) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&Type::bool(ref __self_0), &Type::bool(ref __arg_1_0)) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Greater,
                            ) != ::core::cmp::Ordering::Greater
                        }
                        (&Type::bytes(ref __self_0), &Type::bytes(ref __arg_1_0)) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Greater,
                            ) != ::core::cmp::Ordering::Greater
                        }
                        (&Type::copy(ref __self_0), &Type::copy(ref __arg_1_0)) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Greater,
                            ) != ::core::cmp::Ordering::Greater
                        }
                        (&Type::r#enum(ref __self_0), &Type::r#enum(ref __arg_1_0)) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Greater,
                            ) != ::core::cmp::Ordering::Greater
                        }
                        (&Type::float(ref __self_0), &Type::float(ref __arg_1_0)) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Greater,
                            ) != ::core::cmp::Ordering::Greater
                        }
                        (&Type::int(ref __self_0), &Type::int(ref __arg_1_0)) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Greater,
                            ) != ::core::cmp::Ordering::Greater
                        }
                        (&Type::link(ref __self_0), &Type::link(ref __arg_1_0)) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Greater,
                            ) != ::core::cmp::Ordering::Greater
                        }
                        (&Type::list(ref __self_0), &Type::list(ref __arg_1_0)) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Greater,
                            ) != ::core::cmp::Ordering::Greater
                        }
                        (&Type::map(ref __self_0), &Type::map(ref __arg_1_0)) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Greater,
                            ) != ::core::cmp::Ordering::Greater
                        }
                        (&Type::string(ref __self_0), &Type::string(ref __arg_1_0)) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Greater,
                            ) != ::core::cmp::Ordering::Greater
                        }
                        (&Type::r#struct(ref __self_0), &Type::r#struct(ref __arg_1_0)) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Greater,
                            ) != ::core::cmp::Ordering::Greater
                        }
                        (&Type::union(ref __self_0), &Type::union(ref __arg_1_0)) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Greater,
                            ) != ::core::cmp::Ordering::Greater
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    __self_vi.le(&__arg_1_vi)
                }
            }
        }
        #[inline]
        fn gt(&self, other: &Type) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&Type::bool(ref __self_0), &Type::bool(ref __arg_1_0)) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Less,
                            ) == ::core::cmp::Ordering::Greater
                        }
                        (&Type::bytes(ref __self_0), &Type::bytes(ref __arg_1_0)) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Less,
                            ) == ::core::cmp::Ordering::Greater
                        }
                        (&Type::copy(ref __self_0), &Type::copy(ref __arg_1_0)) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Less,
                            ) == ::core::cmp::Ordering::Greater
                        }
                        (&Type::r#enum(ref __self_0), &Type::r#enum(ref __arg_1_0)) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Less,
                            ) == ::core::cmp::Ordering::Greater
                        }
                        (&Type::float(ref __self_0), &Type::float(ref __arg_1_0)) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Less,
                            ) == ::core::cmp::Ordering::Greater
                        }
                        (&Type::int(ref __self_0), &Type::int(ref __arg_1_0)) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Less,
                            ) == ::core::cmp::Ordering::Greater
                        }
                        (&Type::link(ref __self_0), &Type::link(ref __arg_1_0)) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Less,
                            ) == ::core::cmp::Ordering::Greater
                        }
                        (&Type::list(ref __self_0), &Type::list(ref __arg_1_0)) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Less,
                            ) == ::core::cmp::Ordering::Greater
                        }
                        (&Type::map(ref __self_0), &Type::map(ref __arg_1_0)) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Less,
                            ) == ::core::cmp::Ordering::Greater
                        }
                        (&Type::string(ref __self_0), &Type::string(ref __arg_1_0)) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Less,
                            ) == ::core::cmp::Ordering::Greater
                        }
                        (&Type::r#struct(ref __self_0), &Type::r#struct(ref __arg_1_0)) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Less,
                            ) == ::core::cmp::Ordering::Greater
                        }
                        (&Type::union(ref __self_0), &Type::union(ref __arg_1_0)) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Less,
                            ) == ::core::cmp::Ordering::Greater
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    __self_vi.gt(&__arg_1_vi)
                }
            }
        }
        #[inline]
        fn ge(&self, other: &Type) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&Type::bool(ref __self_0), &Type::bool(ref __arg_1_0)) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Less,
                            ) != ::core::cmp::Ordering::Less
                        }
                        (&Type::bytes(ref __self_0), &Type::bytes(ref __arg_1_0)) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Less,
                            ) != ::core::cmp::Ordering::Less
                        }
                        (&Type::copy(ref __self_0), &Type::copy(ref __arg_1_0)) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Less,
                            ) != ::core::cmp::Ordering::Less
                        }
                        (&Type::r#enum(ref __self_0), &Type::r#enum(ref __arg_1_0)) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Less,
                            ) != ::core::cmp::Ordering::Less
                        }
                        (&Type::float(ref __self_0), &Type::float(ref __arg_1_0)) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Less,
                            ) != ::core::cmp::Ordering::Less
                        }
                        (&Type::int(ref __self_0), &Type::int(ref __arg_1_0)) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Less,
                            ) != ::core::cmp::Ordering::Less
                        }
                        (&Type::link(ref __self_0), &Type::link(ref __arg_1_0)) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Less,
                            ) != ::core::cmp::Ordering::Less
                        }
                        (&Type::list(ref __self_0), &Type::list(ref __arg_1_0)) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Less,
                            ) != ::core::cmp::Ordering::Less
                        }
                        (&Type::map(ref __self_0), &Type::map(ref __arg_1_0)) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Less,
                            ) != ::core::cmp::Ordering::Less
                        }
                        (&Type::string(ref __self_0), &Type::string(ref __arg_1_0)) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Less,
                            ) != ::core::cmp::Ordering::Less
                        }
                        (&Type::r#struct(ref __self_0), &Type::r#struct(ref __arg_1_0)) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Less,
                            ) != ::core::cmp::Ordering::Less
                        }
                        (&Type::union(ref __self_0), &Type::union(ref __arg_1_0)) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Less,
                            ) != ::core::cmp::Ordering::Less
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    __self_vi.ge(&__arg_1_vi)
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for Type {
        #[inline]
        fn clone(&self) -> Type {
            match (&*self,) {
                (&Type::bool(ref __self_0),) => {
                    Type::bool(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&Type::bytes(ref __self_0),) => {
                    Type::bytes(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&Type::copy(ref __self_0),) => {
                    Type::copy(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&Type::r#enum(ref __self_0),) => {
                    Type::r#enum(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&Type::float(ref __self_0),) => {
                    Type::float(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&Type::int(ref __self_0),) => Type::int(::core::clone::Clone::clone(&(*__self_0))),
                (&Type::link(ref __self_0),) => {
                    Type::link(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&Type::list(ref __self_0),) => {
                    Type::list(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&Type::map(ref __self_0),) => Type::map(::core::clone::Clone::clone(&(*__self_0))),
                (&Type::string(ref __self_0),) => {
                    Type::string(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&Type::r#struct(ref __self_0),) => {
                    Type::r#struct(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&Type::union(ref __self_0),) => {
                    Type::union(::core::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for Type {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&Type::bool(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("bool");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&Type::bytes(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("bytes");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&Type::copy(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("copy");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&Type::r#enum(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("enum");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&Type::float(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("float");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&Type::int(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("int");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&Type::link(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("link");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&Type::list(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("list");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&Type::map(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("map");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&Type::string(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("string");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&Type::r#struct(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("struct");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&Type::union(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("union");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    impl proptest::arbitrary::Arbitrary for Type {
        type Parameters = ();
        type Strategy = proptest::strategy::BoxedStrategy<Self>;
        fn arbitrary_with(args: Self::Parameters) -> Self::Strategy {
            #[allow(dead_code)]
            fn _to_fn_ptr<T>(f: fn(&T) -> bool) -> fn(&T) -> bool {
                f
            }
            let args = std::rc::Rc::new(args);
            proptest::strategy::Strategy::boxed({
                #[allow(dead_code)]
                fn _to_weight(weight: u32) -> u32 {
                    weight
                }
                let _s = ::proptest::strategy::Union::new_weighted(<[_]>::into_vec(box [
                    (
                        1,
                        ::proptest::strategy::Strategy::boxed({
                            let strategy_0 = ({
                                #[allow(dead_code)]
                                fn _strategy_of_0<
                                    T: std::fmt::Debug,
                                    S: proptest::strategy::Strategy<Value = T>,
                                >(
                                    s: S,
                                ) -> impl proptest::strategy::Strategy<Value = T>
                                {
                                    s
                                }
                                let _s = proptest::arbitrary::any::<TypeBool>();
                                _s
                            },);
                            let strategy_0 =
                                proptest::strategy::Strategy::prop_map(strategy_0, |_values| {
                                    Self::bool(_values.0)
                                });
                            strategy_0
                        }),
                    ),
                    (
                        1,
                        ::proptest::strategy::Strategy::boxed({
                            let strategy_0 = ({
                                #[allow(dead_code)]
                                fn _strategy_of_0<
                                    T: std::fmt::Debug,
                                    S: proptest::strategy::Strategy<Value = T>,
                                >(
                                    s: S,
                                ) -> impl proptest::strategy::Strategy<Value = T>
                                {
                                    s
                                }
                                let _s = proptest::arbitrary::any::<TypeBytes>();
                                _s
                            },);
                            let strategy_0 =
                                proptest::strategy::Strategy::prop_map(strategy_0, |_values| {
                                    Self::bytes(_values.0)
                                });
                            strategy_0
                        }),
                    ),
                    (
                        1,
                        ::proptest::strategy::Strategy::boxed({
                            let strategy_0 = ({
                                #[allow(dead_code)]
                                fn _strategy_of_0<
                                    T: std::fmt::Debug,
                                    S: proptest::strategy::Strategy<Value = T>,
                                >(
                                    s: S,
                                ) -> impl proptest::strategy::Strategy<Value = T>
                                {
                                    s
                                }
                                let _s = proptest::arbitrary::any::<TypeCopy>();
                                _s
                            },);
                            let strategy_0 =
                                proptest::strategy::Strategy::prop_map(strategy_0, |_values| {
                                    Self::copy(_values.0)
                                });
                            strategy_0
                        }),
                    ),
                    (
                        1,
                        ::proptest::strategy::Strategy::boxed({
                            let strategy_0 = ({
                                #[allow(dead_code)]
                                fn _strategy_of_0<
                                    T: std::fmt::Debug,
                                    S: proptest::strategy::Strategy<Value = T>,
                                >(
                                    s: S,
                                ) -> impl proptest::strategy::Strategy<Value = T>
                                {
                                    s
                                }
                                let _s = proptest::arbitrary::any::<TypeEnum>();
                                _s
                            },);
                            let strategy_0 =
                                proptest::strategy::Strategy::prop_map(strategy_0, |_values| {
                                    Self::r#enum(_values.0)
                                });
                            strategy_0
                        }),
                    ),
                    (
                        1,
                        ::proptest::strategy::Strategy::boxed({
                            let strategy_0 = ({
                                #[allow(dead_code)]
                                fn _strategy_of_0<
                                    T: std::fmt::Debug,
                                    S: proptest::strategy::Strategy<Value = T>,
                                >(
                                    s: S,
                                ) -> impl proptest::strategy::Strategy<Value = T>
                                {
                                    s
                                }
                                let _s = proptest::arbitrary::any::<TypeFloat>();
                                _s
                            },);
                            let strategy_0 =
                                proptest::strategy::Strategy::prop_map(strategy_0, |_values| {
                                    Self::float(_values.0)
                                });
                            strategy_0
                        }),
                    ),
                    (
                        1,
                        ::proptest::strategy::Strategy::boxed({
                            let strategy_0 = ({
                                #[allow(dead_code)]
                                fn _strategy_of_0<
                                    T: std::fmt::Debug,
                                    S: proptest::strategy::Strategy<Value = T>,
                                >(
                                    s: S,
                                ) -> impl proptest::strategy::Strategy<Value = T>
                                {
                                    s
                                }
                                let _s = proptest::arbitrary::any::<TypeInt>();
                                _s
                            },);
                            let strategy_0 =
                                proptest::strategy::Strategy::prop_map(strategy_0, |_values| {
                                    Self::int(_values.0)
                                });
                            strategy_0
                        }),
                    ),
                    (
                        1,
                        ::proptest::strategy::Strategy::boxed({
                            let strategy_0 = ({
                                #[allow(dead_code)]
                                fn _strategy_of_0<
                                    T: std::fmt::Debug,
                                    S: proptest::strategy::Strategy<Value = T>,
                                >(
                                    s: S,
                                ) -> impl proptest::strategy::Strategy<Value = T>
                                {
                                    s
                                }
                                let _s = proptest::arbitrary::any::<TypeLink>();
                                _s
                            },);
                            let strategy_0 =
                                proptest::strategy::Strategy::prop_map(strategy_0, |_values| {
                                    Self::link(_values.0)
                                });
                            strategy_0
                        }),
                    ),
                    (
                        1,
                        ::proptest::strategy::Strategy::boxed({
                            let strategy_0 = ({
                                #[allow(dead_code)]
                                fn _strategy_of_0<
                                    T: std::fmt::Debug,
                                    S: proptest::strategy::Strategy<Value = T>,
                                >(
                                    s: S,
                                ) -> impl proptest::strategy::Strategy<Value = T>
                                {
                                    s
                                }
                                let _s = proptest::arbitrary::any::<TypeList>();
                                _s
                            },);
                            let strategy_0 =
                                proptest::strategy::Strategy::prop_map(strategy_0, |_values| {
                                    Self::list(_values.0)
                                });
                            strategy_0
                        }),
                    ),
                    (
                        1,
                        ::proptest::strategy::Strategy::boxed({
                            let strategy_0 = ({
                                #[allow(dead_code)]
                                fn _strategy_of_0<
                                    T: std::fmt::Debug,
                                    S: proptest::strategy::Strategy<Value = T>,
                                >(
                                    s: S,
                                ) -> impl proptest::strategy::Strategy<Value = T>
                                {
                                    s
                                }
                                let _s = proptest::arbitrary::any::<TypeMap>();
                                _s
                            },);
                            let strategy_0 =
                                proptest::strategy::Strategy::prop_map(strategy_0, |_values| {
                                    Self::map(_values.0)
                                });
                            strategy_0
                        }),
                    ),
                    (
                        1,
                        ::proptest::strategy::Strategy::boxed({
                            let strategy_0 = ({
                                #[allow(dead_code)]
                                fn _strategy_of_0<
                                    T: std::fmt::Debug,
                                    S: proptest::strategy::Strategy<Value = T>,
                                >(
                                    s: S,
                                ) -> impl proptest::strategy::Strategy<Value = T>
                                {
                                    s
                                }
                                let _s = proptest::arbitrary::any::<TypeString>();
                                _s
                            },);
                            let strategy_0 =
                                proptest::strategy::Strategy::prop_map(strategy_0, |_values| {
                                    Self::string(_values.0)
                                });
                            strategy_0
                        }),
                    ),
                    (
                        1,
                        ::proptest::strategy::Strategy::boxed({
                            let strategy_0 = ({
                                #[allow(dead_code)]
                                fn _strategy_of_0<
                                    T: std::fmt::Debug,
                                    S: proptest::strategy::Strategy<Value = T>,
                                >(
                                    s: S,
                                ) -> impl proptest::strategy::Strategy<Value = T>
                                {
                                    s
                                }
                                let _s = proptest::arbitrary::any::<TypeStruct>();
                                _s
                            },);
                            let strategy_0 =
                                proptest::strategy::Strategy::prop_map(strategy_0, |_values| {
                                    Self::r#struct(_values.0)
                                });
                            strategy_0
                        }),
                    ),
                    (
                        1,
                        ::proptest::strategy::Strategy::boxed({
                            let strategy_0 = ({
                                #[allow(dead_code)]
                                fn _strategy_of_0<
                                    T: std::fmt::Debug,
                                    S: proptest::strategy::Strategy<Value = T>,
                                >(
                                    s: S,
                                ) -> impl proptest::strategy::Strategy<Value = T>
                                {
                                    s
                                }
                                let _s = proptest::arbitrary::any::<TypeUnion>();
                                _s
                            },);
                            let strategy_0 =
                                proptest::strategy::Strategy::prop_map(strategy_0, |_values| {
                                    Self::union(_values.0)
                                });
                            strategy_0
                        }),
                    ),
                ]));
                _s
            })
        }
    }
    struct TypeBool {}
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for TypeBool {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "TypeBool",
                    false as usize,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for TypeBool {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"field index 0 <= i < 0",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::export::PhantomData<TypeBool>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = TypeBool;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "struct TypeBool")
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        _: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        _serde::export::Ok(TypeBool {})
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        while let _serde::export::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            }
                        {
                            match __key {
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        _serde::export::Ok(TypeBool {})
                    }
                }
                const FIELDS: &'static [&'static str] = &[];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "TypeBool",
                    FIELDS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<TypeBool>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    impl ::core::marker::StructuralPartialEq for TypeBool {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for TypeBool {
        #[inline]
        fn eq(&self, other: &TypeBool) -> bool {
            match *other {
                TypeBool {} => match *self {
                    TypeBool {} => true,
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialOrd for TypeBool {
        #[inline]
        fn partial_cmp(&self, other: &TypeBool) -> ::core::option::Option<::core::cmp::Ordering> {
            match *other {
                TypeBool {} => match *self {
                    TypeBool {} => ::core::option::Option::Some(::core::cmp::Ordering::Equal),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for TypeBool {
        #[inline]
        fn clone(&self) -> TypeBool {
            match *self {
                TypeBool {} => TypeBool {},
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for TypeBool {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                TypeBool {} => {
                    let mut debug_trait_builder = f.debug_struct("TypeBool");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    impl proptest::arbitrary::Arbitrary for TypeBool {
        type Parameters = ();
        type Strategy = proptest::strategy::BoxedStrategy<Self>;
        fn arbitrary_with(args: Self::Parameters) -> Self::Strategy {
            #[allow(dead_code)]
            fn _to_fn_ptr<T>(f: fn(&T) -> bool) -> fn(&T) -> bool {
                f
            }
            let args = std::rc::Rc::new(args);
            proptest::strategy::Strategy::boxed(proptest::strategy::LazyJust::new(|| Self {}))
        }
    }
    struct TypeBytes {}
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for TypeBytes {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "TypeBytes",
                    false as usize,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for TypeBytes {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"field index 0 <= i < 0",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::export::PhantomData<TypeBytes>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = TypeBytes;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "struct TypeBytes")
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        _: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        _serde::export::Ok(TypeBytes {})
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        while let _serde::export::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            }
                        {
                            match __key {
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        _serde::export::Ok(TypeBytes {})
                    }
                }
                const FIELDS: &'static [&'static str] = &[];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "TypeBytes",
                    FIELDS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<TypeBytes>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    impl ::core::marker::StructuralPartialEq for TypeBytes {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for TypeBytes {
        #[inline]
        fn eq(&self, other: &TypeBytes) -> bool {
            match *other {
                TypeBytes {} => match *self {
                    TypeBytes {} => true,
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialOrd for TypeBytes {
        #[inline]
        fn partial_cmp(&self, other: &TypeBytes) -> ::core::option::Option<::core::cmp::Ordering> {
            match *other {
                TypeBytes {} => match *self {
                    TypeBytes {} => ::core::option::Option::Some(::core::cmp::Ordering::Equal),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for TypeBytes {
        #[inline]
        fn clone(&self) -> TypeBytes {
            match *self {
                TypeBytes {} => TypeBytes {},
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for TypeBytes {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                TypeBytes {} => {
                    let mut debug_trait_builder = f.debug_struct("TypeBytes");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    impl proptest::arbitrary::Arbitrary for TypeBytes {
        type Parameters = ();
        type Strategy = proptest::strategy::BoxedStrategy<Self>;
        fn arbitrary_with(args: Self::Parameters) -> Self::Strategy {
            #[allow(dead_code)]
            fn _to_fn_ptr<T>(f: fn(&T) -> bool) -> fn(&T) -> bool {
                f
            }
            let args = std::rc::Rc::new(args);
            proptest::strategy::Strategy::boxed(proptest::strategy::LazyJust::new(|| Self {}))
        }
    }
    struct TypeCopy {}
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for TypeCopy {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "TypeCopy",
                    false as usize,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for TypeCopy {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"field index 0 <= i < 0",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::export::PhantomData<TypeCopy>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = TypeCopy;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "struct TypeCopy")
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        _: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        _serde::export::Ok(TypeCopy {})
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        while let _serde::export::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            }
                        {
                            match __key {
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        _serde::export::Ok(TypeCopy {})
                    }
                }
                const FIELDS: &'static [&'static str] = &[];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "TypeCopy",
                    FIELDS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<TypeCopy>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    impl ::core::marker::StructuralPartialEq for TypeCopy {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for TypeCopy {
        #[inline]
        fn eq(&self, other: &TypeCopy) -> bool {
            match *other {
                TypeCopy {} => match *self {
                    TypeCopy {} => true,
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialOrd for TypeCopy {
        #[inline]
        fn partial_cmp(&self, other: &TypeCopy) -> ::core::option::Option<::core::cmp::Ordering> {
            match *other {
                TypeCopy {} => match *self {
                    TypeCopy {} => ::core::option::Option::Some(::core::cmp::Ordering::Equal),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for TypeCopy {
        #[inline]
        fn clone(&self) -> TypeCopy {
            match *self {
                TypeCopy {} => TypeCopy {},
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for TypeCopy {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                TypeCopy {} => {
                    let mut debug_trait_builder = f.debug_struct("TypeCopy");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    impl proptest::arbitrary::Arbitrary for TypeCopy {
        type Parameters = ();
        type Strategy = proptest::strategy::BoxedStrategy<Self>;
        fn arbitrary_with(args: Self::Parameters) -> Self::Strategy {
            #[allow(dead_code)]
            fn _to_fn_ptr<T>(f: fn(&T) -> bool) -> fn(&T) -> bool {
                f
            }
            let args = std::rc::Rc::new(args);
            proptest::strategy::Strategy::boxed(proptest::strategy::LazyJust::new(|| Self {}))
        }
    }
    struct TypeEnum {}
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for TypeEnum {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "TypeEnum",
                    false as usize,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for TypeEnum {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"field index 0 <= i < 0",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::export::PhantomData<TypeEnum>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = TypeEnum;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "struct TypeEnum")
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        _: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        _serde::export::Ok(TypeEnum {})
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        while let _serde::export::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            }
                        {
                            match __key {
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        _serde::export::Ok(TypeEnum {})
                    }
                }
                const FIELDS: &'static [&'static str] = &[];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "TypeEnum",
                    FIELDS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<TypeEnum>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    impl ::core::marker::StructuralPartialEq for TypeEnum {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for TypeEnum {
        #[inline]
        fn eq(&self, other: &TypeEnum) -> bool {
            match *other {
                TypeEnum {} => match *self {
                    TypeEnum {} => true,
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialOrd for TypeEnum {
        #[inline]
        fn partial_cmp(&self, other: &TypeEnum) -> ::core::option::Option<::core::cmp::Ordering> {
            match *other {
                TypeEnum {} => match *self {
                    TypeEnum {} => ::core::option::Option::Some(::core::cmp::Ordering::Equal),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for TypeEnum {
        #[inline]
        fn clone(&self) -> TypeEnum {
            match *self {
                TypeEnum {} => TypeEnum {},
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for TypeEnum {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                TypeEnum {} => {
                    let mut debug_trait_builder = f.debug_struct("TypeEnum");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    impl proptest::arbitrary::Arbitrary for TypeEnum {
        type Parameters = ();
        type Strategy = proptest::strategy::BoxedStrategy<Self>;
        fn arbitrary_with(args: Self::Parameters) -> Self::Strategy {
            #[allow(dead_code)]
            fn _to_fn_ptr<T>(f: fn(&T) -> bool) -> fn(&T) -> bool {
                f
            }
            let args = std::rc::Rc::new(args);
            proptest::strategy::Strategy::boxed(proptest::strategy::LazyJust::new(|| Self {}))
        }
    }
    struct TypeFloat {}
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for TypeFloat {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "TypeFloat",
                    false as usize,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for TypeFloat {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"field index 0 <= i < 0",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::export::PhantomData<TypeFloat>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = TypeFloat;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "struct TypeFloat")
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        _: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        _serde::export::Ok(TypeFloat {})
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        while let _serde::export::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            }
                        {
                            match __key {
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        _serde::export::Ok(TypeFloat {})
                    }
                }
                const FIELDS: &'static [&'static str] = &[];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "TypeFloat",
                    FIELDS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<TypeFloat>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    impl ::core::marker::StructuralPartialEq for TypeFloat {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for TypeFloat {
        #[inline]
        fn eq(&self, other: &TypeFloat) -> bool {
            match *other {
                TypeFloat {} => match *self {
                    TypeFloat {} => true,
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialOrd for TypeFloat {
        #[inline]
        fn partial_cmp(&self, other: &TypeFloat) -> ::core::option::Option<::core::cmp::Ordering> {
            match *other {
                TypeFloat {} => match *self {
                    TypeFloat {} => ::core::option::Option::Some(::core::cmp::Ordering::Equal),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for TypeFloat {
        #[inline]
        fn clone(&self) -> TypeFloat {
            match *self {
                TypeFloat {} => TypeFloat {},
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for TypeFloat {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                TypeFloat {} => {
                    let mut debug_trait_builder = f.debug_struct("TypeFloat");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    impl proptest::arbitrary::Arbitrary for TypeFloat {
        type Parameters = ();
        type Strategy = proptest::strategy::BoxedStrategy<Self>;
        fn arbitrary_with(args: Self::Parameters) -> Self::Strategy {
            #[allow(dead_code)]
            fn _to_fn_ptr<T>(f: fn(&T) -> bool) -> fn(&T) -> bool {
                f
            }
            let args = std::rc::Rc::new(args);
            proptest::strategy::Strategy::boxed(proptest::strategy::LazyJust::new(|| Self {}))
        }
    }
    struct TypeInt {}
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for TypeInt {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "TypeInt",
                    false as usize,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for TypeInt {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"field index 0 <= i < 0",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::export::PhantomData<TypeInt>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = TypeInt;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "struct TypeInt")
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        _: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        _serde::export::Ok(TypeInt {})
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        while let _serde::export::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            }
                        {
                            match __key {
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        _serde::export::Ok(TypeInt {})
                    }
                }
                const FIELDS: &'static [&'static str] = &[];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "TypeInt",
                    FIELDS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<TypeInt>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    impl ::core::marker::StructuralPartialEq for TypeInt {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for TypeInt {
        #[inline]
        fn eq(&self, other: &TypeInt) -> bool {
            match *other {
                TypeInt {} => match *self {
                    TypeInt {} => true,
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialOrd for TypeInt {
        #[inline]
        fn partial_cmp(&self, other: &TypeInt) -> ::core::option::Option<::core::cmp::Ordering> {
            match *other {
                TypeInt {} => match *self {
                    TypeInt {} => ::core::option::Option::Some(::core::cmp::Ordering::Equal),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for TypeInt {
        #[inline]
        fn clone(&self) -> TypeInt {
            match *self {
                TypeInt {} => TypeInt {},
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for TypeInt {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                TypeInt {} => {
                    let mut debug_trait_builder = f.debug_struct("TypeInt");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    impl proptest::arbitrary::Arbitrary for TypeInt {
        type Parameters = ();
        type Strategy = proptest::strategy::BoxedStrategy<Self>;
        fn arbitrary_with(args: Self::Parameters) -> Self::Strategy {
            #[allow(dead_code)]
            fn _to_fn_ptr<T>(f: fn(&T) -> bool) -> fn(&T) -> bool {
                f
            }
            let args = std::rc::Rc::new(args);
            proptest::strategy::Strategy::boxed(proptest::strategy::LazyJust::new(|| Self {}))
        }
    }
    enum TypeKind {
        Bool,
        Bytes,
        Enum,
        Float,
        Int,
        Link,
        List,
        Map,
        String,
        Struct,
        Union,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for TypeKind {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    TypeKind::Bool => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "TypeKind",
                        0u32,
                        "Bool",
                    ),
                    TypeKind::Bytes => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "TypeKind",
                        1u32,
                        "Bytes",
                    ),
                    TypeKind::Enum => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "TypeKind",
                        2u32,
                        "Enum",
                    ),
                    TypeKind::Float => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "TypeKind",
                        3u32,
                        "Float",
                    ),
                    TypeKind::Int => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "TypeKind",
                        4u32,
                        "Int",
                    ),
                    TypeKind::Link => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "TypeKind",
                        5u32,
                        "Link",
                    ),
                    TypeKind::List => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "TypeKind",
                        6u32,
                        "List",
                    ),
                    TypeKind::Map => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "TypeKind",
                        7u32,
                        "Map",
                    ),
                    TypeKind::String => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "TypeKind",
                        8u32,
                        "String",
                    ),
                    TypeKind::Struct => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "TypeKind",
                        9u32,
                        "Struct",
                    ),
                    TypeKind::Union => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "TypeKind",
                        10u32,
                        "Union",
                    ),
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for TypeKind {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                    __field6,
                    __field7,
                    __field8,
                    __field9,
                    __field10,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "variant identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::export::Ok(__Field::__field0),
                            1u64 => _serde::export::Ok(__Field::__field1),
                            2u64 => _serde::export::Ok(__Field::__field2),
                            3u64 => _serde::export::Ok(__Field::__field3),
                            4u64 => _serde::export::Ok(__Field::__field4),
                            5u64 => _serde::export::Ok(__Field::__field5),
                            6u64 => _serde::export::Ok(__Field::__field6),
                            7u64 => _serde::export::Ok(__Field::__field7),
                            8u64 => _serde::export::Ok(__Field::__field8),
                            9u64 => _serde::export::Ok(__Field::__field9),
                            10u64 => _serde::export::Ok(__Field::__field10),
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"variant index 0 <= i < 11",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "Bool" => _serde::export::Ok(__Field::__field0),
                            "Bytes" => _serde::export::Ok(__Field::__field1),
                            "Enum" => _serde::export::Ok(__Field::__field2),
                            "Float" => _serde::export::Ok(__Field::__field3),
                            "Int" => _serde::export::Ok(__Field::__field4),
                            "Link" => _serde::export::Ok(__Field::__field5),
                            "List" => _serde::export::Ok(__Field::__field6),
                            "Map" => _serde::export::Ok(__Field::__field7),
                            "String" => _serde::export::Ok(__Field::__field8),
                            "Struct" => _serde::export::Ok(__Field::__field9),
                            "Union" => _serde::export::Ok(__Field::__field10),
                            _ => _serde::export::Err(_serde::de::Error::unknown_variant(
                                __value, VARIANTS,
                            )),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"Bool" => _serde::export::Ok(__Field::__field0),
                            b"Bytes" => _serde::export::Ok(__Field::__field1),
                            b"Enum" => _serde::export::Ok(__Field::__field2),
                            b"Float" => _serde::export::Ok(__Field::__field3),
                            b"Int" => _serde::export::Ok(__Field::__field4),
                            b"Link" => _serde::export::Ok(__Field::__field5),
                            b"List" => _serde::export::Ok(__Field::__field6),
                            b"Map" => _serde::export::Ok(__Field::__field7),
                            b"String" => _serde::export::Ok(__Field::__field8),
                            b"Struct" => _serde::export::Ok(__Field::__field9),
                            b"Union" => _serde::export::Ok(__Field::__field10),
                            _ => {
                                let __value = &_serde::export::from_utf8_lossy(__value);
                                _serde::export::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                ))
                            }
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::export::PhantomData<TypeKind>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = TypeKind;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "enum TypeKind")
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match match _serde::de::EnumAccess::variant(__data) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            (__Field::__field0, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(TypeKind::Bool)
                            }
                            (__Field::__field1, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(TypeKind::Bytes)
                            }
                            (__Field::__field2, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(TypeKind::Enum)
                            }
                            (__Field::__field3, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(TypeKind::Float)
                            }
                            (__Field::__field4, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(TypeKind::Int)
                            }
                            (__Field::__field5, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(TypeKind::Link)
                            }
                            (__Field::__field6, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(TypeKind::List)
                            }
                            (__Field::__field7, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(TypeKind::Map)
                            }
                            (__Field::__field8, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(TypeKind::String)
                            }
                            (__Field::__field9, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(TypeKind::Struct)
                            }
                            (__Field::__field10, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(TypeKind::Union)
                            }
                        }
                    }
                }
                const VARIANTS: &'static [&'static str] = &[
                    "Bool", "Bytes", "Enum", "Float", "Int", "Link", "List", "Map", "String",
                    "Struct", "Union",
                ];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "TypeKind",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<TypeKind>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    impl ::core::marker::StructuralPartialEq for TypeKind {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for TypeKind {
        #[inline]
        fn eq(&self, other: &TypeKind) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        _ => true,
                    }
                } else {
                    false
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialOrd for TypeKind {
        #[inline]
        fn partial_cmp(&self, other: &TypeKind) -> ::core::option::Option<::core::cmp::Ordering> {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        _ => ::core::option::Option::Some(::core::cmp::Ordering::Equal),
                    }
                } else {
                    __self_vi.partial_cmp(&__arg_1_vi)
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for TypeKind {
        #[inline]
        fn clone(&self) -> TypeKind {
            match (&*self,) {
                (&TypeKind::Bool,) => TypeKind::Bool,
                (&TypeKind::Bytes,) => TypeKind::Bytes,
                (&TypeKind::Enum,) => TypeKind::Enum,
                (&TypeKind::Float,) => TypeKind::Float,
                (&TypeKind::Int,) => TypeKind::Int,
                (&TypeKind::Link,) => TypeKind::Link,
                (&TypeKind::List,) => TypeKind::List,
                (&TypeKind::Map,) => TypeKind::Map,
                (&TypeKind::String,) => TypeKind::String,
                (&TypeKind::Struct,) => TypeKind::Struct,
                (&TypeKind::Union,) => TypeKind::Union,
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for TypeKind {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&TypeKind::Bool,) => {
                    let mut debug_trait_builder = f.debug_tuple("Bool");
                    debug_trait_builder.finish()
                }
                (&TypeKind::Bytes,) => {
                    let mut debug_trait_builder = f.debug_tuple("Bytes");
                    debug_trait_builder.finish()
                }
                (&TypeKind::Enum,) => {
                    let mut debug_trait_builder = f.debug_tuple("Enum");
                    debug_trait_builder.finish()
                }
                (&TypeKind::Float,) => {
                    let mut debug_trait_builder = f.debug_tuple("Float");
                    debug_trait_builder.finish()
                }
                (&TypeKind::Int,) => {
                    let mut debug_trait_builder = f.debug_tuple("Int");
                    debug_trait_builder.finish()
                }
                (&TypeKind::Link,) => {
                    let mut debug_trait_builder = f.debug_tuple("Link");
                    debug_trait_builder.finish()
                }
                (&TypeKind::List,) => {
                    let mut debug_trait_builder = f.debug_tuple("List");
                    debug_trait_builder.finish()
                }
                (&TypeKind::Map,) => {
                    let mut debug_trait_builder = f.debug_tuple("Map");
                    debug_trait_builder.finish()
                }
                (&TypeKind::String,) => {
                    let mut debug_trait_builder = f.debug_tuple("String");
                    debug_trait_builder.finish()
                }
                (&TypeKind::Struct,) => {
                    let mut debug_trait_builder = f.debug_tuple("Struct");
                    debug_trait_builder.finish()
                }
                (&TypeKind::Union,) => {
                    let mut debug_trait_builder = f.debug_tuple("Union");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    impl proptest::arbitrary::Arbitrary for TypeKind {
        type Parameters = ();
        type Strategy = proptest::strategy::BoxedStrategy<Self>;
        fn arbitrary_with(args: Self::Parameters) -> Self::Strategy {
            #[allow(dead_code)]
            fn _to_fn_ptr<T>(f: fn(&T) -> bool) -> fn(&T) -> bool {
                f
            }
            let args = std::rc::Rc::new(args);
            proptest::strategy::Strategy::boxed({
                #[allow(dead_code)]
                fn _to_weight(weight: u32) -> u32 {
                    weight
                }
                let _s = ::proptest::strategy::Union::new_weighted(<[_]>::into_vec(box [
                    (
                        1,
                        ::proptest::strategy::Strategy::boxed(proptest::strategy::LazyJust::new(
                            || Self::Bool,
                        )),
                    ),
                    (
                        1,
                        ::proptest::strategy::Strategy::boxed(proptest::strategy::LazyJust::new(
                            || Self::Bytes,
                        )),
                    ),
                    (
                        1,
                        ::proptest::strategy::Strategy::boxed(proptest::strategy::LazyJust::new(
                            || Self::Enum,
                        )),
                    ),
                    (
                        1,
                        ::proptest::strategy::Strategy::boxed(proptest::strategy::LazyJust::new(
                            || Self::Float,
                        )),
                    ),
                    (
                        1,
                        ::proptest::strategy::Strategy::boxed(proptest::strategy::LazyJust::new(
                            || Self::Int,
                        )),
                    ),
                    (
                        1,
                        ::proptest::strategy::Strategy::boxed(proptest::strategy::LazyJust::new(
                            || Self::Link,
                        )),
                    ),
                    (
                        1,
                        ::proptest::strategy::Strategy::boxed(proptest::strategy::LazyJust::new(
                            || Self::List,
                        )),
                    ),
                    (
                        1,
                        ::proptest::strategy::Strategy::boxed(proptest::strategy::LazyJust::new(
                            || Self::Map,
                        )),
                    ),
                    (
                        1,
                        ::proptest::strategy::Strategy::boxed(proptest::strategy::LazyJust::new(
                            || Self::String,
                        )),
                    ),
                    (
                        1,
                        ::proptest::strategy::Strategy::boxed(proptest::strategy::LazyJust::new(
                            || Self::Struct,
                        )),
                    ),
                    (
                        1,
                        ::proptest::strategy::Strategy::boxed(proptest::strategy::LazyJust::new(
                            || Self::Union,
                        )),
                    ),
                ]));
                _s
            })
        }
    }
    impl ::core::marker::StructuralEq for TypeKind {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::Eq for TypeKind {
        #[inline]
        #[doc(hidden)]
        fn assert_receiver_is_total_eq(&self) -> () {
            {}
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::Ord for TypeKind {
        #[inline]
        fn cmp(&self, other: &TypeKind) -> ::core::cmp::Ordering {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        _ => ::core::cmp::Ordering::Equal,
                    }
                } else {
                    __self_vi.cmp(&__arg_1_vi)
                }
            }
        }
    }
    struct TypeLink {}
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for TypeLink {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "TypeLink",
                    false as usize,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for TypeLink {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"field index 0 <= i < 0",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::export::PhantomData<TypeLink>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = TypeLink;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "struct TypeLink")
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        _: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        _serde::export::Ok(TypeLink {})
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        while let _serde::export::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            }
                        {
                            match __key {
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        _serde::export::Ok(TypeLink {})
                    }
                }
                const FIELDS: &'static [&'static str] = &[];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "TypeLink",
                    FIELDS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<TypeLink>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    impl ::core::marker::StructuralPartialEq for TypeLink {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for TypeLink {
        #[inline]
        fn eq(&self, other: &TypeLink) -> bool {
            match *other {
                TypeLink {} => match *self {
                    TypeLink {} => true,
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialOrd for TypeLink {
        #[inline]
        fn partial_cmp(&self, other: &TypeLink) -> ::core::option::Option<::core::cmp::Ordering> {
            match *other {
                TypeLink {} => match *self {
                    TypeLink {} => ::core::option::Option::Some(::core::cmp::Ordering::Equal),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for TypeLink {
        #[inline]
        fn clone(&self) -> TypeLink {
            match *self {
                TypeLink {} => TypeLink {},
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for TypeLink {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                TypeLink {} => {
                    let mut debug_trait_builder = f.debug_struct("TypeLink");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    impl proptest::arbitrary::Arbitrary for TypeLink {
        type Parameters = ();
        type Strategy = proptest::strategy::BoxedStrategy<Self>;
        fn arbitrary_with(args: Self::Parameters) -> Self::Strategy {
            #[allow(dead_code)]
            fn _to_fn_ptr<T>(f: fn(&T) -> bool) -> fn(&T) -> bool {
                f
            }
            let args = std::rc::Rc::new(args);
            proptest::strategy::Strategy::boxed(proptest::strategy::LazyJust::new(|| Self {}))
        }
    }
    struct TypeList {}
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for TypeList {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "TypeList",
                    false as usize,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for TypeList {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"field index 0 <= i < 0",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::export::PhantomData<TypeList>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = TypeList;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "struct TypeList")
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        _: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        _serde::export::Ok(TypeList {})
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        while let _serde::export::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            }
                        {
                            match __key {
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        _serde::export::Ok(TypeList {})
                    }
                }
                const FIELDS: &'static [&'static str] = &[];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "TypeList",
                    FIELDS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<TypeList>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    impl ::core::marker::StructuralPartialEq for TypeList {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for TypeList {
        #[inline]
        fn eq(&self, other: &TypeList) -> bool {
            match *other {
                TypeList {} => match *self {
                    TypeList {} => true,
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialOrd for TypeList {
        #[inline]
        fn partial_cmp(&self, other: &TypeList) -> ::core::option::Option<::core::cmp::Ordering> {
            match *other {
                TypeList {} => match *self {
                    TypeList {} => ::core::option::Option::Some(::core::cmp::Ordering::Equal),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for TypeList {
        #[inline]
        fn clone(&self) -> TypeList {
            match *self {
                TypeList {} => TypeList {},
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for TypeList {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                TypeList {} => {
                    let mut debug_trait_builder = f.debug_struct("TypeList");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    impl proptest::arbitrary::Arbitrary for TypeList {
        type Parameters = ();
        type Strategy = proptest::strategy::BoxedStrategy<Self>;
        fn arbitrary_with(args: Self::Parameters) -> Self::Strategy {
            #[allow(dead_code)]
            fn _to_fn_ptr<T>(f: fn(&T) -> bool) -> fn(&T) -> bool {
                f
            }
            let args = std::rc::Rc::new(args);
            proptest::strategy::Strategy::boxed(proptest::strategy::LazyJust::new(|| Self {}))
        }
    }
    struct TypeMap {}
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for TypeMap {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "TypeMap",
                    false as usize,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for TypeMap {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"field index 0 <= i < 0",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::export::PhantomData<TypeMap>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = TypeMap;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "struct TypeMap")
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        _: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        _serde::export::Ok(TypeMap {})
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        while let _serde::export::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            }
                        {
                            match __key {
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        _serde::export::Ok(TypeMap {})
                    }
                }
                const FIELDS: &'static [&'static str] = &[];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "TypeMap",
                    FIELDS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<TypeMap>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    impl ::core::marker::StructuralPartialEq for TypeMap {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for TypeMap {
        #[inline]
        fn eq(&self, other: &TypeMap) -> bool {
            match *other {
                TypeMap {} => match *self {
                    TypeMap {} => true,
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialOrd for TypeMap {
        #[inline]
        fn partial_cmp(&self, other: &TypeMap) -> ::core::option::Option<::core::cmp::Ordering> {
            match *other {
                TypeMap {} => match *self {
                    TypeMap {} => ::core::option::Option::Some(::core::cmp::Ordering::Equal),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for TypeMap {
        #[inline]
        fn clone(&self) -> TypeMap {
            match *self {
                TypeMap {} => TypeMap {},
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for TypeMap {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                TypeMap {} => {
                    let mut debug_trait_builder = f.debug_struct("TypeMap");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    impl proptest::arbitrary::Arbitrary for TypeMap {
        type Parameters = ();
        type Strategy = proptest::strategy::BoxedStrategy<Self>;
        fn arbitrary_with(args: Self::Parameters) -> Self::Strategy {
            #[allow(dead_code)]
            fn _to_fn_ptr<T>(f: fn(&T) -> bool) -> fn(&T) -> bool {
                f
            }
            let args = std::rc::Rc::new(args);
            proptest::strategy::Strategy::boxed(proptest::strategy::LazyJust::new(|| Self {}))
        }
    }
    struct TypeName(String);
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for TypeName {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                _serde::Serializer::serialize_newtype_struct(__serializer, "TypeName", &self.0)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for TypeName {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                struct __Visitor<'de> {
                    marker: _serde::export::PhantomData<TypeName>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = TypeName;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "tuple struct TypeName")
                    }
                    #[inline]
                    fn visit_newtype_struct<__E>(
                        self,
                        __e: __E,
                    ) -> _serde::export::Result<Self::Value, __E::Error>
                    where
                        __E: _serde::Deserializer<'de>,
                    {
                        let __field0: String =
                            match <String as _serde::Deserialize>::deserialize(__e) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            };
                        _serde::export::Ok(TypeName(__field0))
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 =
                            match match _serde::de::SeqAccess::next_element::<String>(&mut __seq) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        0usize,
                                        &"tuple struct TypeName with 1 element",
                                    ));
                                }
                            };
                        _serde::export::Ok(TypeName(__field0))
                    }
                }
                _serde::Deserializer::deserialize_newtype_struct(
                    __deserializer,
                    "TypeName",
                    __Visitor {
                        marker: _serde::export::PhantomData::<TypeName>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    impl ::core::marker::StructuralPartialEq for TypeName {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for TypeName {
        #[inline]
        fn eq(&self, other: &TypeName) -> bool {
            match *other {
                TypeName(ref __self_1_0) => match *self {
                    TypeName(ref __self_0_0) => (*__self_0_0) == (*__self_1_0),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &TypeName) -> bool {
            match *other {
                TypeName(ref __self_1_0) => match *self {
                    TypeName(ref __self_0_0) => (*__self_0_0) != (*__self_1_0),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialOrd for TypeName {
        #[inline]
        fn partial_cmp(&self, other: &TypeName) -> ::core::option::Option<::core::cmp::Ordering> {
            match *other {
                TypeName(ref __self_1_0) => match *self {
                    TypeName(ref __self_0_0) => {
                        match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0), &(*__self_1_0)) {
                            ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                            }
                            cmp => cmp,
                        }
                    }
                },
            }
        }
        #[inline]
        fn lt(&self, other: &TypeName) -> bool {
            match *other {
                TypeName(ref __self_1_0) => match *self {
                    TypeName(ref __self_0_0) => {
                        ::core::option::Option::unwrap_or(
                            ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0), &(*__self_1_0)),
                            ::core::cmp::Ordering::Greater,
                        ) == ::core::cmp::Ordering::Less
                    }
                },
            }
        }
        #[inline]
        fn le(&self, other: &TypeName) -> bool {
            match *other {
                TypeName(ref __self_1_0) => match *self {
                    TypeName(ref __self_0_0) => {
                        ::core::option::Option::unwrap_or(
                            ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0), &(*__self_1_0)),
                            ::core::cmp::Ordering::Greater,
                        ) != ::core::cmp::Ordering::Greater
                    }
                },
            }
        }
        #[inline]
        fn gt(&self, other: &TypeName) -> bool {
            match *other {
                TypeName(ref __self_1_0) => match *self {
                    TypeName(ref __self_0_0) => {
                        ::core::option::Option::unwrap_or(
                            ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0), &(*__self_1_0)),
                            ::core::cmp::Ordering::Less,
                        ) == ::core::cmp::Ordering::Greater
                    }
                },
            }
        }
        #[inline]
        fn ge(&self, other: &TypeName) -> bool {
            match *other {
                TypeName(ref __self_1_0) => match *self {
                    TypeName(ref __self_0_0) => {
                        ::core::option::Option::unwrap_or(
                            ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0), &(*__self_1_0)),
                            ::core::cmp::Ordering::Less,
                        ) != ::core::cmp::Ordering::Less
                    }
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for TypeName {
        #[inline]
        fn clone(&self) -> TypeName {
            match *self {
                TypeName(ref __self_0_0) => TypeName(::core::clone::Clone::clone(&(*__self_0_0))),
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for TypeName {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                TypeName(ref __self_0_0) => {
                    let mut debug_trait_builder = f.debug_tuple("TypeName");
                    let _ = debug_trait_builder.field(&&(*__self_0_0));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    impl proptest::arbitrary::Arbitrary for TypeName {
        type Parameters = ();
        type Strategy = proptest::strategy::BoxedStrategy<Self>;
        fn arbitrary_with(args: Self::Parameters) -> Self::Strategy {
            #[allow(dead_code)]
            fn _to_fn_ptr<T>(f: fn(&T) -> bool) -> fn(&T) -> bool {
                f
            }
            let args = std::rc::Rc::new(args);
            proptest::strategy::Strategy::boxed({
                let strategy_0 = ({
                    #[allow(dead_code)]
                    fn _strategy_of_0<
                        T: std::fmt::Debug,
                        S: proptest::strategy::Strategy<Value = T>,
                    >(
                        s: S,
                    ) -> impl proptest::strategy::Strategy<Value = T> {
                        s
                    }
                    let _s = proptest::arbitrary::any::<String>();
                    _s
                },);
                let strategy_0 =
                    proptest::strategy::Strategy::prop_map(strategy_0, |_values| Self(_values.0));
                strategy_0
            })
        }
    }
    impl ::core::marker::StructuralEq for TypeName {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::Eq for TypeName {
        #[inline]
        #[doc(hidden)]
        fn assert_receiver_is_total_eq(&self) -> () {
            {
                let _: ::core::cmp::AssertParamIsEq<String>;
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::Ord for TypeName {
        #[inline]
        fn cmp(&self, other: &TypeName) -> ::core::cmp::Ordering {
            match *other {
                TypeName(ref __self_1_0) => match *self {
                    TypeName(ref __self_0_0) => {
                        match ::core::cmp::Ord::cmp(&(*__self_0_0), &(*__self_1_0)) {
                            ::core::cmp::Ordering::Equal => ::core::cmp::Ordering::Equal,
                            cmp => cmp,
                        }
                    }
                },
            }
        }
    }
    struct TypeString {}
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for TypeString {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "TypeString",
                    false as usize,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for TypeString {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"field index 0 <= i < 0",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::export::PhantomData<TypeString>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = TypeString;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "struct TypeString")
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        _: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        _serde::export::Ok(TypeString {})
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        while let _serde::export::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            }
                        {
                            match __key {
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        _serde::export::Ok(TypeString {})
                    }
                }
                const FIELDS: &'static [&'static str] = &[];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "TypeString",
                    FIELDS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<TypeString>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    impl ::core::marker::StructuralPartialEq for TypeString {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for TypeString {
        #[inline]
        fn eq(&self, other: &TypeString) -> bool {
            match *other {
                TypeString {} => match *self {
                    TypeString {} => true,
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialOrd for TypeString {
        #[inline]
        fn partial_cmp(&self, other: &TypeString) -> ::core::option::Option<::core::cmp::Ordering> {
            match *other {
                TypeString {} => match *self {
                    TypeString {} => ::core::option::Option::Some(::core::cmp::Ordering::Equal),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for TypeString {
        #[inline]
        fn clone(&self) -> TypeString {
            match *self {
                TypeString {} => TypeString {},
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for TypeString {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                TypeString {} => {
                    let mut debug_trait_builder = f.debug_struct("TypeString");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    impl proptest::arbitrary::Arbitrary for TypeString {
        type Parameters = ();
        type Strategy = proptest::strategy::BoxedStrategy<Self>;
        fn arbitrary_with(args: Self::Parameters) -> Self::Strategy {
            #[allow(dead_code)]
            fn _to_fn_ptr<T>(f: fn(&T) -> bool) -> fn(&T) -> bool {
                f
            }
            let args = std::rc::Rc::new(args);
            proptest::strategy::Strategy::boxed(proptest::strategy::LazyJust::new(|| Self {}))
        }
    }
    struct TypeStruct {}
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for TypeStruct {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "TypeStruct",
                    false as usize,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for TypeStruct {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"field index 0 <= i < 0",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::export::PhantomData<TypeStruct>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = TypeStruct;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "struct TypeStruct")
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        _: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        _serde::export::Ok(TypeStruct {})
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        while let _serde::export::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            }
                        {
                            match __key {
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        _serde::export::Ok(TypeStruct {})
                    }
                }
                const FIELDS: &'static [&'static str] = &[];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "TypeStruct",
                    FIELDS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<TypeStruct>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    impl ::core::marker::StructuralPartialEq for TypeStruct {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for TypeStruct {
        #[inline]
        fn eq(&self, other: &TypeStruct) -> bool {
            match *other {
                TypeStruct {} => match *self {
                    TypeStruct {} => true,
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialOrd for TypeStruct {
        #[inline]
        fn partial_cmp(&self, other: &TypeStruct) -> ::core::option::Option<::core::cmp::Ordering> {
            match *other {
                TypeStruct {} => match *self {
                    TypeStruct {} => ::core::option::Option::Some(::core::cmp::Ordering::Equal),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for TypeStruct {
        #[inline]
        fn clone(&self) -> TypeStruct {
            match *self {
                TypeStruct {} => TypeStruct {},
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for TypeStruct {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                TypeStruct {} => {
                    let mut debug_trait_builder = f.debug_struct("TypeStruct");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    impl proptest::arbitrary::Arbitrary for TypeStruct {
        type Parameters = ();
        type Strategy = proptest::strategy::BoxedStrategy<Self>;
        fn arbitrary_with(args: Self::Parameters) -> Self::Strategy {
            #[allow(dead_code)]
            fn _to_fn_ptr<T>(f: fn(&T) -> bool) -> fn(&T) -> bool {
                f
            }
            let args = std::rc::Rc::new(args);
            proptest::strategy::Strategy::boxed(proptest::strategy::LazyJust::new(|| Self {}))
        }
    }
    enum TypeTerm {
        String(TypeName),
        Map(InlineDefn),
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for TypeTerm {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    TypeTerm::String(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "TypeTerm",
                            0u32,
                            "String",
                            __field0,
                        )
                    }
                    TypeTerm::Map(ref __field0) => _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "TypeTerm",
                        1u32,
                        "Map",
                        __field0,
                    ),
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for TypeTerm {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "variant identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::export::Ok(__Field::__field0),
                            1u64 => _serde::export::Ok(__Field::__field1),
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"variant index 0 <= i < 2",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "String" => _serde::export::Ok(__Field::__field0),
                            "Map" => _serde::export::Ok(__Field::__field1),
                            _ => _serde::export::Err(_serde::de::Error::unknown_variant(
                                __value, VARIANTS,
                            )),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"String" => _serde::export::Ok(__Field::__field0),
                            b"Map" => _serde::export::Ok(__Field::__field1),
                            _ => {
                                let __value = &_serde::export::from_utf8_lossy(__value);
                                _serde::export::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                ))
                            }
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::export::PhantomData<TypeTerm>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = TypeTerm;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "enum TypeTerm")
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match match _serde::de::EnumAccess::variant(__data) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            (__Field::__field0, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<TypeName>(__variant),
                                TypeTerm::String,
                            ),
                            (__Field::__field1, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<InlineDefn>(__variant),
                                TypeTerm::Map,
                            ),
                        }
                    }
                }
                const VARIANTS: &'static [&'static str] = &["String", "Map"];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "TypeTerm",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<TypeTerm>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    impl ::core::marker::StructuralPartialEq for TypeTerm {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for TypeTerm {
        #[inline]
        fn eq(&self, other: &TypeTerm) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&TypeTerm::String(ref __self_0), &TypeTerm::String(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        (&TypeTerm::Map(ref __self_0), &TypeTerm::Map(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    false
                }
            }
        }
        #[inline]
        fn ne(&self, other: &TypeTerm) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&TypeTerm::String(ref __self_0), &TypeTerm::String(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        (&TypeTerm::Map(ref __self_0), &TypeTerm::Map(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    true
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialOrd for TypeTerm {
        #[inline]
        fn partial_cmp(&self, other: &TypeTerm) -> ::core::option::Option<::core::cmp::Ordering> {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&TypeTerm::String(ref __self_0), &TypeTerm::String(ref __arg_1_0)) => {
                            match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0))
                            {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                }
                                cmp => cmp,
                            }
                        }
                        (&TypeTerm::Map(ref __self_0), &TypeTerm::Map(ref __arg_1_0)) => {
                            match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0))
                            {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                }
                                cmp => cmp,
                            }
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    __self_vi.partial_cmp(&__arg_1_vi)
                }
            }
        }
        #[inline]
        fn lt(&self, other: &TypeTerm) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&TypeTerm::String(ref __self_0), &TypeTerm::String(ref __arg_1_0)) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Greater,
                            ) == ::core::cmp::Ordering::Less
                        }
                        (&TypeTerm::Map(ref __self_0), &TypeTerm::Map(ref __arg_1_0)) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Greater,
                            ) == ::core::cmp::Ordering::Less
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    __self_vi.lt(&__arg_1_vi)
                }
            }
        }
        #[inline]
        fn le(&self, other: &TypeTerm) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&TypeTerm::String(ref __self_0), &TypeTerm::String(ref __arg_1_0)) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Greater,
                            ) != ::core::cmp::Ordering::Greater
                        }
                        (&TypeTerm::Map(ref __self_0), &TypeTerm::Map(ref __arg_1_0)) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Greater,
                            ) != ::core::cmp::Ordering::Greater
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    __self_vi.le(&__arg_1_vi)
                }
            }
        }
        #[inline]
        fn gt(&self, other: &TypeTerm) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&TypeTerm::String(ref __self_0), &TypeTerm::String(ref __arg_1_0)) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Less,
                            ) == ::core::cmp::Ordering::Greater
                        }
                        (&TypeTerm::Map(ref __self_0), &TypeTerm::Map(ref __arg_1_0)) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Less,
                            ) == ::core::cmp::Ordering::Greater
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    __self_vi.gt(&__arg_1_vi)
                }
            }
        }
        #[inline]
        fn ge(&self, other: &TypeTerm) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&TypeTerm::String(ref __self_0), &TypeTerm::String(ref __arg_1_0)) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Less,
                            ) != ::core::cmp::Ordering::Less
                        }
                        (&TypeTerm::Map(ref __self_0), &TypeTerm::Map(ref __arg_1_0)) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Less,
                            ) != ::core::cmp::Ordering::Less
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    __self_vi.ge(&__arg_1_vi)
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for TypeTerm {
        #[inline]
        fn clone(&self) -> TypeTerm {
            match (&*self,) {
                (&TypeTerm::String(ref __self_0),) => {
                    TypeTerm::String(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&TypeTerm::Map(ref __self_0),) => {
                    TypeTerm::Map(::core::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for TypeTerm {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&TypeTerm::String(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("String");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&TypeTerm::Map(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("Map");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    impl proptest::arbitrary::Arbitrary for TypeTerm {
        type Parameters = ();
        type Strategy = proptest::strategy::BoxedStrategy<Self>;
        fn arbitrary_with(args: Self::Parameters) -> Self::Strategy {
            #[allow(dead_code)]
            fn _to_fn_ptr<T>(f: fn(&T) -> bool) -> fn(&T) -> bool {
                f
            }
            let args = std::rc::Rc::new(args);
            proptest::strategy::Strategy::boxed({
                #[allow(dead_code)]
                fn _to_weight(weight: u32) -> u32 {
                    weight
                }
                let _s = ::proptest::strategy::TupleUnion::new((
                    (
                        1,
                        ::proptest::std_facade::Arc::new({
                            let strategy_0 = ({
                                #[allow(dead_code)]
                                fn _strategy_of_0<
                                    T: std::fmt::Debug,
                                    S: proptest::strategy::Strategy<Value = T>,
                                >(
                                    s: S,
                                ) -> impl proptest::strategy::Strategy<Value = T>
                                {
                                    s
                                }
                                let _s = proptest::arbitrary::any::<TypeName>();
                                _s
                            },);
                            let strategy_0 =
                                proptest::strategy::Strategy::prop_map(strategy_0, |_values| {
                                    Self::String(_values.0)
                                });
                            strategy_0
                        }),
                    ),
                    (
                        1,
                        ::proptest::std_facade::Arc::new({
                            let strategy_0 = ({
                                #[allow(dead_code)]
                                fn _strategy_of_0<
                                    T: std::fmt::Debug,
                                    S: proptest::strategy::Strategy<Value = T>,
                                >(
                                    s: S,
                                ) -> impl proptest::strategy::Strategy<Value = T>
                                {
                                    s
                                }
                                let _s = proptest::arbitrary::any::<InlineDefn>();
                                _s
                            },);
                            let strategy_0 =
                                proptest::strategy::Strategy::prop_map(strategy_0, |_values| {
                                    Self::Map(_values.0)
                                });
                            strategy_0
                        }),
                    ),
                ));
                _s
            })
        }
    }
    struct TypeUnion {}
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for TypeUnion {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "TypeUnion",
                    false as usize,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for TypeUnion {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"field index 0 <= i < 0",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::export::PhantomData<TypeUnion>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = TypeUnion;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "struct TypeUnion")
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        _: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        _serde::export::Ok(TypeUnion {})
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        while let _serde::export::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            }
                        {
                            match __key {
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        _serde::export::Ok(TypeUnion {})
                    }
                }
                const FIELDS: &'static [&'static str] = &[];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "TypeUnion",
                    FIELDS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<TypeUnion>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    impl ::core::marker::StructuralPartialEq for TypeUnion {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for TypeUnion {
        #[inline]
        fn eq(&self, other: &TypeUnion) -> bool {
            match *other {
                TypeUnion {} => match *self {
                    TypeUnion {} => true,
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialOrd for TypeUnion {
        #[inline]
        fn partial_cmp(&self, other: &TypeUnion) -> ::core::option::Option<::core::cmp::Ordering> {
            match *other {
                TypeUnion {} => match *self {
                    TypeUnion {} => ::core::option::Option::Some(::core::cmp::Ordering::Equal),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for TypeUnion {
        #[inline]
        fn clone(&self) -> TypeUnion {
            match *self {
                TypeUnion {} => TypeUnion {},
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for TypeUnion {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                TypeUnion {} => {
                    let mut debug_trait_builder = f.debug_struct("TypeUnion");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    impl proptest::arbitrary::Arbitrary for TypeUnion {
        type Parameters = ();
        type Strategy = proptest::strategy::BoxedStrategy<Self>;
        fn arbitrary_with(args: Self::Parameters) -> Self::Strategy {
            #[allow(dead_code)]
            fn _to_fn_ptr<T>(f: fn(&T) -> bool) -> fn(&T) -> bool {
                f
            }
            let args = std::rc::Rc::new(args);
            proptest::strategy::Strategy::boxed(proptest::strategy::LazyJust::new(|| Self {}))
        }
    }
    enum UnionRepresentation {
        byteprefix(UnionRepresentation_BytePrefix),
        envelope(UnionRepresentation_Envelope),
        inline(UnionRepresentation_Inline),
        keyed(UnionRepresentation_Keyed),
        kinded(UnionRepresentation_Kinded),
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for UnionRepresentation {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    UnionRepresentation::byteprefix(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "UnionRepresentation",
                            0u32,
                            "byteprefix",
                            __field0,
                        )
                    }
                    UnionRepresentation::envelope(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "UnionRepresentation",
                            1u32,
                            "envelope",
                            __field0,
                        )
                    }
                    UnionRepresentation::inline(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "UnionRepresentation",
                            2u32,
                            "inline",
                            __field0,
                        )
                    }
                    UnionRepresentation::keyed(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "UnionRepresentation",
                            3u32,
                            "keyed",
                            __field0,
                        )
                    }
                    UnionRepresentation::kinded(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "UnionRepresentation",
                            4u32,
                            "kinded",
                            __field0,
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for UnionRepresentation {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "variant identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::export::Ok(__Field::__field0),
                            1u64 => _serde::export::Ok(__Field::__field1),
                            2u64 => _serde::export::Ok(__Field::__field2),
                            3u64 => _serde::export::Ok(__Field::__field3),
                            4u64 => _serde::export::Ok(__Field::__field4),
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"variant index 0 <= i < 5",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "byteprefix" => _serde::export::Ok(__Field::__field0),
                            "envelope" => _serde::export::Ok(__Field::__field1),
                            "inline" => _serde::export::Ok(__Field::__field2),
                            "keyed" => _serde::export::Ok(__Field::__field3),
                            "kinded" => _serde::export::Ok(__Field::__field4),
                            _ => _serde::export::Err(_serde::de::Error::unknown_variant(
                                __value, VARIANTS,
                            )),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"byteprefix" => _serde::export::Ok(__Field::__field0),
                            b"envelope" => _serde::export::Ok(__Field::__field1),
                            b"inline" => _serde::export::Ok(__Field::__field2),
                            b"keyed" => _serde::export::Ok(__Field::__field3),
                            b"kinded" => _serde::export::Ok(__Field::__field4),
                            _ => {
                                let __value = &_serde::export::from_utf8_lossy(__value);
                                _serde::export::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                ))
                            }
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::export::PhantomData<UnionRepresentation>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = UnionRepresentation;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(
                            __formatter,
                            "enum UnionRepresentation",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match match _serde::de::EnumAccess::variant(__data) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            (__Field::__field0, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<
                                    UnionRepresentation_BytePrefix,
                                >(__variant),
                                UnionRepresentation::byteprefix,
                            ),
                            (__Field::__field1, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<
                                    UnionRepresentation_Envelope,
                                >(__variant),
                                UnionRepresentation::envelope,
                            ),
                            (__Field::__field2, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<
                                    UnionRepresentation_Inline,
                                >(__variant),
                                UnionRepresentation::inline,
                            ),
                            (__Field::__field3, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<
                                    UnionRepresentation_Keyed,
                                >(__variant),
                                UnionRepresentation::keyed,
                            ),
                            (__Field::__field4, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<
                                    UnionRepresentation_Kinded,
                                >(__variant),
                                UnionRepresentation::kinded,
                            ),
                        }
                    }
                }
                const VARIANTS: &'static [&'static str] =
                    &["byteprefix", "envelope", "inline", "keyed", "kinded"];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "UnionRepresentation",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<UnionRepresentation>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    impl ::core::marker::StructuralPartialEq for UnionRepresentation {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for UnionRepresentation {
        #[inline]
        fn eq(&self, other: &UnionRepresentation) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (
                            &UnionRepresentation::byteprefix(ref __self_0),
                            &UnionRepresentation::byteprefix(ref __arg_1_0),
                        ) => (*__self_0) == (*__arg_1_0),
                        (
                            &UnionRepresentation::envelope(ref __self_0),
                            &UnionRepresentation::envelope(ref __arg_1_0),
                        ) => (*__self_0) == (*__arg_1_0),
                        (
                            &UnionRepresentation::inline(ref __self_0),
                            &UnionRepresentation::inline(ref __arg_1_0),
                        ) => (*__self_0) == (*__arg_1_0),
                        (
                            &UnionRepresentation::keyed(ref __self_0),
                            &UnionRepresentation::keyed(ref __arg_1_0),
                        ) => (*__self_0) == (*__arg_1_0),
                        (
                            &UnionRepresentation::kinded(ref __self_0),
                            &UnionRepresentation::kinded(ref __arg_1_0),
                        ) => (*__self_0) == (*__arg_1_0),
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    false
                }
            }
        }
        #[inline]
        fn ne(&self, other: &UnionRepresentation) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (
                            &UnionRepresentation::byteprefix(ref __self_0),
                            &UnionRepresentation::byteprefix(ref __arg_1_0),
                        ) => (*__self_0) != (*__arg_1_0),
                        (
                            &UnionRepresentation::envelope(ref __self_0),
                            &UnionRepresentation::envelope(ref __arg_1_0),
                        ) => (*__self_0) != (*__arg_1_0),
                        (
                            &UnionRepresentation::inline(ref __self_0),
                            &UnionRepresentation::inline(ref __arg_1_0),
                        ) => (*__self_0) != (*__arg_1_0),
                        (
                            &UnionRepresentation::keyed(ref __self_0),
                            &UnionRepresentation::keyed(ref __arg_1_0),
                        ) => (*__self_0) != (*__arg_1_0),
                        (
                            &UnionRepresentation::kinded(ref __self_0),
                            &UnionRepresentation::kinded(ref __arg_1_0),
                        ) => (*__self_0) != (*__arg_1_0),
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    true
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialOrd for UnionRepresentation {
        #[inline]
        fn partial_cmp(
            &self,
            other: &UnionRepresentation,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (
                            &UnionRepresentation::byteprefix(ref __self_0),
                            &UnionRepresentation::byteprefix(ref __arg_1_0),
                        ) => {
                            match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0))
                            {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                }
                                cmp => cmp,
                            }
                        }
                        (
                            &UnionRepresentation::envelope(ref __self_0),
                            &UnionRepresentation::envelope(ref __arg_1_0),
                        ) => {
                            match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0))
                            {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                }
                                cmp => cmp,
                            }
                        }
                        (
                            &UnionRepresentation::inline(ref __self_0),
                            &UnionRepresentation::inline(ref __arg_1_0),
                        ) => {
                            match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0))
                            {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                }
                                cmp => cmp,
                            }
                        }
                        (
                            &UnionRepresentation::keyed(ref __self_0),
                            &UnionRepresentation::keyed(ref __arg_1_0),
                        ) => {
                            match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0))
                            {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                }
                                cmp => cmp,
                            }
                        }
                        (
                            &UnionRepresentation::kinded(ref __self_0),
                            &UnionRepresentation::kinded(ref __arg_1_0),
                        ) => {
                            match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0))
                            {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                }
                                cmp => cmp,
                            }
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    __self_vi.partial_cmp(&__arg_1_vi)
                }
            }
        }
        #[inline]
        fn lt(&self, other: &UnionRepresentation) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (
                            &UnionRepresentation::byteprefix(ref __self_0),
                            &UnionRepresentation::byteprefix(ref __arg_1_0),
                        ) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Greater,
                            ) == ::core::cmp::Ordering::Less
                        }
                        (
                            &UnionRepresentation::envelope(ref __self_0),
                            &UnionRepresentation::envelope(ref __arg_1_0),
                        ) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Greater,
                            ) == ::core::cmp::Ordering::Less
                        }
                        (
                            &UnionRepresentation::inline(ref __self_0),
                            &UnionRepresentation::inline(ref __arg_1_0),
                        ) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Greater,
                            ) == ::core::cmp::Ordering::Less
                        }
                        (
                            &UnionRepresentation::keyed(ref __self_0),
                            &UnionRepresentation::keyed(ref __arg_1_0),
                        ) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Greater,
                            ) == ::core::cmp::Ordering::Less
                        }
                        (
                            &UnionRepresentation::kinded(ref __self_0),
                            &UnionRepresentation::kinded(ref __arg_1_0),
                        ) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Greater,
                            ) == ::core::cmp::Ordering::Less
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    __self_vi.lt(&__arg_1_vi)
                }
            }
        }
        #[inline]
        fn le(&self, other: &UnionRepresentation) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (
                            &UnionRepresentation::byteprefix(ref __self_0),
                            &UnionRepresentation::byteprefix(ref __arg_1_0),
                        ) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Greater,
                            ) != ::core::cmp::Ordering::Greater
                        }
                        (
                            &UnionRepresentation::envelope(ref __self_0),
                            &UnionRepresentation::envelope(ref __arg_1_0),
                        ) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Greater,
                            ) != ::core::cmp::Ordering::Greater
                        }
                        (
                            &UnionRepresentation::inline(ref __self_0),
                            &UnionRepresentation::inline(ref __arg_1_0),
                        ) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Greater,
                            ) != ::core::cmp::Ordering::Greater
                        }
                        (
                            &UnionRepresentation::keyed(ref __self_0),
                            &UnionRepresentation::keyed(ref __arg_1_0),
                        ) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Greater,
                            ) != ::core::cmp::Ordering::Greater
                        }
                        (
                            &UnionRepresentation::kinded(ref __self_0),
                            &UnionRepresentation::kinded(ref __arg_1_0),
                        ) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Greater,
                            ) != ::core::cmp::Ordering::Greater
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    __self_vi.le(&__arg_1_vi)
                }
            }
        }
        #[inline]
        fn gt(&self, other: &UnionRepresentation) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (
                            &UnionRepresentation::byteprefix(ref __self_0),
                            &UnionRepresentation::byteprefix(ref __arg_1_0),
                        ) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Less,
                            ) == ::core::cmp::Ordering::Greater
                        }
                        (
                            &UnionRepresentation::envelope(ref __self_0),
                            &UnionRepresentation::envelope(ref __arg_1_0),
                        ) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Less,
                            ) == ::core::cmp::Ordering::Greater
                        }
                        (
                            &UnionRepresentation::inline(ref __self_0),
                            &UnionRepresentation::inline(ref __arg_1_0),
                        ) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Less,
                            ) == ::core::cmp::Ordering::Greater
                        }
                        (
                            &UnionRepresentation::keyed(ref __self_0),
                            &UnionRepresentation::keyed(ref __arg_1_0),
                        ) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Less,
                            ) == ::core::cmp::Ordering::Greater
                        }
                        (
                            &UnionRepresentation::kinded(ref __self_0),
                            &UnionRepresentation::kinded(ref __arg_1_0),
                        ) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Less,
                            ) == ::core::cmp::Ordering::Greater
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    __self_vi.gt(&__arg_1_vi)
                }
            }
        }
        #[inline]
        fn ge(&self, other: &UnionRepresentation) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (
                            &UnionRepresentation::byteprefix(ref __self_0),
                            &UnionRepresentation::byteprefix(ref __arg_1_0),
                        ) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Less,
                            ) != ::core::cmp::Ordering::Less
                        }
                        (
                            &UnionRepresentation::envelope(ref __self_0),
                            &UnionRepresentation::envelope(ref __arg_1_0),
                        ) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Less,
                            ) != ::core::cmp::Ordering::Less
                        }
                        (
                            &UnionRepresentation::inline(ref __self_0),
                            &UnionRepresentation::inline(ref __arg_1_0),
                        ) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Less,
                            ) != ::core::cmp::Ordering::Less
                        }
                        (
                            &UnionRepresentation::keyed(ref __self_0),
                            &UnionRepresentation::keyed(ref __arg_1_0),
                        ) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Less,
                            ) != ::core::cmp::Ordering::Less
                        }
                        (
                            &UnionRepresentation::kinded(ref __self_0),
                            &UnionRepresentation::kinded(ref __arg_1_0),
                        ) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Less,
                            ) != ::core::cmp::Ordering::Less
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    __self_vi.ge(&__arg_1_vi)
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for UnionRepresentation {
        #[inline]
        fn clone(&self) -> UnionRepresentation {
            match (&*self,) {
                (&UnionRepresentation::byteprefix(ref __self_0),) => {
                    UnionRepresentation::byteprefix(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&UnionRepresentation::envelope(ref __self_0),) => {
                    UnionRepresentation::envelope(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&UnionRepresentation::inline(ref __self_0),) => {
                    UnionRepresentation::inline(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&UnionRepresentation::keyed(ref __self_0),) => {
                    UnionRepresentation::keyed(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&UnionRepresentation::kinded(ref __self_0),) => {
                    UnionRepresentation::kinded(::core::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for UnionRepresentation {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&UnionRepresentation::byteprefix(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("byteprefix");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&UnionRepresentation::envelope(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("envelope");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&UnionRepresentation::inline(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("inline");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&UnionRepresentation::keyed(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("keyed");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&UnionRepresentation::kinded(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("kinded");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    impl proptest::arbitrary::Arbitrary for UnionRepresentation {
        type Parameters = ();
        type Strategy = proptest::strategy::BoxedStrategy<Self>;
        fn arbitrary_with(args: Self::Parameters) -> Self::Strategy {
            #[allow(dead_code)]
            fn _to_fn_ptr<T>(f: fn(&T) -> bool) -> fn(&T) -> bool {
                f
            }
            let args = std::rc::Rc::new(args);
            proptest::strategy::Strategy::boxed({
                #[allow(dead_code)]
                fn _to_weight(weight: u32) -> u32 {
                    weight
                }
                let _s = ::proptest::strategy::TupleUnion::new((
                    (
                        1,
                        ::proptest::std_facade::Arc::new({
                            let strategy_0 = ({
                                #[allow(dead_code)]
                                fn _strategy_of_0<
                                    T: std::fmt::Debug,
                                    S: proptest::strategy::Strategy<Value = T>,
                                >(
                                    s: S,
                                ) -> impl proptest::strategy::Strategy<Value = T>
                                {
                                    s
                                }
                                let _s =
                                    proptest::arbitrary::any::<UnionRepresentation_BytePrefix>();
                                _s
                            },);
                            let strategy_0 =
                                proptest::strategy::Strategy::prop_map(strategy_0, |_values| {
                                    Self::byteprefix(_values.0)
                                });
                            strategy_0
                        }),
                    ),
                    (
                        1,
                        ::proptest::std_facade::Arc::new({
                            let strategy_0 = ({
                                #[allow(dead_code)]
                                fn _strategy_of_0<
                                    T: std::fmt::Debug,
                                    S: proptest::strategy::Strategy<Value = T>,
                                >(
                                    s: S,
                                ) -> impl proptest::strategy::Strategy<Value = T>
                                {
                                    s
                                }
                                let _s = proptest::arbitrary::any::<UnionRepresentation_Envelope>();
                                _s
                            },);
                            let strategy_0 =
                                proptest::strategy::Strategy::prop_map(strategy_0, |_values| {
                                    Self::envelope(_values.0)
                                });
                            strategy_0
                        }),
                    ),
                    (
                        1,
                        ::proptest::std_facade::Arc::new({
                            let strategy_0 = ({
                                #[allow(dead_code)]
                                fn _strategy_of_0<
                                    T: std::fmt::Debug,
                                    S: proptest::strategy::Strategy<Value = T>,
                                >(
                                    s: S,
                                ) -> impl proptest::strategy::Strategy<Value = T>
                                {
                                    s
                                }
                                let _s = proptest::arbitrary::any::<UnionRepresentation_Inline>();
                                _s
                            },);
                            let strategy_0 =
                                proptest::strategy::Strategy::prop_map(strategy_0, |_values| {
                                    Self::inline(_values.0)
                                });
                            strategy_0
                        }),
                    ),
                    (
                        1,
                        ::proptest::std_facade::Arc::new({
                            let strategy_0 = ({
                                #[allow(dead_code)]
                                fn _strategy_of_0<
                                    T: std::fmt::Debug,
                                    S: proptest::strategy::Strategy<Value = T>,
                                >(
                                    s: S,
                                ) -> impl proptest::strategy::Strategy<Value = T>
                                {
                                    s
                                }
                                let _s = proptest::arbitrary::any::<UnionRepresentation_Keyed>();
                                _s
                            },);
                            let strategy_0 =
                                proptest::strategy::Strategy::prop_map(strategy_0, |_values| {
                                    Self::keyed(_values.0)
                                });
                            strategy_0
                        }),
                    ),
                    (
                        1,
                        ::proptest::std_facade::Arc::new({
                            let strategy_0 = ({
                                #[allow(dead_code)]
                                fn _strategy_of_0<
                                    T: std::fmt::Debug,
                                    S: proptest::strategy::Strategy<Value = T>,
                                >(
                                    s: S,
                                ) -> impl proptest::strategy::Strategy<Value = T>
                                {
                                    s
                                }
                                let _s = proptest::arbitrary::any::<UnionRepresentation_Kinded>();
                                _s
                            },);
                            let strategy_0 =
                                proptest::strategy::Strategy::prop_map(strategy_0, |_values| {
                                    Self::kinded(_values.0)
                                });
                            strategy_0
                        }),
                    ),
                ));
                _s
            })
        }
    }
    struct UnionRepresentation_BytePrefix {}
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for UnionRepresentation_BytePrefix {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "UnionRepresentation_BytePrefix",
                    false as usize,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for UnionRepresentation_BytePrefix {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"field index 0 <= i < 0",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::export::PhantomData<UnionRepresentation_BytePrefix>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = UnionRepresentation_BytePrefix;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(
                            __formatter,
                            "struct UnionRepresentation_BytePrefix",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        _: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        _serde::export::Ok(UnionRepresentation_BytePrefix {})
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        while let _serde::export::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            }
                        {
                            match __key {
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        _serde::export::Ok(UnionRepresentation_BytePrefix {})
                    }
                }
                const FIELDS: &'static [&'static str] = &[];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "UnionRepresentation_BytePrefix",
                    FIELDS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<UnionRepresentation_BytePrefix>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    impl ::core::marker::StructuralPartialEq for UnionRepresentation_BytePrefix {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for UnionRepresentation_BytePrefix {
        #[inline]
        fn eq(&self, other: &UnionRepresentation_BytePrefix) -> bool {
            match *other {
                UnionRepresentation_BytePrefix {} => match *self {
                    UnionRepresentation_BytePrefix {} => true,
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialOrd for UnionRepresentation_BytePrefix {
        #[inline]
        fn partial_cmp(
            &self,
            other: &UnionRepresentation_BytePrefix,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match *other {
                UnionRepresentation_BytePrefix {} => match *self {
                    UnionRepresentation_BytePrefix {} => {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                    }
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for UnionRepresentation_BytePrefix {
        #[inline]
        fn clone(&self) -> UnionRepresentation_BytePrefix {
            match *self {
                UnionRepresentation_BytePrefix {} => UnionRepresentation_BytePrefix {},
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for UnionRepresentation_BytePrefix {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                UnionRepresentation_BytePrefix {} => {
                    let mut debug_trait_builder = f.debug_struct("UnionRepresentation_BytePrefix");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    impl proptest::arbitrary::Arbitrary for UnionRepresentation_BytePrefix {
        type Parameters = ();
        type Strategy = proptest::strategy::BoxedStrategy<Self>;
        fn arbitrary_with(args: Self::Parameters) -> Self::Strategy {
            #[allow(dead_code)]
            fn _to_fn_ptr<T>(f: fn(&T) -> bool) -> fn(&T) -> bool {
                f
            }
            let args = std::rc::Rc::new(args);
            proptest::strategy::Strategy::boxed(proptest::strategy::LazyJust::new(|| Self {}))
        }
    }
    struct UnionRepresentation_Envelope {}
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for UnionRepresentation_Envelope {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "UnionRepresentation_Envelope",
                    false as usize,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for UnionRepresentation_Envelope {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"field index 0 <= i < 0",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::export::PhantomData<UnionRepresentation_Envelope>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = UnionRepresentation_Envelope;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(
                            __formatter,
                            "struct UnionRepresentation_Envelope",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        _: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        _serde::export::Ok(UnionRepresentation_Envelope {})
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        while let _serde::export::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            }
                        {
                            match __key {
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        _serde::export::Ok(UnionRepresentation_Envelope {})
                    }
                }
                const FIELDS: &'static [&'static str] = &[];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "UnionRepresentation_Envelope",
                    FIELDS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<UnionRepresentation_Envelope>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    impl ::core::marker::StructuralPartialEq for UnionRepresentation_Envelope {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for UnionRepresentation_Envelope {
        #[inline]
        fn eq(&self, other: &UnionRepresentation_Envelope) -> bool {
            match *other {
                UnionRepresentation_Envelope {} => match *self {
                    UnionRepresentation_Envelope {} => true,
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialOrd for UnionRepresentation_Envelope {
        #[inline]
        fn partial_cmp(
            &self,
            other: &UnionRepresentation_Envelope,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match *other {
                UnionRepresentation_Envelope {} => match *self {
                    UnionRepresentation_Envelope {} => {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                    }
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for UnionRepresentation_Envelope {
        #[inline]
        fn clone(&self) -> UnionRepresentation_Envelope {
            match *self {
                UnionRepresentation_Envelope {} => UnionRepresentation_Envelope {},
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for UnionRepresentation_Envelope {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                UnionRepresentation_Envelope {} => {
                    let mut debug_trait_builder = f.debug_struct("UnionRepresentation_Envelope");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    impl proptest::arbitrary::Arbitrary for UnionRepresentation_Envelope {
        type Parameters = ();
        type Strategy = proptest::strategy::BoxedStrategy<Self>;
        fn arbitrary_with(args: Self::Parameters) -> Self::Strategy {
            #[allow(dead_code)]
            fn _to_fn_ptr<T>(f: fn(&T) -> bool) -> fn(&T) -> bool {
                f
            }
            let args = std::rc::Rc::new(args);
            proptest::strategy::Strategy::boxed(proptest::strategy::LazyJust::new(|| Self {}))
        }
    }
    struct UnionRepresentation_Inline {}
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for UnionRepresentation_Inline {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "UnionRepresentation_Inline",
                    false as usize,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for UnionRepresentation_Inline {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"field index 0 <= i < 0",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::export::PhantomData<UnionRepresentation_Inline>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = UnionRepresentation_Inline;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(
                            __formatter,
                            "struct UnionRepresentation_Inline",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        _: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        _serde::export::Ok(UnionRepresentation_Inline {})
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        while let _serde::export::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            }
                        {
                            match __key {
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        _serde::export::Ok(UnionRepresentation_Inline {})
                    }
                }
                const FIELDS: &'static [&'static str] = &[];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "UnionRepresentation_Inline",
                    FIELDS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<UnionRepresentation_Inline>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    impl ::core::marker::StructuralPartialEq for UnionRepresentation_Inline {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for UnionRepresentation_Inline {
        #[inline]
        fn eq(&self, other: &UnionRepresentation_Inline) -> bool {
            match *other {
                UnionRepresentation_Inline {} => match *self {
                    UnionRepresentation_Inline {} => true,
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialOrd for UnionRepresentation_Inline {
        #[inline]
        fn partial_cmp(
            &self,
            other: &UnionRepresentation_Inline,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match *other {
                UnionRepresentation_Inline {} => match *self {
                    UnionRepresentation_Inline {} => {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                    }
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for UnionRepresentation_Inline {
        #[inline]
        fn clone(&self) -> UnionRepresentation_Inline {
            match *self {
                UnionRepresentation_Inline {} => UnionRepresentation_Inline {},
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for UnionRepresentation_Inline {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                UnionRepresentation_Inline {} => {
                    let mut debug_trait_builder = f.debug_struct("UnionRepresentation_Inline");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    impl proptest::arbitrary::Arbitrary for UnionRepresentation_Inline {
        type Parameters = ();
        type Strategy = proptest::strategy::BoxedStrategy<Self>;
        fn arbitrary_with(args: Self::Parameters) -> Self::Strategy {
            #[allow(dead_code)]
            fn _to_fn_ptr<T>(f: fn(&T) -> bool) -> fn(&T) -> bool {
                f
            }
            let args = std::rc::Rc::new(args);
            proptest::strategy::Strategy::boxed(proptest::strategy::LazyJust::new(|| Self {}))
        }
    }
    struct UnionRepresentation_Keyed(Map<String, TypeName>);
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for UnionRepresentation_Keyed {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                _serde::Serializer::serialize_newtype_struct(
                    __serializer,
                    "UnionRepresentation_Keyed",
                    &self.0,
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for UnionRepresentation_Keyed {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                struct __Visitor<'de> {
                    marker: _serde::export::PhantomData<UnionRepresentation_Keyed>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = UnionRepresentation_Keyed;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(
                            __formatter,
                            "tuple struct UnionRepresentation_Keyed",
                        )
                    }
                    #[inline]
                    fn visit_newtype_struct<__E>(
                        self,
                        __e: __E,
                    ) -> _serde::export::Result<Self::Value, __E::Error>
                    where
                        __E: _serde::Deserializer<'de>,
                    {
                        let __field0: Map<String, TypeName> =
                            match <Map<String, TypeName> as _serde::Deserialize>::deserialize(__e) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            };
                        _serde::export::Ok(UnionRepresentation_Keyed(__field0))
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                            Map<String, TypeName>,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    0usize,
                                    &"tuple struct UnionRepresentation_Keyed with 1 element",
                                ));
                            }
                        };
                        _serde::export::Ok(UnionRepresentation_Keyed(__field0))
                    }
                }
                _serde::Deserializer::deserialize_newtype_struct(
                    __deserializer,
                    "UnionRepresentation_Keyed",
                    __Visitor {
                        marker: _serde::export::PhantomData::<UnionRepresentation_Keyed>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    impl ::core::marker::StructuralPartialEq for UnionRepresentation_Keyed {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for UnionRepresentation_Keyed {
        #[inline]
        fn eq(&self, other: &UnionRepresentation_Keyed) -> bool {
            match *other {
                UnionRepresentation_Keyed(ref __self_1_0) => match *self {
                    UnionRepresentation_Keyed(ref __self_0_0) => (*__self_0_0) == (*__self_1_0),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &UnionRepresentation_Keyed) -> bool {
            match *other {
                UnionRepresentation_Keyed(ref __self_1_0) => match *self {
                    UnionRepresentation_Keyed(ref __self_0_0) => (*__self_0_0) != (*__self_1_0),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialOrd for UnionRepresentation_Keyed {
        #[inline]
        fn partial_cmp(
            &self,
            other: &UnionRepresentation_Keyed,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match *other {
                UnionRepresentation_Keyed(ref __self_1_0) => match *self {
                    UnionRepresentation_Keyed(ref __self_0_0) => {
                        match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0), &(*__self_1_0)) {
                            ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                            }
                            cmp => cmp,
                        }
                    }
                },
            }
        }
        #[inline]
        fn lt(&self, other: &UnionRepresentation_Keyed) -> bool {
            match *other {
                UnionRepresentation_Keyed(ref __self_1_0) => match *self {
                    UnionRepresentation_Keyed(ref __self_0_0) => {
                        ::core::option::Option::unwrap_or(
                            ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0), &(*__self_1_0)),
                            ::core::cmp::Ordering::Greater,
                        ) == ::core::cmp::Ordering::Less
                    }
                },
            }
        }
        #[inline]
        fn le(&self, other: &UnionRepresentation_Keyed) -> bool {
            match *other {
                UnionRepresentation_Keyed(ref __self_1_0) => match *self {
                    UnionRepresentation_Keyed(ref __self_0_0) => {
                        ::core::option::Option::unwrap_or(
                            ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0), &(*__self_1_0)),
                            ::core::cmp::Ordering::Greater,
                        ) != ::core::cmp::Ordering::Greater
                    }
                },
            }
        }
        #[inline]
        fn gt(&self, other: &UnionRepresentation_Keyed) -> bool {
            match *other {
                UnionRepresentation_Keyed(ref __self_1_0) => match *self {
                    UnionRepresentation_Keyed(ref __self_0_0) => {
                        ::core::option::Option::unwrap_or(
                            ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0), &(*__self_1_0)),
                            ::core::cmp::Ordering::Less,
                        ) == ::core::cmp::Ordering::Greater
                    }
                },
            }
        }
        #[inline]
        fn ge(&self, other: &UnionRepresentation_Keyed) -> bool {
            match *other {
                UnionRepresentation_Keyed(ref __self_1_0) => match *self {
                    UnionRepresentation_Keyed(ref __self_0_0) => {
                        ::core::option::Option::unwrap_or(
                            ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0), &(*__self_1_0)),
                            ::core::cmp::Ordering::Less,
                        ) != ::core::cmp::Ordering::Less
                    }
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for UnionRepresentation_Keyed {
        #[inline]
        fn clone(&self) -> UnionRepresentation_Keyed {
            match *self {
                UnionRepresentation_Keyed(ref __self_0_0) => {
                    UnionRepresentation_Keyed(::core::clone::Clone::clone(&(*__self_0_0)))
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for UnionRepresentation_Keyed {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                UnionRepresentation_Keyed(ref __self_0_0) => {
                    let mut debug_trait_builder = f.debug_tuple("UnionRepresentation_Keyed");
                    let _ = debug_trait_builder.field(&&(*__self_0_0));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    impl proptest::arbitrary::Arbitrary for UnionRepresentation_Keyed {
        type Parameters = ();
        type Strategy = proptest::strategy::BoxedStrategy<Self>;
        fn arbitrary_with(args: Self::Parameters) -> Self::Strategy {
            #[allow(dead_code)]
            fn _to_fn_ptr<T>(f: fn(&T) -> bool) -> fn(&T) -> bool {
                f
            }
            let args = std::rc::Rc::new(args);
            proptest::strategy::Strategy::boxed({
                let strategy_0 = ({
                    #[allow(dead_code)]
                    fn _strategy_of_0<
                        T: std::fmt::Debug,
                        S: proptest::strategy::Strategy<Value = T>,
                    >(
                        s: S,
                    ) -> impl proptest::strategy::Strategy<Value = T> {
                        s
                    }
                    let _s = proptest::arbitrary::any::<Map<String, TypeName>>();
                    _s
                },);
                let strategy_0 =
                    proptest::strategy::Strategy::prop_map(strategy_0, |_values| Self(_values.0));
                strategy_0
            })
        }
    }
    struct UnionRepresentation_Kinded(Map<RepresentationKind, TypeName>);
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for UnionRepresentation_Kinded {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                _serde::Serializer::serialize_newtype_struct(
                    __serializer,
                    "UnionRepresentation_Kinded",
                    &self.0,
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for UnionRepresentation_Kinded {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                struct __Visitor<'de> {
                    marker: _serde::export::PhantomData<UnionRepresentation_Kinded>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = UnionRepresentation_Kinded;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(
                            __formatter,
                            "tuple struct UnionRepresentation_Kinded",
                        )
                    }
                    #[inline]
                    fn visit_newtype_struct<__E>(
                        self,
                        __e: __E,
                    ) -> _serde::export::Result<Self::Value, __E::Error>
                    where
                        __E: _serde::Deserializer<'de>,
                    {
                        let __field0: Map<RepresentationKind, TypeName> = match <Map<
                            RepresentationKind,
                            TypeName,
                        > as _serde::Deserialize>::deserialize(
                            __e
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        _serde::export::Ok(UnionRepresentation_Kinded(__field0))
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                            Map<RepresentationKind, TypeName>,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    0usize,
                                    &"tuple struct UnionRepresentation_Kinded with 1 element",
                                ));
                            }
                        };
                        _serde::export::Ok(UnionRepresentation_Kinded(__field0))
                    }
                }
                _serde::Deserializer::deserialize_newtype_struct(
                    __deserializer,
                    "UnionRepresentation_Kinded",
                    __Visitor {
                        marker: _serde::export::PhantomData::<UnionRepresentation_Kinded>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    impl ::core::marker::StructuralPartialEq for UnionRepresentation_Kinded {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for UnionRepresentation_Kinded {
        #[inline]
        fn eq(&self, other: &UnionRepresentation_Kinded) -> bool {
            match *other {
                UnionRepresentation_Kinded(ref __self_1_0) => match *self {
                    UnionRepresentation_Kinded(ref __self_0_0) => (*__self_0_0) == (*__self_1_0),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &UnionRepresentation_Kinded) -> bool {
            match *other {
                UnionRepresentation_Kinded(ref __self_1_0) => match *self {
                    UnionRepresentation_Kinded(ref __self_0_0) => (*__self_0_0) != (*__self_1_0),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialOrd for UnionRepresentation_Kinded {
        #[inline]
        fn partial_cmp(
            &self,
            other: &UnionRepresentation_Kinded,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match *other {
                UnionRepresentation_Kinded(ref __self_1_0) => match *self {
                    UnionRepresentation_Kinded(ref __self_0_0) => {
                        match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0), &(*__self_1_0)) {
                            ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                            }
                            cmp => cmp,
                        }
                    }
                },
            }
        }
        #[inline]
        fn lt(&self, other: &UnionRepresentation_Kinded) -> bool {
            match *other {
                UnionRepresentation_Kinded(ref __self_1_0) => match *self {
                    UnionRepresentation_Kinded(ref __self_0_0) => {
                        ::core::option::Option::unwrap_or(
                            ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0), &(*__self_1_0)),
                            ::core::cmp::Ordering::Greater,
                        ) == ::core::cmp::Ordering::Less
                    }
                },
            }
        }
        #[inline]
        fn le(&self, other: &UnionRepresentation_Kinded) -> bool {
            match *other {
                UnionRepresentation_Kinded(ref __self_1_0) => match *self {
                    UnionRepresentation_Kinded(ref __self_0_0) => {
                        ::core::option::Option::unwrap_or(
                            ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0), &(*__self_1_0)),
                            ::core::cmp::Ordering::Greater,
                        ) != ::core::cmp::Ordering::Greater
                    }
                },
            }
        }
        #[inline]
        fn gt(&self, other: &UnionRepresentation_Kinded) -> bool {
            match *other {
                UnionRepresentation_Kinded(ref __self_1_0) => match *self {
                    UnionRepresentation_Kinded(ref __self_0_0) => {
                        ::core::option::Option::unwrap_or(
                            ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0), &(*__self_1_0)),
                            ::core::cmp::Ordering::Less,
                        ) == ::core::cmp::Ordering::Greater
                    }
                },
            }
        }
        #[inline]
        fn ge(&self, other: &UnionRepresentation_Kinded) -> bool {
            match *other {
                UnionRepresentation_Kinded(ref __self_1_0) => match *self {
                    UnionRepresentation_Kinded(ref __self_0_0) => {
                        ::core::option::Option::unwrap_or(
                            ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0), &(*__self_1_0)),
                            ::core::cmp::Ordering::Less,
                        ) != ::core::cmp::Ordering::Less
                    }
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for UnionRepresentation_Kinded {
        #[inline]
        fn clone(&self) -> UnionRepresentation_Kinded {
            match *self {
                UnionRepresentation_Kinded(ref __self_0_0) => {
                    UnionRepresentation_Kinded(::core::clone::Clone::clone(&(*__self_0_0)))
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for UnionRepresentation_Kinded {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                UnionRepresentation_Kinded(ref __self_0_0) => {
                    let mut debug_trait_builder = f.debug_tuple("UnionRepresentation_Kinded");
                    let _ = debug_trait_builder.field(&&(*__self_0_0));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    impl proptest::arbitrary::Arbitrary for UnionRepresentation_Kinded {
        type Parameters = ();
        type Strategy = proptest::strategy::BoxedStrategy<Self>;
        fn arbitrary_with(args: Self::Parameters) -> Self::Strategy {
            #[allow(dead_code)]
            fn _to_fn_ptr<T>(f: fn(&T) -> bool) -> fn(&T) -> bool {
                f
            }
            let args = std::rc::Rc::new(args);
            proptest::strategy::Strategy::boxed({
                let strategy_0 = ({
                    #[allow(dead_code)]
                    fn _strategy_of_0<
                        T: std::fmt::Debug,
                        S: proptest::strategy::Strategy<Value = T>,
                    >(
                        s: S,
                    ) -> impl proptest::strategy::Strategy<Value = T> {
                        s
                    }
                    let _s = proptest::arbitrary::any::<Map<RepresentationKind, TypeName>>();
                    _s
                },);
                let strategy_0 =
                    proptest::strategy::Strategy::prop_map(strategy_0, |_values| Self(_values.0));
                strategy_0
            })
        }
    }
    #[cfg(test)]
    mod generated_tests {
        extern crate test;
        #[cfg(test)]
        #[rustc_test_marker]
        pub const macro_snapshot: test::TestDescAndFn = test::TestDescAndFn {
            desc: test::TestDesc {
                name: test::StaticTestName("macro_test::generated_tests::macro_snapshot"),
                ignore: false,
                allow_fail: false,
                should_panic: test::ShouldPanic::No,
                test_type: test::TestType::UnitTest,
            },
            testfn: test::StaticTestFn(|| test::assert_test_result(macro_snapshot())),
        };
        fn macro_snapshot() {
            let manifest = "/home/sage/w/ipld-schema/data-validation/ipld-schema/Cargo.toml";
            let parent_module = "ipld_schema::macro_test::generated_tests"
                .strip_prefix("ipld_schema")
                .unwrap()
                .strip_suffix("::generated_tests")
                .unwrap();
            :: insta :: _macro_support :: assert_snapshot (:: insta :: _macro_support :: AutoName . into () , & String :: from_utf8_lossy (& std :: process :: Command :: new ("cargo") . args (& ["expand" , "--manifest-path" , manifest , "--lib" , "--tests" , parent_module]) . output () . unwrap () . stdout) , "/home/sage/w/ipld-schema/data-validation/ipld-schema" , "ipld_schema::macro_test::generated_tests" , "ipld-schema/src/macro_test.rs" , 4u32 , "String::from_utf8_lossy(&std::process::Command::new(\"cargo\").args(&[\"expand\",\n                                                                    \"--manifest-path\",\n                                                                    manifest,\n                                                                    \"--lib\",\n                                                                    \"--tests\",\n                                                                    parent_module]).output().unwrap().stdout)") . unwrap () ;
        }
    }
}

