{"files":[{"path":["/","home","sage","w","ipld-schema","proptest","src","lib.rs"],"content":"#![deny(clippy::all)]\n#![deny(clippy::pedantic)]\n\npub mod schema;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","sage","w","ipld-schema","proptest","src","schema.rs"],"content":"#![allow(dead_code)]\n\nuse serde::{Deserialize, Serialize};\nuse std::fmt;\n\n#[cfg(test)]\nuse proptest::{collection::btree_map, prelude::*};\n\n#[cfg(all(test, feature = \"fast-test\"))]\nconst DEFAULT_SIZE_RANGE: std::ops::RangeInclusive<usize> = 0..=10;\n#[cfg(all(test, not(feature = \"fast-test\")))]\nconst DEFAULT_SIZE_RANGE: std::ops::RangeInclusive<usize> = 0..=100;\n\ntype Int = i64;\ntype Float = f64;\ntype Map<K, V> = std::collections::BTreeMap<K, V>;\n\n// TODO: revisit public API\n\n// TODO: docs\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]\n#[cfg_attr(test, derive(test_strategy::Arbitrary))]\nstruct Null;\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]\n#[cfg_attr(test, derive(test_strategy::Arbitrary))]\npub(crate) struct TypeName(#[cfg_attr(test, strategy(\"[A-Z][a-z0-9_]*\"))] String);\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]\n#[cfg_attr(test, derive(test_strategy::Arbitrary))]\nstruct SchemaMap(\n    // TODO: increase size range\n    #[cfg_attr(test, strategy(btree_map(any::<TypeName>(), any::<Type>(), DEFAULT_SIZE_RANGE)))]\n    Map<TypeName, Type>,\n);\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]\n#[cfg_attr(test, derive(test_strategy::Arbitrary))]\npub(crate) struct AdvancedDataLayoutName(String);\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Default)]\n#[cfg_attr(test, derive(test_strategy::Arbitrary))]\npub(crate) struct AdvancedDataLayoutMap(\n    #[cfg_attr(test, strategy(Just(Map::new())))] Map<AdvancedDataLayoutName, AdvancedDataLayout>,\n);\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]\n#[serde(rename_all = \"camelCase\")]\n#[cfg_attr(test, derive(test_strategy::Arbitrary))]\npub(crate) struct Schema {\n    types: SchemaMap,\n    #[serde(default, skip_serializing_if = \"is_default\")]\n    advanced: AdvancedDataLayoutMap,\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]\n#[serde(tag = \"kind\", rename_all = \"lowercase\")]\n#[cfg_attr(test, derive(test_strategy::Arbitrary))]\n// TODO: can't handle some variants until fields referred to by representation exist and field orders matches set of fields\npub(crate) enum Type {\n    Bool(TypeBool),\n    String(TypeString),\n    Bytes(TypeBytes),\n    Int(TypeInt),\n    Float(TypeFloat),\n    Map(TypeMap),\n    List(TypeList),\n    Link(TypeLink),\n    Union(TypeUnion),\n    #[cfg_attr(test, weight(0))]\n    Struct(TypeStruct),\n    #[cfg_attr(test, weight(0))]\n    Enum(TypeEnum),\n    Copy(TypeCopy),\n}\n\n/*\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]\n#[serde(rename_all = \"lowercase\")]\n#[cfg_attr(test, derive(test_strategy::Arbitrary))]\npub(crate) enum TypeKind {\n    Bool,\n    String,\n    Bytes,\n    Int,\n    Float,\n    Map,\n    List,\n    Link,\n    Union,\n    Struct,\n    Enum,\n}\n*/\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]\n#[serde(rename_all = \"lowercase\")]\n#[cfg_attr(test, derive(test_strategy::Arbitrary))]\npub(crate) enum RepresentationKind {\n    Bool,\n    String,\n    Bytes,\n    Int,\n    Float,\n    Map,\n    List,\n    Link,\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]\n#[serde(untagged)]\n#[cfg_attr(test, derive(test_strategy::Arbitrary))]\npub(crate) enum AnyScalar {\n    Bool(bool),\n    String(String),\n    Bytes(Vec<u8>),\n    Int(Int),\n    Float(Float),\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]\n#[cfg_attr(test, derive(test_strategy::Arbitrary))]\nstruct AdvancedDataLayout;\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]\n#[cfg_attr(test, derive(test_strategy::Arbitrary))]\npub(crate) struct TypeBool;\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]\n#[cfg_attr(test, derive(test_strategy::Arbitrary))]\npub(crate) struct TypeString;\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]\n#[cfg_attr(test, derive(test_strategy::Arbitrary))]\npub(crate) struct TypeBytes {\n    representation: BytesRepresentation,\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]\n#[serde(rename_all = \"lowercase\")]\n#[cfg_attr(test, derive(test_strategy::Arbitrary))]\n// TODO: generate all variants\nenum BytesRepresentation {\n    Bytes(bytes_representation::Bytes),\n    #[cfg_attr(test, weight(0))]\n    Advanced(AdvancedDataLayoutName),\n}\n\nmod bytes_representation {\n    use serde::{Deserialize, Serialize};\n\n    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]\n    #[cfg_attr(test, derive(test_strategy::Arbitrary))]\n    pub(crate) struct Bytes;\n}\n\nimpl Default for BytesRepresentation {\n    fn default() -> Self {\n        Self::Bytes(bytes_representation::Bytes)\n    }\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]\n#[cfg_attr(test, derive(test_strategy::Arbitrary))]\npub(crate) struct TypeInt;\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]\n#[cfg_attr(test, derive(test_strategy::Arbitrary))]\npub(crate) struct TypeFloat;\n\nfn is_default<D: Default + PartialEq>(d: &D) -> bool {\n    *d == D::default()\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]\n#[serde(rename_all = \"camelCase\")]\n#[cfg_attr(test, derive(test_strategy::Arbitrary))]\npub(crate) struct TypeMap {\n    key_type: TypeName,\n\n    value_type: TypeTerm,\n\n    #[serde(default, skip_serializing_if = \"is_default\")]\n    value_nullable: bool,\n\n    #[serde(default, skip_serializing_if = \"is_default\")]\n    representation: MapRepresentation,\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]\n#[serde(rename_all = \"lowercase\")]\n#[cfg_attr(test, derive(test_strategy::Arbitrary))]\n// TODO: generate all variants\nenum MapRepresentation {\n    Map(map_representation::Map),\n    StringPairs(map_representation::StringPairs),\n    ListPairs(map_representation::ListPairs),\n    #[cfg_attr(test, weight(0))]\n    Advanced(AdvancedDataLayoutName),\n}\n\nmod map_representation {\n    use serde::{Deserialize, Serialize};\n\n    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]\n    #[cfg_attr(test, derive(test_strategy::Arbitrary))]\n    pub(crate) struct Map;\n\n    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]\n    #[serde(rename_all = \"camelCase\")]\n    #[cfg_attr(test, derive(test_strategy::Arbitrary))]\n    pub(crate) struct StringPairs {\n        #[cfg_attr(test, strategy(\"[^\\\"]+\"))]\n        pub(crate) inner_delim: String,\n\n        #[cfg_attr(test, strategy(\"[^\\\"]+\"))]\n        pub(crate) entry_delim: String,\n    }\n\n    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]\n    #[cfg_attr(test, derive(test_strategy::Arbitrary))]\n    pub(crate) struct ListPairs;\n}\n\nimpl Default for MapRepresentation {\n    fn default() -> Self {\n        Self::Map(map_representation::Map)\n    }\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]\n#[serde(rename_all = \"camelCase\")]\n#[cfg_attr(test, derive(test_strategy::Arbitrary))]\npub(crate) struct TypeList {\n    value_type: TypeTerm,\n\n    #[serde(default, skip_serializing_if = \"is_default\")]\n    value_nullable: bool,\n\n    #[serde(default, skip_serializing_if = \"is_default\")]\n    representation: ListRepresentation,\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]\n#[cfg_attr(test, derive(test_strategy::Arbitrary))]\nenum ListRepresentation {\n    List(list_representation::List),\n    #[cfg_attr(test, weight(0))]\n    Advanced(AdvancedDataLayoutName),\n}\n\nmod list_representation {\n    use serde::{Deserialize, Serialize};\n\n    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]\n    #[cfg_attr(test, derive(test_strategy::Arbitrary))]\n    pub(crate) struct List;\n}\n\nimpl Default for ListRepresentation {\n    fn default() -> Self {\n        Self::List(list_representation::List)\n    }\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]\n#[serde(rename_all = \"camelCase\")]\n#[cfg_attr(test, derive(test_strategy::Arbitrary))]\npub(crate) struct TypeLink {\n    #[cfg_attr(test, strategy(\"[A-Z][a-z0-9_]*\"))]\n    expected_type: String,\n}\n\nimpl Default for TypeLink {\n    fn default() -> Self {\n        Self {\n            expected_type: \"Any\".to_string(),\n        }\n    }\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]\n#[serde(rename_all = \"camelCase\")]\n#[cfg_attr(test, derive(test_strategy::Arbitrary))]\npub(crate) struct TypeUnion {\n    representation: UnionRepresentation,\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]\n#[serde(rename_all = \"lowercase\")]\n#[cfg_attr(test, derive(test_strategy::Arbitrary))]\nenum UnionRepresentation {\n    Kinded(union_representation::Kinded),\n    Keyed(union_representation::Keyed),\n    Envelope(union_representation::Envelope),\n    Inline(union_representation::Inline),\n    BytePrefix(union_representation::BytePrefix),\n}\n\nmod union_representation {\n    use super::{Map, RepresentationKind, TypeName};\n    use serde::{Deserialize, Serialize};\n\n    #[cfg(test)]\n    use super::DEFAULT_SIZE_RANGE;\n\n    #[cfg(test)]\n    use proptest::{collection::btree_map, prelude::any};\n\n    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]\n    #[cfg_attr(test, derive(test_strategy::Arbitrary))]\n    pub(crate) struct Kinded(pub(crate) Map<RepresentationKind, TypeName>);\n\n    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]\n    #[cfg_attr(test, derive(test_strategy::Arbitrary))]\n    pub(crate) struct Keyed(\n        #[cfg_attr(test, strategy(btree_map(\"[^\\\"]*\", any::<TypeName>(), DEFAULT_SIZE_RANGE)))]\n        pub(crate) Map<String, TypeName>,\n    );\n\n    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]\n    #[serde(rename_all = \"camelCase\")]\n    #[cfg_attr(test, derive(test_strategy::Arbitrary))]\n    pub(crate) struct Envelope {\n        #[cfg_attr(test, strategy(\"[^\\\"]*\"))]\n        pub(crate) discriminant_key: String,\n\n        #[cfg_attr(test, strategy(\"[^\\\"]*\"))]\n        pub(crate) content_key: String,\n\n        #[cfg_attr(test, strategy(btree_map(\"[^\\\"]*\", any::<TypeName>(), DEFAULT_SIZE_RANGE)))]\n        pub(crate) discriminant_table: Map<String, TypeName>,\n    }\n\n    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]\n    #[serde(rename_all = \"camelCase\")]\n    #[cfg_attr(test, derive(test_strategy::Arbitrary))]\n    pub(crate) struct Inline {\n        #[cfg_attr(test, strategy(\"[^\\\"]*\"))]\n        pub(crate) discriminant_key: String,\n\n        #[cfg_attr(test, strategy(btree_map(\"[^\\\"]*\", any::<TypeName>(), DEFAULT_SIZE_RANGE)))]\n        pub(crate) discriminant_table: Map<String, TypeName>,\n    }\n\n    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]\n    #[serde(rename_all = \"camelCase\")]\n    #[cfg_attr(test, derive(test_strategy::Arbitrary))]\n    pub(crate) struct BytePrefix {\n        #[cfg_attr(test, strategy(btree_map(any::<TypeName>(), any::<u8>(), DEFAULT_SIZE_RANGE)))]\n        pub(crate) discriminant_table: Map<TypeName, u8>,\n    }\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]\n#[serde(rename_all = \"camelCase\")]\n#[cfg_attr(test, derive(test_strategy::Arbitrary))]\npub(crate) struct TypeStruct {\n    // TODO: increase size range\n    #[cfg_attr(test, strategy(btree_map(any::<FieldName>(), any::<StructField>(), DEFAULT_SIZE_RANGE)))]\n    fields: Map<FieldName, StructField>,\n    representation: StructRepresentation,\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]\n#[cfg_attr(test, derive(test_strategy::Arbitrary))]\npub(crate) struct FieldName(#[cfg_attr(test, strategy(\"[a-zA-Z0-9_]+\"))] String);\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]\n#[serde(rename_all = \"camelCase\")]\n#[cfg_attr(test, derive(test_strategy::Arbitrary))]\nstruct StructField {\n    r#type: TypeTerm,\n\n    #[serde(default, skip_serializing_if = \"is_default\")]\n    optional: bool,\n\n    #[serde(default, skip_serializing_if = \"is_default\")]\n    nullable: bool,\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]\n#[serde(untagged)]\n#[cfg_attr(test, derive(test_strategy::Arbitrary))]\n// TODO: allow all variants; may require proptest's prop_recursive strategy\npub(crate) enum TypeTerm {\n    TypeName(TypeName),\n    #[cfg_attr(test, weight(0))]\n    InlineDefn(Box<InlineDefn>),\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]\n#[serde(tag = \"kind\", rename_all = \"lowercase\")]\n#[cfg_attr(test, derive(test_strategy::Arbitrary))]\npub(crate) enum InlineDefn {\n    Map(TypeMap),\n    List(TypeList),\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]\n#[serde(rename_all = \"lowercase\")]\n#[cfg_attr(test, derive(test_strategy::Arbitrary))]\n// TODO: generate all variants\n// TODO: all FieldNames generated here should correspond to one of TypeStruct's fields\nenum StructRepresentation {\n    Map(struct_representation::Map),\n    Tuple(struct_representation::Tuple),\n    StringPairs(struct_representation::StringPairs),\n\n    // can't handle this variant until field order matches set of fields\n    #[cfg_attr(test, weight(0))]\n    StringJoin(struct_representation::StringJoin),\n    ListPairs(struct_representation::ListPairs),\n}\n\nmod struct_representation {\n    use super::{AnyScalar, FieldName};\n    use serde::{Deserialize, Serialize};\n\n    #[cfg(test)]\n    use super::DEFAULT_SIZE_RANGE;\n\n    #[cfg(test)]\n    use proptest::{collection::btree_map, prelude::any};\n\n    #[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]\n    #[serde(rename_all = \"camelCase\")]\n    #[cfg_attr(test, derive(test_strategy::Arbitrary))]\n    pub(crate) struct Map {\n        #[serde(default)]\n        #[cfg_attr(test, strategy(btree_map(any::<FieldName>(), any::<MapFieldDetails>(), DEFAULT_SIZE_RANGE)))]\n        pub(crate) fields: super::Map<FieldName, MapFieldDetails>,\n    }\n\n    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]\n    #[serde(rename_all = \"camelCase\")]\n    #[cfg_attr(test, derive(test_strategy::Arbitrary))]\n    pub(crate) struct MapFieldDetails {\n        pub(crate) rename: Option<String>,\n        pub(crate) implicit: Option<AnyScalar>,\n    }\n\n    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]\n    #[serde(rename_all = \"camelCase\")]\n    #[cfg_attr(test, derive(test_strategy::Arbitrary))]\n    pub(crate) struct Tuple {\n        // TODO: remove Option\n        pub(crate) field_order: Option<Vec<FieldName>>,\n    }\n\n    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]\n    #[serde(rename_all = \"camelCase\")]\n    #[cfg_attr(test, derive(test_strategy::Arbitrary))]\n    pub(crate) struct StringPairs {\n        #[cfg_attr(test, strategy(\"[^\\\"]+\"))]\n        pub(crate) inner_delim: String,\n\n        #[cfg_attr(test, strategy(\"[^\\\"]+\"))]\n        pub(crate) entry_delim: String,\n    }\n\n    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]\n    #[serde(rename_all = \"camelCase\")]\n    #[cfg_attr(test, derive(test_strategy::Arbitrary))]\n    pub(crate) struct StringJoin {\n        #[cfg_attr(test, strategy(\"[^\\\"]+\"))]\n        pub(crate) join: String,\n\n        pub(crate) field_order: Vec<FieldName>,\n    }\n\n    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]\n    #[cfg_attr(test, derive(test_strategy::Arbitrary))]\n    pub(crate) struct ListPairs;\n}\n\nimpl Default for StructRepresentation {\n    fn default() -> Self {\n        Self::Map(struct_representation::Map::default())\n    }\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]\n#[cfg_attr(test, derive(test_strategy::Arbitrary))]\npub(crate) struct TypeEnum {\n    #[cfg_attr(test, strategy(btree_map(any::<EnumValue>(), any::<Null>(), DEFAULT_SIZE_RANGE)))]\n    members: Map<EnumValue, Null>,\n    representation: EnumRepresentation,\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]\n#[cfg_attr(test, derive(test_strategy::Arbitrary))]\npub(crate) struct EnumValue(#[cfg_attr(test, strategy(\"[a-z0-9_]+\"))] String);\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]\n#[serde(rename_all = \"lowercase\")]\n#[cfg_attr(test, derive(test_strategy::Arbitrary))]\nenum EnumRepresentation {\n    String(enum_representation::String),\n    #[cfg_attr(test, weight(0))]\n    Int(enum_representation::Int),\n}\n\nmod enum_representation {\n    use super::{EnumValue, Map};\n    use serde::{Deserialize, Serialize};\n\n    #[cfg(test)]\n    use super::DEFAULT_SIZE_RANGE;\n\n    #[cfg(test)]\n    use proptest::{collection::btree_map, prelude::*};\n\n    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Default)]\n    #[cfg_attr(test, derive(test_strategy::Arbitrary))]\n    pub(crate) struct String(\n        #[cfg_attr(test, strategy(btree_map(any::<EnumValue>(), \"[^\\\"]*\", DEFAULT_SIZE_RANGE)))]\n        Map<EnumValue, std::string::String>,\n    );\n\n    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Default)]\n    #[cfg_attr(test, derive(test_strategy::Arbitrary))]\n    pub(crate) struct Int(\n        #[cfg_attr(test, strategy(btree_map(any::<EnumValue>(), any::<Int>(), DEFAULT_SIZE_RANGE)))]\n         Map<EnumValue, Int>,\n    );\n}\n\nimpl Default for EnumRepresentation {\n    fn default() -> Self {\n        Self::String(enum_representation::String::default())\n    }\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]\n#[cfg_attr(test, derive(test_strategy::Arbitrary))]\npub(crate) struct TypeCopy {\n    from_type: TypeName,\n}\n\nconst L_BOOL: &str = \"bool\";\nconst L_STRING: &str = \"string\";\nconst L_BYTES: &str = \"bytes\";\nconst L_INT: &str = \"int\";\nconst L_FLOAT: &str = \"float\";\nconst L_MAP: &str = \"map\";\nconst L_LIST: &str = \"list\";\nconst L_LINK: &str = \"link\";\nconst L_UNION: &str = \"union\";\nconst L_STRUCT: &str = \"struct\";\nconst L_ENUM: &str = \"enum\";\n\nconst L_TYPE: &str = \"type\";\nconst L_OPTIONAL: &str = \"optional\";\nconst L_NULLABLE: &str = \"nullable\";\nconst L_LINK_REF: &str = \"&\";\nconst L_COPY: &str = \"=\";\nconst L_REPRESENTATION: &str = \"representation\";\nconst L_KINDED: &str = \"kinded\";\nconst L_KEYED: &str = \"keyed\";\nconst L_ENVELOPE: &str = \"envelope\";\nconst L_INLINE: &str = \"inline\";\nconst L_TUPLE: &str = \"tuple\";\nconst L_STRINGPAIRS: &str = \"stringpairs\";\nconst L_STRINGJOIN: &str = \"stringjoin\";\nconst L_LISTPAIRS: &str = \"listpairs\";\nconst L_DISCRIMINANT_KEY: &str = \"discriminantKey\";\nconst L_CONTENT_KEY: &str = \"contentKey\";\nconst L_IMPLICIT: &str = \"implicit\";\nconst L_BYTEPREFIX: &str = \"byteprefix\";\n\nimpl fmt::Display for TypeName {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> Result<(), fmt::Error> {\n        write!(f, \"{}\", self.0)\n    }\n}\n\nimpl fmt::Display for SchemaMap {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> Result<(), fmt::Error> {\n        for (name, ty) in &self.0 {\n            write!(f, \"{} {} {}\\n\\n\", L_TYPE, name, ty)?;\n        }\n        Ok(())\n    }\n}\n\nimpl fmt::Display for Schema {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> Result<(), fmt::Error> {\n        // TODO: self.advanced\n        write!(f, \"{}\", &self.types)\n    }\n}\n\nimpl fmt::Display for Type {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> Result<(), fmt::Error> {\n        match self {\n            Self::Bool(x) => write!(f, \"{}\", x),\n            Self::String(x) => write!(f, \"{}\", x),\n            Self::Bytes(x) => write!(f, \"{}\", x),\n            Self::Int(x) => write!(f, \"{}\", x),\n            Self::Float(x) => write!(f, \"{}\", x),\n            Self::Map(x) => write!(f, \"{}\", x),\n            Self::List(x) => write!(f, \"{}\", x),\n            Self::Link(x) => write!(f, \"{}\", x),\n            Self::Union(x) => write!(f, \"{}\", x),\n            Self::Struct(x) => write!(f, \"{}\", x),\n            Self::Enum(x) => write!(f, \"{}\", x),\n            Self::Copy(x) => write!(f, \"{}\", x),\n        }\n    }\n}\n\n/*\nimpl fmt::Display for TypeKind {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> Result<(), fmt::Error> {\n        match self {\n            Self::Bool => write!(f, \"{}\", L_BOOL),\n            Self::String => write!(f, \"{}\", L_STRING),\n            Self::Bytes => write!(f, \"{}\", L_BYTES),\n            Self::Int => write!(f, \"{}\", L_INT),\n            Self::Float => write!(f, \"{}\", L_FLOAT),\n            Self::Map => write!(f, \"{}\", L_MAP),\n            Self::List => write!(f, \"{}\", L_LIST),\n            Self::Link => write!(f, \"{}\", L_LINK),\n            Self::Union => write!(f, \"{}\", L_UNION),\n            Self::Struct => write!(f, \"{}\", L_STRUCT),\n            Self::Enum => write!(f, \"{}\", L_ENUM),\n        }\n    }\n}\n*/\n\nimpl fmt::Display for RepresentationKind {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> Result<(), fmt::Error> {\n        match self {\n            Self::Bool => write!(f, \"{}\", L_BOOL),\n            Self::String => write!(f, \"{}\", L_STRING),\n            Self::Bytes => write!(f, \"{}\", L_BYTES),\n            Self::Int => write!(f, \"{}\", L_INT),\n            Self::Float => write!(f, \"{}\", L_FLOAT),\n            Self::Map => write!(f, \"{}\", L_MAP),\n            Self::List => write!(f, \"{}\", L_LIST),\n            Self::Link => write!(f, \"{}\", L_LINK),\n        }\n    }\n}\n\nimpl fmt::Display for AnyScalar {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> Result<(), fmt::Error> {\n        match self {\n            Self::Bool(x) => write!(f, \"\\\"{}\\\"\", x),\n            Self::String(x) => write!(f, \"\\\"{}\\\"\", x),\n            Self::Bytes(_x) => todo!(\"literal bytes\"), // write!(f, \"{}\", x),\n            Self::Int(x) => write!(f, \"{}\", x),\n            Self::Float(x) => write!(f, \"{}\", x),\n        }\n    }\n}\n\nimpl fmt::Display for TypeBool {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> Result<(), fmt::Error> {\n        write!(f, \"{}\", L_BOOL)\n    }\n}\n\nimpl fmt::Display for TypeString {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> Result<(), fmt::Error> {\n        write!(f, \"{}\", L_STRING)\n    }\n}\n\nimpl fmt::Display for TypeBytes {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> Result<(), fmt::Error> {\n        write!(f, \"{}\", self.representation)\n    }\n}\n\nimpl fmt::Display for BytesRepresentation {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> Result<(), fmt::Error> {\n        match self {\n            Self::Bytes(b) => write!(f, \"{}\", b),\n            Self::Advanced(_name) => todo!(\"advanced layout for bytes\"),\n        }\n    }\n}\n\nimpl fmt::Display for bytes_representation::Bytes {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> Result<(), fmt::Error> {\n        write!(f, \"{}\", L_BYTES)\n    }\n}\n\nimpl fmt::Display for TypeInt {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> Result<(), fmt::Error> {\n        write!(f, \"{}\", L_INT)\n    }\n}\n\nimpl fmt::Display for TypeFloat {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> Result<(), fmt::Error> {\n        write!(f, \"{}\", L_FLOAT)\n    }\n}\n\nimpl fmt::Display for TypeMap {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> Result<(), fmt::Error> {\n        match &self.representation {\n            MapRepresentation::Map(_) => {\n                if self.value_nullable {\n                    write!(f, \"{} \", L_NULLABLE)?;\n                }\n                write!(f, \"{{{}:{}}}\", self.key_type, self.value_type)\n            }\n            MapRepresentation::StringPairs(sp) => {\n                if self.value_nullable {\n                    write!(f, \"{} \", L_NULLABLE)?;\n                }\n                writeln!(\n                    f,\n                    \"{{{}:{}}} {} {} {{\",\n                    self.key_type, self.value_type, L_REPRESENTATION, L_STRINGPAIRS\n                )?;\n                writeln!(f, \"  innerDelim \\\"{}\\\"\", sp.inner_delim)?;\n                writeln!(f, \"  entryDelim \\\"{}\\\"\", sp.entry_delim)?;\n                writeln!(f, \"}}\")\n            }\n            MapRepresentation::ListPairs(_) => {\n                if self.value_nullable {\n                    write!(f, \"{} \", L_NULLABLE)?;\n                }\n                writeln!(\n                    f,\n                    \"{{{}:{}}} representation listpairs\",\n                    self.key_type, self.value_type\n                )\n            }\n            MapRepresentation::Advanced(_) => todo!(),\n        }\n    }\n}\n\nimpl fmt::Display for TypeList {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> Result<(), fmt::Error> {\n        if self.value_nullable {\n            write!(f, \"{} \", L_NULLABLE)?;\n        }\n        write!(f, \"[{}]\", self.value_type)\n\n        // TODO: handle self.representation\n    }\n}\n\nimpl fmt::Display for TypeLink {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> Result<(), fmt::Error> {\n        write!(f, \"{}{}\", L_LINK_REF, self.expected_type)\n    }\n}\n\nimpl fmt::Display for TypeUnion {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> Result<(), fmt::Error> {\n        write!(f, \"{}\", self.representation)\n    }\n}\n\nimpl fmt::Display for UnionRepresentation {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> Result<(), fmt::Error> {\n        match self {\n            Self::Kinded(x) => write!(f, \"{}\", x),\n            Self::Keyed(x) => write!(f, \"{}\", x),\n            Self::Envelope(x) => write!(f, \"{}\", x),\n            Self::Inline(x) => write!(f, \"{}\", x),\n            Self::BytePrefix(x) => write!(f, \"{}\", x),\n        }\n    }\n}\n\nimpl fmt::Display for union_representation::Kinded {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> Result<(), fmt::Error> {\n        write!(f, \"{} {{\", L_UNION)?;\n        for (kind, name) in &self.0 {\n            write!(f, \"\\n  | {} {}\", name, kind)?;\n        }\n        if !self.0.is_empty() {\n            writeln!(f)?;\n        }\n        write!(f, \"}} {} {}\", L_REPRESENTATION, L_KINDED)\n    }\n}\n\nimpl fmt::Display for union_representation::Keyed {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> Result<(), fmt::Error> {\n        write!(f, \"{} {{\", L_UNION)?;\n        for (ty, name) in &self.0 {\n            write!(f, \"\\n  | {} \\\"{}\\\"\", name, ty)?;\n        }\n        if !self.0.is_empty() {\n            writeln!(f)?;\n        }\n        write!(f, \"}} {} {}\", L_REPRESENTATION, L_KEYED)\n    }\n}\n\nimpl fmt::Display for union_representation::Envelope {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> Result<(), fmt::Error> {\n        write!(f, \"{} {{\", L_UNION)?;\n        for (ty, name) in &self.discriminant_table {\n            write!(f, \"\\n  | {} \\\"{}\\\"\", name, ty)?;\n        }\n        if !self.discriminant_table.is_empty() {\n            writeln!(f)?;\n        }\n        writeln!(f, \"}} {} {} {{\", L_REPRESENTATION, L_ENVELOPE)?;\n        writeln!(f, \"  {} \\\"{}\\\"\", L_DISCRIMINANT_KEY, self.discriminant_key)?;\n        writeln!(f, \"  {} \\\"{}\\\"\", L_CONTENT_KEY, self.content_key)?;\n        writeln!(f, \"}}\")\n    }\n}\n\nimpl fmt::Display for union_representation::Inline {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> Result<(), fmt::Error> {\n        write!(f, \"{} {{\", L_UNION)?;\n        for (ty, name) in &self.discriminant_table {\n            write!(f, \"\\n  | {} \\\"{}\\\"\", name, ty)?;\n        }\n        if !self.discriminant_table.is_empty() {\n            writeln!(f)?;\n        }\n        write!(\n            f,\n            \"}} {} {} {{\\n  {} \\\"{}\\\"\\n}}\",\n            L_REPRESENTATION, L_INLINE, L_DISCRIMINANT_KEY, self.discriminant_key\n        )\n    }\n}\n\nimpl fmt::Display for union_representation::BytePrefix {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> Result<(), fmt::Error> {\n        write!(f, \"{} {{\", L_UNION)?;\n        for (ty, byte) in &self.discriminant_table {\n            write!(f, \"\\n  | {} {}\", ty, byte)?;\n        }\n        if !self.discriminant_table.is_empty() {\n            writeln!(f)?;\n        }\n        write!(f, \"}} {} {}\", L_REPRESENTATION, L_BYTEPREFIX)\n    }\n}\n\nimpl fmt::Display for TypeStruct {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> Result<(), fmt::Error> {\n        match &self.representation {\n            StructRepresentation::Map(m) => {\n                write!(f, \"{} {{\", L_STRUCT)?;\n                for (name, val) in &self.fields {\n                    write!(f, \"\\n  {} {}\", name, val)?;\n                    if let Some(details) = m.fields.get(name) {\n                        write!(f, \" (\")?;\n                        if let Some(implicit) = &details.implicit {\n                            write!(f, \"{} {}\", L_IMPLICIT, implicit)?;\n                        }\n                        write!(f, \")\")?;\n                    }\n                }\n                if !self.fields.is_empty() {\n                    writeln!(f)?;\n                }\n                write!(f, \"}}\")\n            }\n            StructRepresentation::Tuple(t) => {\n                write!(f, \"{} {{\", L_STRUCT)?;\n                for (name, val) in &self.fields {\n                    write!(f, \"\\n  {} {}\", name, val)?;\n                }\n                if !self.fields.is_empty() {\n                    writeln!(f)?;\n                }\n                write!(f, \"}} {} {}\", L_REPRESENTATION, L_TUPLE)?;\n                if let Some(field_order) = &t.field_order {\n                    writeln!(f, \" {{\")?;\n                    writeln!(\n                        f,\n                        \"  fieldOrder [{}]\",\n                        field_order\n                            .iter()\n                            .map(|f| format!(\"\\\"{}\\\"\", f))\n                            .collect::<Vec<_>>()\n                            .join(\", \")\n                    )?;\n                    writeln!(f, \"}}\")?;\n                }\n                Ok(())\n            }\n            StructRepresentation::StringPairs(sp) => {\n                write!(f, \"{} {{\", L_STRUCT)?;\n                for (name, val) in &self.fields {\n                    write!(f, \"\\n  {} {}\", name, val)?;\n                }\n                if !self.fields.is_empty() {\n                    writeln!(f)?;\n                }\n                writeln!(f, \"}} {} {} {{\", L_REPRESENTATION, L_STRINGPAIRS)?;\n                writeln!(f, \"  innerDelim \\\"{}\\\"\", sp.inner_delim)?;\n                writeln!(f, \"  entryDelim \\\"{}\\\"\", sp.entry_delim)?;\n                writeln!(f, \"}}\")\n            }\n            StructRepresentation::StringJoin(sj) => {\n                write!(f, \"{} {{\", L_STRUCT)?;\n                for (name, val) in &self.fields {\n                    write!(f, \"\\n  {} {}\", name, val)?;\n                }\n                if !self.fields.is_empty() {\n                    writeln!(f)?;\n                }\n                writeln!(f, \"}} {} {} {{\", L_REPRESENTATION, L_STRINGJOIN)?;\n                writeln!(f, \"  join \\\"{}\\\"\", sj.join)?;\n                writeln!(f, \"}}\")\n            }\n            StructRepresentation::ListPairs(_) => {\n                write!(f, \"{} {{\", L_STRUCT)?;\n                for (name, val) in &self.fields {\n                    write!(f, \"\\n  {} {}\", name, val)?;\n                }\n                if !self.fields.is_empty() {\n                    writeln!(f)?;\n                }\n                write!(f, \"}} {} {}\", L_REPRESENTATION, L_LISTPAIRS)\n            }\n        }\n    }\n}\n\nimpl fmt::Display for FieldName {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> Result<(), fmt::Error> {\n        write!(f, \"{}\", self.0)\n    }\n}\n\nimpl fmt::Display for StructField {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> Result<(), fmt::Error> {\n        if self.optional {\n            write!(f, \"{} \", L_OPTIONAL)?;\n        }\n        if self.nullable {\n            write!(f, \"{} \", L_NULLABLE)?;\n        }\n        write!(f, \"{}\", self.r#type)\n    }\n}\n\nimpl fmt::Display for TypeTerm {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> Result<(), fmt::Error> {\n        match self {\n            Self::TypeName(name) => write!(f, \"{}\", name),\n            Self::InlineDefn(inline) => write!(f, \"{}\", inline),\n        }\n    }\n}\n\nimpl fmt::Display for InlineDefn {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> Result<(), fmt::Error> {\n        match self {\n            Self::Map(map) => write!(f, \"{}\", map),\n            Self::List(list) => write!(f, \"{}\", list),\n        }\n    }\n}\n\nimpl fmt::Display for TypeEnum {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> Result<(), fmt::Error> {\n        write!(f, \"{} {{\", L_ENUM)?;\n        #[allow(clippy::for_kv_map)]\n        for (value, _null) in &self.members {\n            write!(f, \"\\n  | {}\", value)?;\n        }\n        if !self.members.is_empty() {\n            writeln!(f)?;\n        }\n        write!(f, \"}}\")\n\n        // TODO: handle self.representation\n    }\n}\n\nimpl fmt::Display for EnumValue {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> Result<(), fmt::Error> {\n        write!(f, \"{}\", self.0)\n    }\n}\n\nimpl fmt::Display for TypeCopy {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> Result<(), fmt::Error> {\n        write!(f, \"{} {}\", L_COPY, self.from_type)\n    }\n}\n\npeg::parser! {\n    grammar schema_dsl() for str {\n        rule _eof() -> () = ![_] { }\n        rule _eol() -> () = \"\\n\" / \"\\r\\n\" { }\n        rule _ws1() -> () = \" \" / \"\\t\" { }\n\n        rule _comment() -> String = _ws1()* \"#\" s:$((!_eol() [_])*) _eol() { s.to_string() }\n        rule _empty_line() -> () = _ws1()* _eol() { }\n        rule _ws_block() -> () = (_comment() / _empty_line())* _ws1()* { }\n\n        pub(crate) rule type_name() -> TypeName = cs:$(['A'..='Z'] (['A'..='Z'] / ['a'..='z'] / ['0'..='9'] / \"_\")*) { TypeName(cs.to_string()) }\n\n        rule schema_map() -> SchemaMap = _ws_block() decls:(type_decl() ** _ws_block()) _ws_block() _eof() { SchemaMap(decls.into_iter().collect()) }\n\n        // TODO: `advanced`\n        pub(crate) rule parse() -> Schema = types:schema_map() { Schema { types, advanced: AdvancedDataLayoutMap::default() } }\n\n        rule m_map() -> TypeMap\n            = nil:(\"nullable\" _ws1()+)? \"{\" _ws1()* n:type_name() _ws1()* \":\" _ws1()* t:type_term() \"}\"\n        {\n            TypeMap {\n                key_type: n,\n                value_type: t,\n                value_nullable: nil.is_some(),\n                representation: MapRepresentation::default()\n            }\n        }\n        rule m_stringpairs() -> TypeMap\n            = nil:(\"nullable\" _ws1()+)? \"{\" _ws1()* n:type_name() _ws1()* \":\" _ws1()* t:type_term() \"}\"\n              // TODO: support either field order\n              _ws1()* \"representation\" _ws1()+ \"stringpairs\" _ws1()* \"{\" _eol() _ws1()* \"innerDelim\" _ws1()+ id:string() _eol() _ws1()* \"entryDelim\" _ws1()+ ed:string() _ws_block() \"}\"\n        {\n            TypeMap {\n                key_type: n,\n                value_type: t,\n                value_nullable: nil.is_some(),\n                representation: MapRepresentation::StringPairs(map_representation::StringPairs { inner_delim: id, entry_delim: ed })\n            }\n        }\n        rule m_listpairs() -> TypeMap\n            = nil:(\"nullable\" _ws1()+)? \"{\" _ws1()* n:type_name() _ws1()* \":\" _ws1()* t:type_term() \"}\" _ws1()* \"representation\" _ws1()+ \"listpairs\"\n        {\n            TypeMap {\n                key_type: n,\n                value_type: t,\n                value_nullable: nil.is_some(),\n                representation: MapRepresentation::ListPairs(map_representation::ListPairs)\n            }\n        }\n        rule type_map() -> TypeMap = m:(\n            m_stringpairs() /\n            m_listpairs() /\n            m_map()\n        )\n\n        // TODO: nullable and non-default representation\n        rule type_list() -> TypeList = nil:(\"nullable\" _ws1()+)?  \"[\" _ws1()* t:type_term() _ws1()* \"]\" { TypeList { value_type: t, value_nullable: nil.is_some(), representation: ListRepresentation::default()} }\n\n        rule t_bool() -> Type = \"bool\" { Type::Bool(TypeBool) }\n        rule t_string() -> Type = \"string\" { Type::String(TypeString) }\n        rule t_bytes() -> Type = \"bytes\" { Type::Bytes(TypeBytes { representation: BytesRepresentation::default() }) }\n        rule t_int() -> Type = \"int\" { Type::Int(TypeInt) }\n        rule t_float() -> Type = \"float\" { Type::Float(TypeFloat) }\n        rule t_map() -> Type = m:type_map() { Type::Map(m) }\n        rule t_list() -> Type = l:type_list() { Type::List(l) }\n        rule t_link() -> Type = \"&\" t:type_name() { Type::Link(TypeLink { expected_type: t.to_string() }) }\n        rule t_union() -> Type = r:union_representation() { Type::Union(TypeUnion { representation: r }) }\n        rule t_struct() -> Type = s:struct_model() { Type::Struct(s) }\n        rule t_enum() -> Type = \"enum\" _ws1()* \"{\" _ws_block() ms:(enum_member()*) _ws_block() \"}\" { Type::Enum(TypeEnum { members: ms.into_iter().map(|m| (m, Null)).collect(), representation: EnumRepresentation::default() }) }\n        rule t_copy() -> Type = \"=\" _ws1()* n:type_name() { Type::Copy(TypeCopy { from_type: n }) }\n        rule r#type() -> Type = t:(\n            t_bool() /\n            t_string() /\n            t_bytes() /\n            t_int() /\n            t_float() /\n            t_map() /\n            t_list() /\n            t_link() /\n            t_union() /\n            t_struct() /\n            t_enum() /\n            t_copy()\n        ) { t }\n        pub(crate) rule schema_type() -> Type = t:r#type() { t }\n\n\n        rule union_representation() -> UnionRepresentation = ur:(\n            ur_kinded() /\n            ur_keyed() /\n            ur_envelope() /\n            ur_inline() /\n            ur_byteprefix()\n        ) { ur }\n        rule ur_kinded() -> UnionRepresentation = \"union\" _ws1()* \"{\" _ws_block() ts:(type_name_and_representation_kind()*) _ws1()* \"}\" _ws1()* \"representation\" _ws1()+ \"kinded\" _ws1()* (_eol() / _eof()) { UnionRepresentation::Kinded(union_representation::Kinded(ts.into_iter().map(|(tn, rk)| (rk, tn)).collect())) }\n        rule ur_keyed() -> UnionRepresentation = \"union\" _ws1()* \"{\" _ws_block() ts:(type_name_and_string()*) _ws1()* \"}\" _ws1()* \"representation\" _ws1()+ \"keyed\" _ws1()* (_eol() / _eof())  { UnionRepresentation::Keyed(union_representation::Keyed(ts.into_iter().map(|(tn, s)| (s, tn)).collect())) }\n        rule ur_envelope() -> UnionRepresentation = \"union\" _ws1()* \"{\" _ws_block() ts:(type_name_and_string()*) _ws1()* \"}\" _ws1()* \"representation\" _ws1()+ \"envelope\" _ws1()* \"{\" _ws_block() \"discriminantKey\" _ws1()+ dk:string() _ws_block() \"contentKey\" _ws1()+ ck:string() _ws_block() \"}\" (_eol() / _eof())  { UnionRepresentation::Envelope(union_representation::Envelope { discriminant_table: ts.into_iter().map(|(tn, s)| (s, tn)).collect(), discriminant_key: dk, content_key: ck }) }\n        rule ur_inline() -> UnionRepresentation = \"union\" _ws1()* \"{\" _ws_block() ts:(type_name_and_string()*) _ws1()* \"}\" _ws1()* \"representation\" _ws1()+ \"inline\" _ws1()* \"{\" _ws_block() \"discriminantKey\" _ws1()+ k:string() _ws_block() \"}\" (_eol() / _eof())  { UnionRepresentation::Inline(union_representation::Inline { discriminant_key: k, discriminant_table: ts.into_iter().map(|(tn, s)| (s, tn)).collect() }) }\n        rule ur_byteprefix() -> UnionRepresentation = \"union\" _ws1()* \"{\" _ws_block() ts:(type_name_and_byte()*) _ws1()* \"}\" _ws1()* \"representation\" _ws1()+ \"byteprefix\" (_eol() / _eof())  { UnionRepresentation::BytePrefix(union_representation::BytePrefix { discriminant_table: ts.into_iter().collect() }) }\n\n        rule type_name_and_string() -> (TypeName, String) = _ws1()* \"|\" _ws1()* t:type_name() _ws1()+ s:string() _ws1()* _eol() { (t, s) }\n        rule string() -> String = \"\\\"\" cs:$((!\"\\\"\" [_])*) \"\\\"\" { cs.to_string() }\n\n        rule type_name_and_byte() -> (TypeName, u8) = _ws1()* \"|\" _ws1()* s:type_name() _ws1()+ b:$(['0'..='9']+) _ws1()* _eol() { dbg!((s, b.parse().unwrap())) }\n\n        rule type_name_and_representation_kind() -> (TypeName, RepresentationKind) = _ws1()* \"|\" _ws1()* t:type_name() _ws1()+ r:representation_kind() _ws1()* _eol() { (t, r) }\n        rule rk_bool() -> RepresentationKind = \"bool\" { RepresentationKind::Bool }\n        rule rk_string() -> RepresentationKind = \"string\" { RepresentationKind::String }\n        rule rk_bytes() -> RepresentationKind = \"bytes\" { RepresentationKind::Bytes }\n        rule rk_int() -> RepresentationKind = \"int\" { RepresentationKind::Int }\n        rule rk_float() -> RepresentationKind = \"float\" { RepresentationKind::Float }\n        rule rk_map() -> RepresentationKind = \"map\" { RepresentationKind::Map }\n        rule rk_list() -> RepresentationKind = \"list\" { RepresentationKind::List }\n        rule rk_link() -> RepresentationKind = \"link\" { RepresentationKind::Link }\n        rule representation_kind() -> RepresentationKind = r:(\n            rk_bool() /\n            rk_string() /\n            rk_bytes() /\n            rk_int() /\n            rk_float() /\n            rk_map() /\n            rk_list() /\n            rk_link()\n        ) { r }\n\n        rule as_bool_false() -> AnyScalar = \"\\\"false\\\"\" { AnyScalar::Bool(false) }\n        rule as_bool_true() -> AnyScalar = \"\\\"true\\\"\" { AnyScalar::Bool(true) }\n        rule as_string() -> AnyScalar = s:string() { AnyScalar::String(s) }\n        rule as_bytes() -> AnyScalar = \"x\" { todo!() }\n        rule as_int() -> AnyScalar = \"x\" { todo!() }\n        rule as_float() -> AnyScalar = \"x\" { todo!() }\n        rule any_scalar() -> AnyScalar = a:(\n            as_bool_false() /\n            as_bool_true() /\n            as_string() /\n            as_bytes() /\n            as_int() /\n            as_float()\n        ) { a }\n\n\n        pub(crate) rule field_name() -> FieldName = cs:$((['A'..='Z'] / ['a'..='z'] / ['0'..='9'] / \"_\")+) { FieldName(cs.to_string()) }\n        rule quoted_field_name() -> FieldName = \"\\\"\" f:field_name() \"\\\"\" { f }\n        // TODO: support different ordering of optional and nullable\n        rule struct_field() -> StructField = o:(\"optional\" _ws1()+)? n:(\"nullable\" _ws1()+)? t:type_term() { StructField { r#type: t, optional: o.is_some(), nullable: n.is_some() } }\n\n        rule tt_type_name() -> TypeTerm = n:type_name() { TypeTerm::TypeName(n) }\n        rule id_map() -> InlineDefn = m:type_map() { InlineDefn::Map(m) }\n        rule id_list() -> InlineDefn = l:type_list() { InlineDefn::List(l) }\n        rule tt_inline_defn() -> TypeTerm = i:(id_map() / id_list()) { TypeTerm::InlineDefn(Box::new(i)) }\n        pub(crate) rule type_term() -> TypeTerm = tt:(tt_type_name() / tt_inline_defn()) { tt }\n\n        rule st_map() -> TypeStruct = \"struct\" _ws1()* \"{\" _ws_block() fs:(st_map_field()*) _ws1()* \"}\" {\n            let fields = fs.iter().cloned().map(|(f, s, _)| (f, s)).collect();\n            let representation = StructRepresentation::Map(struct_representation::Map {\n                fields: fs.into_iter().filter_map(|(f, _, x)| x.map(|x| (f, x))).collect()\n            });\n\n            TypeStruct { fields, representation }\n        }\n        rule st_map_field() -> (FieldName, StructField, Option<struct_representation::MapFieldDetails>) = _ws1()* n:field_name() _ws1()+ f:struct_field() x:st_map_field_details()? _ws1()* _eol() { (n, f, x) }\n        rule st_map_field_details() -> struct_representation::MapFieldDetails = _ws1()* \"(\" _ws1()* \"implicit\" _ws1()+ i:any_scalar()? _ws1()* \")\" { struct_representation::MapFieldDetails { implicit: i, rename: None } }\n\n        rule st_tuple() -> TypeStruct\n            = \"struct\" _ws1()* \"{\" _ws_block() fs:(st_map_field()*) _ws1()* \"}\"\n            _ws1()* \"representation\" _ws1()+ \"tuple\" _ws1()* o:st_field_order()?\n        {\n            let fields = fs.iter().cloned().map(|(f, s, _)| (f, s)).collect();\n            let representation = StructRepresentation::Tuple(struct_representation::Tuple {\n                field_order: o,\n            });\n\n            TypeStruct { fields, representation }\n        }\n        rule st_field_order() -> Vec<FieldName> = \"{\" _ws_block() \"fieldOrder\" _ws1()+ \"[\" fs:(quoted_field_name() ** (\",\" _ws_block())) \"]\" _ws_block() \"}\" { fs }\n\n        rule st_stringpairs() -> TypeStruct\n            = \"struct\" _ws1()* \"{\" _ws_block() fs:(st_map_field()*) _ws1()* \"}\"\n              // TODO: support either field ordering\n              _ws1()* \"representation\" _ws1()+ \"stringpairs\" _ws1()* \"{\" _eol() _ws1()* \"innerDelim\" _ws1()+ id:string() _eol() _ws1()* \"entryDelim\" _ws1()+ ed:string() _ws_block() \"}\"\n        {\n            TypeStruct {\n                fields: fs.iter().cloned().map(|(f, s, _)| (f, s)).collect(),\n                representation: StructRepresentation::StringPairs(struct_representation::StringPairs {\n                    inner_delim: id,\n                    entry_delim: ed,\n                }),\n            }\n        }\n\n        rule st_stringjoin() -> TypeStruct\n        = \"struct\" _ws1()* \"{\" _ws_block() fs:(st_map_field()*) _ws1()* \"}\"\n          // TODO: support either field ordering\n          _ws1()* \"representation\" _ws1()+ \"stringjoin\" _ws1()* \"{\" _eol() _ws1()* \"join\" _ws1()+ j:string() _ws_block() \"}\"\n        {\n            TypeStruct {\n                fields: fs.iter().cloned().map(|(f, s, _)| (f, s)).collect(),\n                representation: StructRepresentation::StringJoin(struct_representation::StringJoin {\n                    join: j,\n                    field_order: fs.into_iter().map(|(f, _, _)| f).collect::<Vec<_>>(),\n                }),\n            }\n        }\n\n        rule st_listpairs() -> TypeStruct\n        = \"struct\" _ws1()* \"{\" _ws_block() fs:(st_map_field()*) _ws1()* \"}\" _ws1()* \"representation\" _ws1()+ \"listpairs\"\n        {\n            TypeStruct {\n                fields: fs.iter().cloned().map(|(f, s, _)| (f, s)).collect(),\n                representation: StructRepresentation::ListPairs(struct_representation::ListPairs),\n            }\n        }\n\n        pub(crate) rule struct_model() -> TypeStruct = s:(\n            st_tuple() /\n            st_stringpairs() /\n            st_stringjoin() /\n            st_listpairs() /\n            st_map()\n        ) { s }\n\n\n        pub(crate) rule enum_value() -> EnumValue = cs:$((['A'..='Z'] / ['a'..='z'] / ['0'..='9'] / \"_\")+) { EnumValue(cs.to_string()) }\n        rule enum_member() -> EnumValue = _ws1()* \"|\" _ws1()* ev:enum_value() _ws1()* _eol() { ev }\n\n        rule type_decl() -> (TypeName, Type) = \"type\" _ws1()+ n:type_name() _ws1()+ t:r#type() (_eol() / _eof()) { (n, t) }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    use std::fs::read_to_string;\n\n    use insta::{assert_debug_snapshot, assert_json_snapshot, with_settings};\n    use pretty_assertions::assert_eq;\n    use test_strategy::proptest;\n\n    #[cfg(feature = \"fast-test\")]\n    const CASES: u32 = 10;\n    #[cfg(not(feature = \"fast-test\"))]\n    const CASES: u32 = 1000;\n\n    #[cfg(feature = \"fast-test\")]\n    const MAX_SHRINK_ITERS: u32 = 100;\n    #[cfg(not(feature = \"fast-test\"))]\n    const MAX_SHRINK_ITERS: u32 = 10000;\n\n    fn schema_schema() -> Schema {\n        schema_dsl::parse(&read_to_string(\"./specs/schemas/schema-schema.ipldsch\").unwrap())\n            .unwrap()\n    }\n\n    fn schema_schema_json() -> String {\n        read_to_string(\"./specs/schemas/schema-schema.ipldsch.json\").unwrap()\n    }\n\n    fn schema_roundtrips_through_json(schema: &Schema) {\n        assert_eq!(\n            *schema,\n            serde_json::from_str(&serde_json::to_string(schema).unwrap()).unwrap()\n        );\n    }\n\n    fn schema_roundtrips_through_dsl(schema: &Schema) {\n        let rendered = schema.to_string();\n\n        for (n, line) in rendered.lines().enumerate() {\n            eprintln!(\"  {:>4}  │ {}\", n + 1, line);\n        }\n\n        assert_eq!(*schema, schema_dsl::parse(&rendered).unwrap());\n    }\n\n    #[test]\n    fn snapshot_of_parsed_schema_schema() {\n        assert_debug_snapshot!(schema_schema());\n    }\n\n    #[test]\n    fn snapshot_of_reified_json_form_of_schema_schema() {\n        with_settings!({sort_maps => true}, {\n            assert_json_snapshot!(schema_schema())\n        });\n    }\n\n    #[test]\n    fn struct_representation_tuple_reifies_correctly() {\n        schema_roundtrips_through_json(\n            &schema_dsl::parse(\n                r#\"type StructRepresentation_Tuple struct {\n            fieldOrder optional [FieldName]\n        }\"#,\n            )\n            .unwrap(),\n        );\n    }\n\n    #[test]\n    fn reified_form_of_schema_schema_matches_parsed_dsl_form() {\n        assert_eq!(\n            schema_schema(),\n            serde_json::from_str(&schema_schema_json()).unwrap()\n        );\n    }\n\n    #[test]\n    fn schema_schema_roundtrips_through_parsing_and_display() {\n        schema_roundtrips_through_dsl(&schema_schema());\n    }\n\n    #[proptest(cases = CASES, max_shrink_iters = MAX_SHRINK_ITERS)]\n    fn roundtrips_through_dsl_form(schema: Schema) {\n        schema_roundtrips_through_dsl(&schema);\n    }\n\n    #[proptest(cases = CASES, max_shrink_iters = MAX_SHRINK_ITERS)]\n    fn roundtrips_through_json_form(schema: Schema) {\n        schema_roundtrips_through_json(&schema);\n    }\n}\n","traces":[{"line":159,"address":[7351376],"length":1,"stats":{"Line":1},"fn_name":"default"},{"line":160,"address":[7351388],"length":1,"stats":{"Line":1},"fn_name":null},{"line":172,"address":[6168587,6168768,6168880,6168797,6168909,6168560,6168656,6168685],"length":1,"stats":{"Line":4},"fn_name":"is_default<bool>"},{"line":173,"address":[6168574,6168665,6168707,6168777,6168889,6168819,6168931,6168609],"length":1,"stats":{"Line":8},"fn_name":null},{"line":227,"address":[7351408],"length":1,"stats":{"Line":3},"fn_name":"default"},{"line":228,"address":[7351420],"length":1,"stats":{"Line":1},"fn_name":null},{"line":262,"address":[7351440],"length":1,"stats":{"Line":1},"fn_name":"default"},{"line":263,"address":[7351452],"length":1,"stats":{"Line":1},"fn_name":null},{"line":276,"address":[7351472],"length":1,"stats":{"Line":0},"fn_name":"default"},{"line":278,"address":[7351486],"length":1,"stats":{"Line":0},"fn_name":null},{"line":479,"address":[7351568],"length":1,"stats":{"Line":0},"fn_name":"default"},{"line":480,"address":[7351575],"length":1,"stats":{"Line":0},"fn_name":null},{"line":531,"address":[7351632],"length":1,"stats":{"Line":1},"fn_name":"default"},{"line":532,"address":[7351639],"length":1,"stats":{"Line":3},"fn_name":null},{"line":574,"address":[7351696],"length":1,"stats":{"Line":1},"fn_name":"fmt"},{"line":575,"address":[7351713],"length":1,"stats":{"Line":1},"fn_name":null},{"line":580,"address":[7351872],"length":1,"stats":{"Line":1},"fn_name":"fmt"},{"line":581,"address":[7352019,7352465,7351895],"length":1,"stats":{"Line":2},"fn_name":null},{"line":582,"address":[7352099,7352470,7352497],"length":1,"stats":{"Line":1},"fn_name":null},{"line":584,"address":[7352009],"length":1,"stats":{"Line":1},"fn_name":null},{"line":589,"address":[7352512],"length":1,"stats":{"Line":1},"fn_name":"fmt"},{"line":591,"address":[7352535],"length":1,"stats":{"Line":1},"fn_name":null},{"line":596,"address":[7352704],"length":1,"stats":{"Line":1},"fn_name":"fmt"},{"line":597,"address":[7354716,7353076,7353498,7353920,7354131,7354330,7354909,7355102,7355219,7353287,7354523,7353709,7352868],"length":1,"stats":{"Line":12},"fn_name":null},{"line":598,"address":[7352878,7352727],"length":1,"stats":{"Line":2},"fn_name":null},{"line":599,"address":[7353089],"length":1,"stats":{"Line":1},"fn_name":null},{"line":600,"address":[7353300],"length":1,"stats":{"Line":1},"fn_name":null},{"line":601,"address":[7353511],"length":1,"stats":{"Line":1},"fn_name":null},{"line":602,"address":[7353722],"length":1,"stats":{"Line":1},"fn_name":null},{"line":603,"address":[7353933],"length":1,"stats":{"Line":1},"fn_name":null},{"line":604,"address":[7354144],"length":1,"stats":{"Line":1},"fn_name":null},{"line":605,"address":[7354343],"length":1,"stats":{"Line":1},"fn_name":null},{"line":606,"address":[7354536],"length":1,"stats":{"Line":1},"fn_name":null},{"line":607,"address":[7354729],"length":1,"stats":{"Line":1},"fn_name":null},{"line":608,"address":[7354922],"length":1,"stats":{"Line":1},"fn_name":null},{"line":609,"address":[7355119,7352786],"length":1,"stats":{"Line":2},"fn_name":null},{"line":635,"address":[7355248],"length":1,"stats":{"Line":1},"fn_name":"fmt"},{"line":636,"address":[7356614,7356272,7356443,7356101,7355759,7355930,7355570,7356729,7355384],"length":1,"stats":{"Line":8},"fn_name":null},{"line":637,"address":[7355271,7355400],"length":1,"stats":{"Line":2},"fn_name":null},{"line":638,"address":[7355589],"length":1,"stats":{"Line":1},"fn_name":null},{"line":639,"address":[7355778],"length":1,"stats":{"Line":1},"fn_name":null},{"line":640,"address":[7355949],"length":1,"stats":{"Line":1},"fn_name":null},{"line":641,"address":[7356120],"length":1,"stats":{"Line":1},"fn_name":null},{"line":642,"address":[7356291],"length":1,"stats":{"Line":1},"fn_name":null},{"line":643,"address":[7356462],"length":1,"stats":{"Line":1},"fn_name":null},{"line":644,"address":[7355330,7356631],"length":1,"stats":{"Line":2},"fn_name":null},{"line":650,"address":[7356752],"length":1,"stats":{"Line":1},"fn_name":"fmt"},{"line":651,"address":[7356912,7357296,7357715,7357826,7357102],"length":1,"stats":{"Line":2},"fn_name":null},{"line":652,"address":[7356775,7356922],"length":1,"stats":{"Line":2},"fn_name":null},{"line":653,"address":[7357122],"length":1,"stats":{"Line":1},"fn_name":null},{"line":655,"address":[7357541],"length":1,"stats":{"Line":0},"fn_name":null},{"line":656,"address":[7356836,7357729],"length":1,"stats":{"Line":0},"fn_name":null},{"line":662,"address":[7357856],"length":1,"stats":{"Line":1},"fn_name":"fmt"},{"line":663,"address":[7357887],"length":1,"stats":{"Line":1},"fn_name":null},{"line":668,"address":[7358048],"length":1,"stats":{"Line":1},"fn_name":"fmt"},{"line":669,"address":[7358079],"length":1,"stats":{"Line":1},"fn_name":null},{"line":674,"address":[7358240],"length":1,"stats":{"Line":1},"fn_name":"fmt"},{"line":675,"address":[7358257],"length":1,"stats":{"Line":1},"fn_name":null},{"line":680,"address":[7358416],"length":1,"stats":{"Line":1},"fn_name":"fmt"},{"line":681,"address":[7358525],"length":1,"stats":{"Line":0},"fn_name":null},{"line":682,"address":[7358439,7358532],"length":1,"stats":{"Line":2},"fn_name":null},{"line":689,"address":[4715840],"length":1,"stats":{"Line":1},"fn_name":"fmt"},{"line":690,"address":[4715871],"length":1,"stats":{"Line":1},"fn_name":null},{"line":695,"address":[7358864],"length":1,"stats":{"Line":1},"fn_name":"fmt"},{"line":696,"address":[7358895],"length":1,"stats":{"Line":1},"fn_name":null},{"line":701,"address":[7359056],"length":1,"stats":{"Line":1},"fn_name":"fmt"},{"line":702,"address":[7359087],"length":1,"stats":{"Line":1},"fn_name":null},{"line":707,"address":[7359248],"length":1,"stats":{"Line":1},"fn_name":"fmt"},{"line":708,"address":[7359272,7361432,7359962,7361950,7359369],"length":1,"stats":{"Line":4},"fn_name":null},{"line":709,"address":[7359279],"length":1,"stats":{"Line":1},"fn_name":null},{"line":710,"address":[7359624,7359379],"length":1,"stats":{"Line":2},"fn_name":null},{"line":711,"address":[7359404,7359657,7359626],"length":1,"stats":{"Line":1},"fn_name":null},{"line":713,"address":[7359692],"length":1,"stats":{"Line":1},"fn_name":null},{"line":715,"address":[7359975],"length":1,"stats":{"Line":1},"fn_name":null},{"line":716,"address":[7359997,7360250],"length":1,"stats":{"Line":2},"fn_name":null},{"line":717,"address":[7360030,7360252],"length":1,"stats":{"Line":1},"fn_name":null},{"line":719,"address":[7360319,7360900],"length":1,"stats":{"Line":1},"fn_name":null},{"line":720,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":722,"address":[7360312],"length":1,"stats":{"Line":1},"fn_name":null},{"line":724,"address":[7360943,7360845,7361150],"length":1,"stats":{"Line":2},"fn_name":null},{"line":725,"address":[7361190,7361373,7361092],"length":1,"stats":{"Line":2},"fn_name":null},{"line":726,"address":[7361409,7361350],"length":1,"stats":{"Line":2},"fn_name":null},{"line":728,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":729,"address":[7361666,7361445],"length":1,"stats":{"Line":1},"fn_name":null},{"line":730,"address":[7361668,7361470],"length":1,"stats":{"Line":0},"fn_name":null},{"line":732,"address":[7361719],"length":1,"stats":{"Line":1},"fn_name":null},{"line":733,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":735,"address":[7361712],"length":1,"stats":{"Line":1},"fn_name":null},{"line":744,"address":[7361968],"length":1,"stats":{"Line":1},"fn_name":"fmt"},{"line":745,"address":[7362207,7361991],"length":1,"stats":{"Line":2},"fn_name":null},{"line":746,"address":[7362236,7362026,7362209],"length":1,"stats":{"Line":1},"fn_name":null},{"line":748,"address":[7362255],"length":1,"stats":{"Line":1},"fn_name":null},{"line":755,"address":[7362416],"length":1,"stats":{"Line":1},"fn_name":"fmt"},{"line":756,"address":[7362453],"length":1,"stats":{"Line":1},"fn_name":null},{"line":761,"address":[7362688],"length":1,"stats":{"Line":1},"fn_name":"fmt"},{"line":762,"address":[7362705],"length":1,"stats":{"Line":1},"fn_name":null},{"line":767,"address":[7362864],"length":1,"stats":{"Line":1},"fn_name":"fmt"},{"line":768,"address":[7363405,7363212,7363598,7363791,7363902,7363022],"length":1,"stats":{"Line":4},"fn_name":null},{"line":769,"address":[7362887,7363032],"length":1,"stats":{"Line":2},"fn_name":null},{"line":770,"address":[7363225],"length":1,"stats":{"Line":1},"fn_name":null},{"line":771,"address":[7363418],"length":1,"stats":{"Line":0},"fn_name":null},{"line":772,"address":[7363611],"length":1,"stats":{"Line":1},"fn_name":null},{"line":773,"address":[7363805,7362946],"length":1,"stats":{"Line":2},"fn_name":null},{"line":779,"address":[5457232],"length":1,"stats":{"Line":1},"fn_name":"fmt"},{"line":780,"address":[5457510,5457540,5457269],"length":1,"stats":{"Line":1},"fn_name":null},{"line":781,"address":[5458027,5457668,5457492,5457557],"length":1,"stats":{"Line":3},"fn_name":null},{"line":782,"address":[5458032,5457734],"length":1,"stats":{"Line":1},"fn_name":null},{"line":784,"address":[5458064,5457651,5458190],"length":1,"stats":{"Line":3},"fn_name":null},{"line":785,"address":[5458192,5458094],"length":1,"stats":{"Line":1},"fn_name":null},{"line":787,"address":[5458241],"length":1,"stats":{"Line":1},"fn_name":null},{"line":792,"address":[5458480],"length":1,"stats":{"Line":1},"fn_name":"fmt"},{"line":793,"address":[5458758,5458517,5458788],"length":1,"stats":{"Line":1},"fn_name":null},{"line":794,"address":[5458805,5458740,5459276,5458916],"length":1,"stats":{"Line":3},"fn_name":null},{"line":795,"address":[5459281,5458982],"length":1,"stats":{"Line":1},"fn_name":null},{"line":797,"address":[5458899,5459313,5459439],"length":1,"stats":{"Line":3},"fn_name":null},{"line":798,"address":[5459441,5459343],"length":1,"stats":{"Line":1},"fn_name":null},{"line":800,"address":[5459490],"length":1,"stats":{"Line":1},"fn_name":null},{"line":805,"address":[5459728],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":806,"address":[5459765,5460066,5460036],"length":1,"stats":{"Line":0},"fn_name":null},{"line":807,"address":[5460083,5460012,5460599,5460203],"length":1,"stats":{"Line":0},"fn_name":null},{"line":808,"address":[5460604,5460269],"length":1,"stats":{"Line":0},"fn_name":null},{"line":810,"address":[5460639,5460177,5460771],"length":1,"stats":{"Line":0},"fn_name":null},{"line":811,"address":[5460773,5460669],"length":1,"stats":{"Line":0},"fn_name":null},{"line":813,"address":[5460822,5461208],"length":1,"stats":{"Line":0},"fn_name":null},{"line":814,"address":[5461241,5461134,5461539],"length":1,"stats":{"Line":0},"fn_name":null},{"line":815,"address":[5461458,5461809,5461572],"length":1,"stats":{"Line":0},"fn_name":null},{"line":816,"address":[5461845,5461786],"length":1,"stats":{"Line":0},"fn_name":null},{"line":821,"address":[5461888],"length":1,"stats":{"Line":1},"fn_name":"fmt"},{"line":822,"address":[5462197,5461926,5462228],"length":1,"stats":{"Line":1},"fn_name":null},{"line":823,"address":[5462365,5462173,5462245,5462731],"length":1,"stats":{"Line":3},"fn_name":null},{"line":824,"address":[5462736,5462431],"length":1,"stats":{"Line":1},"fn_name":null},{"line":826,"address":[5462339,5462771,5462897],"length":1,"stats":{"Line":3},"fn_name":null},{"line":827,"address":[5462801,5462899],"length":1,"stats":{"Line":1},"fn_name":null},{"line":829,"address":[5462963],"length":1,"stats":{"Line":1},"fn_name":null},{"line":830,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":832,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":838,"address":[5463360],"length":1,"stats":{"Line":1},"fn_name":"fmt"},{"line":839,"address":[5463397,5463638,5463668],"length":1,"stats":{"Line":1},"fn_name":null},{"line":840,"address":[5463620,5463685,5463796,5464156],"length":1,"stats":{"Line":3},"fn_name":null},{"line":841,"address":[5464161,5463862],"length":1,"stats":{"Line":1},"fn_name":null},{"line":843,"address":[5464319,5464193,5463779],"length":1,"stats":{"Line":3},"fn_name":null},{"line":844,"address":[5464223,5464321],"length":1,"stats":{"Line":1},"fn_name":null},{"line":846,"address":[5464370],"length":1,"stats":{"Line":1},"fn_name":null},{"line":851,"address":[7364032,7363936],"length":1,"stats":{"Line":1},"fn_name":"fmt"},{"line":852,"address":[7368480,7370483,7372197,7366081,7363965,7364115,7373325],"length":1,"stats":{"Line":2},"fn_name":null},{"line":853,"address":[7363972,7364139],"length":1,"stats":{"Line":2},"fn_name":null},{"line":854,"address":[7364154,7364408,7364438],"length":1,"stats":{"Line":1},"fn_name":null},{"line":855,"address":[7364390,7364573,7365836,7364459],"length":1,"stats":{"Line":3},"fn_name":null},{"line":856,"address":[7365002,7364639],"length":1,"stats":{"Line":1},"fn_name":null},{"line":857,"address":[7365036,7364976,7365806],"length":1,"stats":{"Line":3},"fn_name":null},{"line":858,"address":[7365100,7365275],"length":1,"stats":{"Line":1},"fn_name":null},{"line":859,"address":[7365655,7365305,7365222],"length":1,"stats":{"Line":2},"fn_name":null},{"line":860,"address":[7365340,7365657],"length":1,"stats":{"Line":1},"fn_name":null},{"line":862,"address":[7365808,7365704],"length":1,"stats":{"Line":1},"fn_name":null},{"line":865,"address":[7365980,7364553,7365848],"length":1,"stats":{"Line":3},"fn_name":null},{"line":866,"address":[7365878,7365982],"length":1,"stats":{"Line":1},"fn_name":null},{"line":868,"address":[7366029],"length":1,"stats":{"Line":1},"fn_name":null},{"line":870,"address":[7366108],"length":1,"stats":{"Line":0},"fn_name":null},{"line":871,"address":[7366377,7366123],"length":1,"stats":{"Line":0},"fn_name":null},{"line":872,"address":[7366916,7366407,7366359,7366521],"length":1,"stats":{"Line":0},"fn_name":null},{"line":873,"address":[7366921,7366587],"length":1,"stats":{"Line":0},"fn_name":null},{"line":875,"address":[7367088,7366956,7366501],"length":1,"stats":{"Line":0},"fn_name":null},{"line":876,"address":[7366986,7367090],"length":1,"stats":{"Line":0},"fn_name":null},{"line":878,"address":[7367139,7367496],"length":1,"stats":{"Line":0},"fn_name":null},{"line":879,"address":[7368442,7367467,7367524],"length":1,"stats":{"Line":0},"fn_name":null},{"line":880,"address":[7367705,7367564],"length":1,"stats":{"Line":0},"fn_name":null},{"line":881,"address":[7367948,7368222,7368101],"length":1,"stats":{"Line":0},"fn_name":null},{"line":882,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":884,"address":[7367682,7367751],"length":1,"stats":{"Line":0},"fn_name":null},{"line":885,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":886,"address":[6169012,6168992],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":887,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":888,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":890,"address":[7368444,7368340],"length":1,"stats":{"Line":0},"fn_name":null},{"line":892,"address":[7368472],"length":1,"stats":{"Line":0},"fn_name":null},{"line":894,"address":[7368507],"length":1,"stats":{"Line":0},"fn_name":null},{"line":895,"address":[7368522,7368776],"length":1,"stats":{"Line":0},"fn_name":null},{"line":896,"address":[7368758,7368806,7369315,7368920],"length":1,"stats":{"Line":0},"fn_name":null},{"line":897,"address":[7369320,7368986],"length":1,"stats":{"Line":0},"fn_name":null},{"line":899,"address":[7369355,7368900,7369487],"length":1,"stats":{"Line":0},"fn_name":null},{"line":900,"address":[7369489,7369385],"length":1,"stats":{"Line":0},"fn_name":null},{"line":902,"address":[7369538,7369912],"length":1,"stats":{"Line":0},"fn_name":null},{"line":903,"address":[7369955,7370183,7369854],"length":1,"stats":{"Line":0},"fn_name":null},{"line":904,"address":[7370226,7370119,7370424],"length":1,"stats":{"Line":0},"fn_name":null},{"line":905,"address":[7370460,7370401],"length":1,"stats":{"Line":0},"fn_name":null},{"line":907,"address":[7370510],"length":1,"stats":{"Line":0},"fn_name":null},{"line":908,"address":[7370779,7370525],"length":1,"stats":{"Line":0},"fn_name":null},{"line":909,"address":[7370923,7370761,7370809,7371318],"length":1,"stats":{"Line":0},"fn_name":null},{"line":910,"address":[7370989,7371323],"length":1,"stats":{"Line":0},"fn_name":null},{"line":912,"address":[7371490,7370903,7371358],"length":1,"stats":{"Line":0},"fn_name":null},{"line":913,"address":[7371492,7371388],"length":1,"stats":{"Line":0},"fn_name":null},{"line":915,"address":[7371912,7371541],"length":1,"stats":{"Line":0},"fn_name":null},{"line":916,"address":[7371857,7371955,7372138],"length":1,"stats":{"Line":0},"fn_name":null},{"line":917,"address":[7372115,7372174],"length":1,"stats":{"Line":0},"fn_name":null},{"line":919,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":920,"address":[7364061,7372387,7372217],"length":1,"stats":{"Line":0},"fn_name":null},{"line":921,"address":[7372885,7372526,7372369,7372415],"length":1,"stats":{"Line":0},"fn_name":null},{"line":922,"address":[7372592,7372890],"length":1,"stats":{"Line":0},"fn_name":null},{"line":924,"address":[7372922,7372509,7373048],"length":1,"stats":{"Line":0},"fn_name":null},{"line":925,"address":[7372952,7373050],"length":1,"stats":{"Line":0},"fn_name":null},{"line":927,"address":[7373099],"length":1,"stats":{"Line":0},"fn_name":null},{"line":934,"address":[7373376],"length":1,"stats":{"Line":1},"fn_name":"fmt"},{"line":935,"address":[7373393],"length":1,"stats":{"Line":1},"fn_name":null},{"line":940,"address":[7373552],"length":1,"stats":{"Line":1},"fn_name":"fmt"},{"line":941,"address":[7373575,7373791],"length":1,"stats":{"Line":2},"fn_name":null},{"line":942,"address":[7373610,7373793,7373820],"length":1,"stats":{"Line":1},"fn_name":null},{"line":944,"address":[7373839,7374057],"length":1,"stats":{"Line":1},"fn_name":null},{"line":945,"address":[7373864,7374059],"length":1,"stats":{"Line":0},"fn_name":null},{"line":947,"address":[7374089],"length":1,"stats":{"Line":1},"fn_name":null},{"line":952,"address":[7374256],"length":1,"stats":{"Line":1},"fn_name":"fmt"},{"line":953,"address":[7374652,7374380,7374549],"length":1,"stats":{"Line":2},"fn_name":null},{"line":954,"address":[7374279,7374387],"length":1,"stats":{"Line":2},"fn_name":null},{"line":955,"address":[7374563,7374304],"length":1,"stats":{"Line":2},"fn_name":null},{"line":961,"address":[7374672],"length":1,"stats":{"Line":1},"fn_name":"fmt"},{"line":962,"address":[7374965,7374796,7375068],"length":1,"stats":{"Line":2},"fn_name":null},{"line":963,"address":[7374803,7374695],"length":1,"stats":{"Line":2},"fn_name":null},{"line":964,"address":[7374979,7374720],"length":1,"stats":{"Line":2},"fn_name":null},{"line":970,"address":[7375088],"length":1,"stats":{"Line":1},"fn_name":"fmt"},{"line":971,"address":[7375369,7375125,7375342],"length":1,"stats":{"Line":1},"fn_name":null},{"line":973,"address":[7375383,7375764,7375324,7375491],"length":1,"stats":{"Line":3},"fn_name":null},{"line":974,"address":[7375769,7375557],"length":1,"stats":{"Line":1},"fn_name":null},{"line":976,"address":[7375798,7375921,7375474],"length":1,"stats":{"Line":3},"fn_name":null},{"line":977,"address":[7375828,7375923],"length":1,"stats":{"Line":1},"fn_name":null},{"line":979,"address":[7375967],"length":1,"stats":{"Line":1},"fn_name":null},{"line":986,"address":[7376032],"length":1,"stats":{"Line":1},"fn_name":"fmt"},{"line":987,"address":[7376049],"length":1,"stats":{"Line":1},"fn_name":null},{"line":992,"address":[7376208],"length":1,"stats":{"Line":1},"fn_name":"fmt"},{"line":993,"address":[7376245],"length":1,"stats":{"Line":1},"fn_name":null},{"line":997,"address":[4314667,4320186,4252928,4320862,4324183,4312667,4253600,4218352,4313383,4336479,4220015,4266272,4309702,4336722,4241846,4349569,4223632,4224750,4242390,4251074,4252333,4257819,4281819,4329486,4330968,4331492,4346571,4358763,4294487,4229757,4359727,4372489,4218402,4254850,4263938,4374075,4378306,4235803,4381573,4225699,4257908,4387414,4224427,4300275,4312736,4384679,4377651,4214071,4239543,4314704,4386862,4320845,4224329,4365762,4249506,4348924,4380893,4234644,4340273,4269939,4304049,4339616,4299746,4337191,4311904,4317866,4240289,4243541,4251472,4266673,4213472,4352337,4287624,4326415,4363166,4268701,4316294,4363422,4385208,4377770,4364073,4321874,4211388,4217492,4264726,4374185,4253314,4275655,4329250,4343235,4237502,4344638,4285027,4295073,4226780,4238557,4363250,4353763,4362010,4386919,4252082,4219636,4257320,4254432,4223455,4320699,4331301,4363715,4381922,4222933,4254755,4225539,4374722,4294216,4254347,4370487,4388111,4241011,4231334,4327970,4378704,4380424,4338249,4371680,4284278,4380017,4314304,4371721,4304506,4286335,4311867,4252978,4278873,4296471,4298092,4316644,4302272,4345818,4256493,4362114,4386335,4388081,4246930,4290690,4385846,4342049,4268164,4317088,4325812,4329922,4386957,4342647,4240344,4225648,4349168,4221261,4271635,4275048,4266113,4249420,4317123,4337886,4353312,4360224,4375726,4341942,4246443,4263986,4254233,4285997,4315904,4385346,4225264,4229567,4250576,4286125,4302033,4324631,4367955,4383473,4271584,4336571,4233035,4331475,4249997,4307458,4350158,4355707,4230790,4302638,4231853,4301981,4312183,4215470,4248361,4270306,4224974,4302053,4307187,4351558,4231948,4345171,4327259,4363284,4252781,4264189,4258926,4288497,4253264,4330752,4295728,4380049,4388774,4389442,4311432,4336672,4253551,4240385,4240656,4313467,4262289,4242909,4262634,4245417,4360462,4211718,4245181,4368708,4222175,4236767,4212780,4271326,4264546,4292929,4356354,4325584,4330662,4247448,4353609,4367052,4388439,4361772,4254800,4273513,4223658,4359978,4294312,4300867,4263514,4248126,4251024,4333136,4246504,4225314,4216688,4224798,4334192,4258067,4338345,4350639,4389544,4363387,4220648,4294672,4317028,4335741,4339225,4284608,4304354,4257770,4262824,4333537,4354121,4237264,4312583,4346822,4237582,4252882,4290038,4350395,4375475,4370169,4321284,4212044,4256916,4315945,4388870,4240687,4251426,4317790,4369672,4227078,4274803,4341358,4305790,4217227,4325299,4226290,4255498,4347068,4376721,4224312,4251773,4325160,4271477,4328205,4385296,4309104,4304566,4306176,4321824,4343121,4358010,4286084,4291443,4240960,4387059,4288022,4254377,4388202,4308975,4245654,4244450,4276734,4325248,4352680,4332082,4213032,4310242,4329200,4332173,4308820,4262324,4317539,4255136,4349219,4232485,4305930,4353712,4320964,4277345,4387877,4280163,4217373,4311504,4250487,4284516,4337331,4387642,4321332,4342967,4211344,4365667,4338452,4294456,4253214,4313104,4278778,4296566,4251325,4340899,4279410,4228207,4311936,4217972,4278398,4310324,4311536,4246532,4221858,4276675,4262608,4318336,4348893,4230313,4361526,4381380,4306367,4328451,4216208,4234398,4264768,4273418,4378146,4258016,4377509,4345281,4348945,4310561,4353554,4357604,4217390,4312704,4313936,4328790,4284032,4337577,4364728,4212736,4276928,4281066,4229594,4229726,4212000,4241602,4227597,4252480,4246722,4292861,4298329,4233394,4381492,4383176,4376772,4269699,4215647,4230546,4264496,4217860,4223844,4312267,4237018,4322643,4341123,4292383,4286269,4273038,4310179,4371896,4213522,4224170,4355174,4252530,4299696,4378397,4229518,4252032,4296126,4311321,4320376,4326144,4331922,4339133,4318386,4246691,4308893,4220902,4303633,4314583,4337840,4220269,4344240,4380747,4326812,4288402,4266323,4240412,4327024,4354776,4227692,4226057,4297853,4258976,4215526,4239124,4378754,4371865,4244091,4329148,4329586,4314336,4290284,4324850,4229059,4319987,4259048,4286304,4329823,4254482,4381012,4248884,4276826,4299493,4361275,4251985,4253651,4215276,4266134,4306647,4216714,4318206,4327758,4375972,4250357,4231036,4343019,4382394,4303126,4263395,4309154,4225584,4320010,4335226,4314267,4314776,4252434,4316352,4242092,4283323,4367303,4349030,4372147,4247555,4380910,4383952,4267726,4360542,4365126,4264818,4313504,4246880,4323904,4217812,4266081,4254393,4272640,4286611,4327502,4366299,4370407,4316196,4378194,4389569,4216016,4321444,4330778,4376800,4384898,4387008,4250978,4275288,4278000,4313136,4229939,4253919,4317504,4328822,4332530,4363664,4282759,4248607,4292132,4329872,4283005,4241369,4315872,4343184,4348312,4355817,4289034,4292623,4373144,4386442,4312983,4326464,4320160,4298696,4304690,4332480,4250626,4384231,4376938,4221749,4330604,4350991,4216655,4313867,4328962,4243004,4302136,4380070,4240224,4240590,4317450,4311783,4333187,4211935,4256107,4318282,4339198,4263253,4299585,4313536,4389395,4329536,4328838,4223542,4363219,4382114,4299434,4310760,4312304,4336432,4301308,4339428,4323425,4218986,4326319,4216063,4229888,4302323,4343585,4316800,4357107,4331594,4372096,4376912,4377668,4212617,4224910,4274050,4353493,4238315,4306944,4250405,4255087,4322346,4316393,4301104,4271985,4282508,4240313,4294723,4323128,4280414,4238794,4305287,4264098,4271385,4389462,4221808,4258992,4313783,4213353,4377128,4317955,4367549,4294271,4276979,4255187,4328912,4226534,4235050,4262257,4339666,4380234,4382691,4297103,4326515,4269454,4369923,4381872,4283243,4326376,4332997,4314183,4247902,4286560,4373542,4380208,4268069,4313904,4321525,4376345,4300748,4381332,4218053,4335131,4312336,4247504,4289787,4301406,4211328,4251522,4239032,4258335,4250877,4302161,4316850,4333050,4331970,4215600,4371626,4219382,4223388,4293348,4234147,4267328,4370927,4317920,4218720,4246559,4339185,4222865,4212296,4228739,4362539,4256848,4317374,4347471,4258978,4319934,4313067,4357358,4311394,4351199,4322066,4334590,4286053,4286969,4342156,4246021,4216904,4316742,4304640,4280660,4240625,4283781,4263412,4214840],"length":1,"stats":{"Line":835},"fn_name":"new"},{"line":1003,"address":[4215218,4215434],"length":1,"stats":{"Line":4},"fn_name":null},{"line":1007,"address":[4221635,4219435,4220068,4220701,4218773],"length":1,"stats":{"Line":14},"fn_name":null},{"line":1009,"address":[4222793,4223236],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1012,"address":[4225381,4225599],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1015,"address":[4227541,4228699,4226766],"length":1,"stats":{"Line":5},"fn_name":null},{"line":1017,"address":[4229335],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1018,"address":[4229179],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1019,"address":[4229219],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1020,"address":[4229259],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1021,"address":[4229295],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1025,"address":[4232995,4231022,4231797],"length":1,"stats":{"Line":5},"fn_name":null},{"line":1027,"address":[4238960,4237430],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1029,"address":[4240038],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1030,"address":[4239663],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1031,"address":[4239703],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1032,"address":[4239743],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1033,"address":[4239771],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1037,"address":[4242078,4244051,4242853],"length":1,"stats":{"Line":5},"fn_name":null},{"line":1039,"address":[4246261],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1040,"address":[4246141],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1041,"address":[4246181],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1042,"address":[4246221],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1043,"address":[4246249],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1053,"address":[4250117,4249348,4248593],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1055,"address":[4250964],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1056,"address":[4251412],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1057,"address":[4251863],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1058,"address":[4252420],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1059,"address":[4252868],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1060,"address":[4253055],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1061,"address":[4253391],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1062,"address":[4254095],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1063,"address":[4254559],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1064,"address":[4254927],"length":1,"stats":{"Line":4},"fn_name":null},{"line":1065,"address":[4257440,4256782],"length":1,"stats":{"Line":10},"fn_name":null},{"line":1066,"address":[4258717],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1067,"address":[4262147],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1080,"address":[4262207],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1081,"address":[4264623],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1084,"address":[4265971],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1090,"address":[4266031],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1091,"address":[4271093,4268013],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1092,"address":[4273362,4276442],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1093,"address":[4285555,4283171,4278722,4284444],"length":1,"stats":{"Line":4},"fn_name":null},{"line":1094,"address":[4288346,4292789,4293876],"length":1,"stats":{"Line":11},"fn_name":null},{"line":1095,"address":[4299224,4296415],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1097,"address":[4300708,4301252,4301768],"length":1,"stats":{"Line":8},"fn_name":null},{"line":1098,"address":[4304465,4304017],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1100,"address":[4306679,4307956,4305750,4307426],"length":1,"stats":{"Line":4},"fn_name":null},{"line":1102,"address":[4311201,4310746,4310139],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1103,"address":[4311862],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1104,"address":[4312262],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1105,"address":[4312662],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1106,"address":[4313062],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1107,"address":[4313462],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1108,"address":[4313862],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1109,"address":[4314262],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1110,"address":[4314662],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1111,"address":[4315861],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1122,"address":[4316279],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1123,"address":[4316727],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1124,"address":[4316922],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1125,"address":[4317465,4317495],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1126,"address":[4317881,4317911],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1127,"address":[4318297,4318327],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1128,"address":[4319813],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1135,"address":[4319865],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1138,"address":[4323936,4323160,4325046,4322378],"length":1,"stats":{"Line":7},"fn_name":null},{"line":1139,"address":[4326258,4325772],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1141,"address":[4327488,4328434,4328550,4328670],"length":1,"stats":{"Line":5},"fn_name":null},{"line":1143,"address":[4329038],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1144,"address":[4329327],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1145,"address":[4329663],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1146,"address":[4330574,4330255],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1147,"address":[4332876],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1149,"address":[4335075],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1150,"address":[4335874],"length":1,"stats":{"Line":9},"fn_name":null},{"line":1151,"address":[4336124],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1152,"address":[4335997,4336117],"length":1,"stats":{"Line":14},"fn_name":null},{"line":1155,"address":[4336232],"length":1,"stats":{"Line":4},"fn_name":null},{"line":1157,"address":[4337151,4338280,4338829,4337744],"length":1,"stats":{"Line":6},"fn_name":null},{"line":1158,"address":[4341969,4342763],"length":1,"stats":{"Line":4},"fn_name":null},{"line":1161,"address":[4345123],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1162,"address":[4348343],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1164,"address":[4348396,4348468],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1165,"address":[4348585],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1166,"address":[4348537],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1169,"address":[4348693],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1171,"address":[4352297,4353429],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1174,"address":[4355659],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1176,"address":[4360390,4361938],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1178,"address":[4363062],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1179,"address":[4362672],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1180,"address":[4362907],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1181,"address":[4362795],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1182,"address":[4362851],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1188,"address":[4365611],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1190,"address":[4370335],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1192,"address":[4371521],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1193,"address":[4371060],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1194,"address":[4371366],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1195,"address":[4371183],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1196,"address":[4371223,4371359],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1202,"address":[4374027],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1204,"address":[4376613],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1205,"address":[4376478],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1206,"address":[4376601],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1210,"address":[4379907],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1216,"address":[4379967],"length":1,"stats":{"Line":4},"fn_name":null},{"line":1219,"address":[4382426,4383984,4385094,4383208],"length":1,"stats":{"Line":4},"fn_name":null},{"line":1220,"address":[4386279,4386801],"length":1,"stats":{"Line":4},"fn_name":null},{"line":1222,"address":[4388041,4388606,4389180],"length":1,"stats":{"Line":6},"fn_name":null}],"covered":245,"coverable":341}]}